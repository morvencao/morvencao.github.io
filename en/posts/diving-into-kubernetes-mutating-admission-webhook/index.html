<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.104.3"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Morven's Life"><meta property="og:url" content="https://morven.life/en/posts/diving-into-kubernetes-mutating-admission-webhook/"><link rel=canonical href=https://morven.life/en/posts/diving-into-kubernetes-mutating-admission-webhook/><link rel=apple-touch-icon href=https://morven.life/favicon.ico><link rel=icon href=https://morven.life/favicon.ico><link rel=shortcut href=https://morven.life/favicon.ico><link rel=alternate type=application/atom+xml href=https://morven.life/index.xml title="Morven's Life"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/morven.life\/"},"articleSection":"posts","name":"Diving into Kubernetes MutatingAdmissionWebhook","headline":"Diving into Kubernetes MutatingAdmissionWebhook","description":"Update: With the latest changes in the source code repository for this tutorial, I replaced the webhook server certificate created by the CertificateSigningRequest API and CA bundle patch process with self-generated CA and certificate, all the process will be done in the webhook server pod, so we won’t need the manual certificate creating and patch steps.\nAdmission controllers are powerful tools for intercepting requests to the Kubernetes API server prior to persistence of the object.","inLanguage":"en-US","author":"Morven\u0027s Life","creator":"Morven\u0027s Life","publisher":"Morven\u0027s Life","accountablePerson":"Morven\u0027s Life","copyrightHolder":"Morven\u0027s Life","copyrightYear":"2018","datePublished":"2018-04-10 00:00:00 \u002b0000 UTC","dateModified":"2018-04-10 00:00:00 \u002b0000 UTC","url":"https:\/\/morven.life\/en\/posts\/diving-into-kubernetes-mutating-admission-webhook\/","keywords":[]}</script><title>Diving into Kubernetes MutatingAdmissionWebhook</title><meta property="og:title" content="Diving into Kubernetes MutatingAdmissionWebhook"><meta property="og:type" content="article"><meta property="og:description" content="Update: With the latest changes in the source code repository for this tutorial, I replaced the webhook server certificate created by the CertificateSigningRequest API and CA bundle patch process with self-generated CA and certificate, all the process will be done in the webhook server pod, so we won’t need the manual certificate creating and patch steps.
Admission controllers are powerful tools for intercepting requests to the Kubernetes API server prior to persistence of the object."><meta name=description content="Update: With the latest changes in the source code repository for this tutorial, I replaced the webhook server certificate created by the CertificateSigningRequest API and CA bundle patch process with self-generated CA and certificate, all the process will be done in the webhook server pod, so we won’t need the manual certificate creating and patch steps.
Admission controllers are powerful tools for intercepting requests to the Kubernetes API server prior to persistence of the object."><meta property="og:locale" content="en-us"><style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body blockquote{background-color:#f8f8f8;border-left:2px solid;margin:40px;padding:10px 20px}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:85%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.signatures{font-family:permanent marker,Impact,Charcoal,sans-serif;font-size:3rem;margin-top:32px}.signatures a{text-decoration:none}.header-line{width:100%;height:3px;background-color:#000;margin:18px 0}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-date,.posts-title{font-size:1.2rem}.posts-line{margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px;margin-bottom:3px}.site-footer{margin-top:50px;margin-bottom:80px;display:flex;justify-content:flex-end;flex-wrap:wrap;padding:12px 0;border-width:3px;border-color:#000}.site-footer-item{margin-right:12px}@media screen and (max-width:600px){.site-header{display:none}.post-content{padding:0 12px}.post-content p{letter-spacing:.05em}}@media screen and (max-width:48em){.posts-category{display:none}}.post-content img{max-width:100%;display:block;margin-left:auto;margin-right:auto;margin-top:12px}.post-header{margin-bottom:50px}.post-title{font-size:2.5rem;font-weight:600}.post-category{display:inline;font-weight:900;margin:0 4px;padding:2px 5px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}</style><style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style><link href=https://morven.life/index.xml rel=alternate type=application/rss+xml title="Morven's Life"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class="post English" id=article><div class=row><div class=col-xs-12><header class=post-header><h1 class=post-title>Diving into Kubernetes MutatingAdmissionWebhook</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-04-10 00:00:00 UTC">10 Apr 2018</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://morven.life/>@Morven's Life</a></div></div></div></header><div class="post-content markdown-body"><p><em><strong>Update:</strong> With the latest changes in the <a href=https://github.com/morvencao/kube-sidecar-injector>source code repository</a> for this tutorial, I replaced the webhook server certificate created by the <code>CertificateSigningRequest</code> API and CA bundle patch process with self-generated CA and certificate, all the process will be done in the webhook server pod, so we won’t need the manual certificate creating and patch steps.</em></p><p><a href=https://kubernetes.io/docs/admin/admission-controllers/>Admission controllers</a> are powerful tools for intercepting requests to the Kubernetes API server prior to persistence of the object. However, they are not very flexible due to the requirement that they are compiled as a binary in the <code>kube-apiserver</code> that is configured by the cluster administrator. Starting in Kubernetes 1.7, <a href=https://v1-8.docs.kubernetes.io/docs/admin/extensible-admission-controllers/#initializers>Initializers</a> and <a href=https://v1-8.docs.kubernetes.io/docs/admin/extensible-admission-controllers/#external-admission-webhooks>External Admission Webhooks</a> are introduced to address this limitation. In Kubernetes 1.9, <code>Initializers</code> stays in alpha phase while <code>External Admission Webhooks</code> are promoted to beta and split into <a href=https://kubernetes.io/docs/admin/admission-controllers/#mutatingadmissionwebhook-beta-in-19>MutatingAdmissionWebhook</a> and <a href=https://kubernetes.io/docs/admin/admission-controllers/#validatingadmissionwebhook-alpha-in-18-beta-in-19>ValidatingAdmissionWebhook</a>.</p><p><code>MutatingAdmissionWebhook</code> together with <code>ValidatingAdmissionWebhook</code> are a special kind of <code>admission controllers</code> which process mutations and validations. This validation is done by matching the rules that are defined in the <a href=https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#mutatingwebhookconfiguration-v1beta1-admissionregistration>MutatingWebhookConfiguration</a>(explained below).</p><p>In this article, I will dive into the details of a <code>MutatingAdmissionWebhook</code> and write a working webhook admission server step-by-step.</p><h2 id=benefit-of-webhooks>Benefit of Webhooks</h2><p>Kubernetes cluster administrators can use <code>webhooks</code> to create additional mutating and validating admission plugins to the admission chain of <code>apiserver</code> without recompiling them. This provides developers with the freedom and flexibility to customize admission logic on multiple actions such CREATE, UPDATE, and DELETE on any resource. The number of applications that can be used are vast. Some common use cases include:</p><ul><li>Mutating resources before creating them. <a href=https://github.com/istio>Istio</a>, a representative example, injects an <a href=https://github.com/envoyproxy/envoy>Envoy</a> sidecar container to target pods to implement traffic management and policy enforcement.</li><li>Automated provisioning of <code>StorageClass</code>. Observes creation of <code>PersistentVolumeClaim</code> objects and automatically adds storage class to them based on predefined policy. Users that do not need to care about <code>StorageClass</code> creating.</li><li>Validating complex custom resource. Make sure custom resource can only be created after its definition and all dependencies created and available.</li><li>Restricting namespace. On multi-tenant systems, avoid resources created in reserved namespaces.</li></ul><p>Besides the user-cases listed above, many more applications can be created based on the power of <code>webhooks</code>.</p><h2 id=webhooks-vs-initializers>Webhooks vs Initializers</h2><p>Based on feedback from the community and use cases in alpha phase for both <code>External Admission Webhooks</code> and <code>Initializers</code>, the Kubernetes community decided to promote webhooks to beta and split it into two types of webhooks (<code>MutatingAdmissionWebhook</code> and <code>ValidatingAdmissionWebhook</code>). These updates make webhooks consistent with other admission controllers and enforce <code>mutate-before-validate</code>. <code>Initializers</code> can also implement dynamic admission control by modifying Kubernetes resources before they are actually created. If you&rsquo;re unfamiliar with <code>Initializers</code>, please refer to the article: <a href=https://medium.com/ibm-cloud/kubernetes-initializers-deep-dive-and-tutorial-3bc416e4e13e>https://medium.com/ibm-cloud/kubernetes-initializers-deep-dive-and-tutorial-3bc416e4e13e</a>.</p><p>So what’s the difference between <code>Webhooks</code> and <code>Initializers</code>?</p><ul><li><code>Webhooks</code> can be applied on more actions, including &lsquo;mutate&rsquo; or &lsquo;admit&rsquo; on resoures &lsquo;CREATE&rsquo; &lsquo;UPDATE&rsquo; and &lsquo;DELETE&rsquo;, whereas <code>Initializers</code> can&rsquo;t &lsquo;admit&rsquo; resources for &lsquo;DELETE&rsquo; requests.</li><li><code>Webhooks</code> are not allowed to query resources before created, while <code>Initializers</code> are capable of watching the uninitialized resources by the query parameter <code>?includeUninitialized=true</code>, which makes the resource creation progress transparent.</li><li>Since <code>Initializers</code> persist the &lsquo;pre-create&rsquo; states to <code>etcd</code>, higher latency and increased <code>etcd</code> burden will be introduced accordingly, especially when <code>apiserver</code> upgrades or fails. <code>Webhooks</code>, however, consume less memory and computing resources.</li><li><code>Webhooks</code> provide more robustness on failures than <code>Initializers</code>. Failure policies can be configured in <code>Webhooks</code> configuraton to avoid hanging onto resources that are created. Buggy <code>Initializers</code>, on the other hand, may block all matched resources attempted to be created.</li></ul><p>Besides the differences listed above, <code>Initializer</code> has some significant issues currently as open issues with long expected development time including quota replenishment bug. Promotion of <code>Webhooks</code> to beta may be a signal that more support for it in the future, but that depends. If stable behavior is preferred, I suggest you choose <code>Webhooks</code>.</p><h2 id=how-mutatingadmissionwebhook-works>How MutatingAdmissionWebhook works</h2><p><code>MutatingAdmissionWebhook</code> intercepts requests matching the rules defined in <code>MutatingWebhookConfiguration</code> before presisting into <code>etcd</code>. <code>MutatingAdmissionWebhook</code> executes the mutation by sending admission requests to webhook server. Webhook server is just plain http server that adhere to the <a href=https://github.com/kubernetes/kubernetes/blob/v1.9.0/pkg/apis/admission/types.go>API</a>.</p><p>The following diagram describes how <code>MutatingAdmissionWebhook</code> works in details:</p><p><img src=https://i.loli.net/2019/03/17/5c8dede75dfde.jpg alt></p><p>The <code>MutatingAdmissionWebhook</code> needs three objects to function:</p><ol><li><strong>MutatingWebhookConfiguration</strong></li></ol><p><code>MutatingAdmissionWebhook</code> needs to be registered in the <code>apiserver</code> by providing <code>MutatingWebhookConfiguration</code>. During the registration process, <code>MutatingAdmissionWebhook</code> states:</p><ul><li>How to connect to the webhook admission server</li><li>How to verify the webhook admission server</li><li>The URL path of the webhook admission server</li><li>Rules defining which resource and what action it handles</li><li>How unrecognized errors from the webhook admission server are handled</li></ul><ol start=2><li><strong>MutatingAdmissionWebhook itself</strong></li></ol><p><code>MutatingAdmissionWebhook</code> is a plugin-style admission controller that can be configured into the <code>apiserver</code>. The <code>MutatingAdmissionWebhook</code> plugin get the list of interested admission webhooks from <code>MutatingWebhookConfiguration</code>. Then the <code>MutatingAdmissionWebhook</code> observes the requests to <code>apiserver</code> and intercepts requests matching the rules in admission webhooks and calls them in parallel.</p><ol start=3><li><strong>Webhook Admission Server</strong></li></ol><p>Webhook Admission Server is just plain http server that adhere to Kubernetes <a href=https://github.com/kubernetes/kubernetes/blob/v1.9.0/pkg/apis/admission/types.go>admission API</a>. For each request to the <code>apiserver</code>, the <code>MutatingAdmissionWebhook</code> sends an <code>admissionReview</code>(<a href=https://github.com/kubernetes/kubernetes/blob/v1.9.0/pkg/apis/admission/types.go>API</a> for reference) to the relevant webhook admission server. The webhook admission server gathers information like <code>object</code>, <code>oldobject</code>, and <code>userInfo</code> from <code>admissionReview</code>, and sends back an <code>admissionReview</code> response including <code>AdmissionResponse</code> whose <code>Allowed</code> and <code>Result</code> fields are filled with the admission decision and optional <code>Patch</code> to mutate the resoures.</p><h2 id=tutorial-for-mutatingadmissionwebhook>Tutorial for MutatingAdmissionWebhook</h2><p>Writing a complete Webhook Admission Server may be intimidating. To make it easier, we’ll write a simple Webhook Admission Server that implements injecting nginx sidecar container and volume. The complete code can be found in the <a href=https://github.com/morvencao/kube-mutating-webhook-tutorial>kube-mutating-webhook-tutorial</a>. This project refers to `Kunernetes webhook example](<a href=https://github.com/kubernetes/kubernetes/tree/release-1.9/test/images/webhook>https://github.com/kubernetes/kubernetes/tree/release-1.9/test/images/webhook</a>) and <a href=https://github.com/istio/istio/tree/master/pilot/pkg/kube/inject>Istio sidecar injection implementation</a>.</p><p>In the following sections, I’ll show you how to write a working containerized webhook admission server and deploy it to a Kubernetes cluster.</p><h3 id=prerequisites>Prerequisites</h3><p><code>MutatingAdmissionWebhook</code> requires a Kubernetes 1.9.0 or above with the <code>admissionregistration.k8s.io/v1beta1</code> API enabled. Verify that by the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>kubectl api-versions | grep admissionregistration.k8s.io/v1beta1
</span></span></code></pre></div><p>The result should not be empty.</p><p>In addition, the <code>MutatingAdmissionWebhook</code> and <code>ValidatingAdmissionWebhook</code> admission controllers should be added and listed in the correct order in the <code>admission-control</code> flag of <code>kube-apiserver</code>.</p><h3 id=write-the-webhook-server>Write the Webhook Server</h3><p>Webhook Admission Server is just a simple http server that adheres to the <a href=https://github.com/kubernetes/kubernetes/blob/v1.9.0/pkg/apis/admission/types.go>Kubernetes admission API</a>. I&rsquo;ll paste some pseudo code to describe the main logic:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>sidecarConfig, err := loadConfig(parameters.sidecarCfgFile)
</span></span><span style=display:flex><span>pair, err := tls.LoadX509KeyPair(parameters.certFile, parameters.keyFile)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>whsvr := &amp;WebhookServer {
</span></span><span style=display:flex><span>    sidecarConfig:    sidecarConfig,
</span></span><span style=display:flex><span>    server:           &amp;http.Server {
</span></span><span style=display:flex><span>        Addr:        fmt.Sprintf(&#34;:%v&#34;, 443),
</span></span><span style=display:flex><span>        TLSConfig:   &amp;tls.Config{Certificates: []tls.Certificate{pair}},
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>// define http server and server handler
</span></span><span style=display:flex><span>mux := http.NewServeMux()
</span></span><span style=display:flex><span>mux.HandleFunc(&#34;/mutate&#34;, whsvr.serve)
</span></span><span style=display:flex><span>whsvr.server.Handler = mux
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// start webhook server in new rountine
</span></span><span style=display:flex><span>go func() {
</span></span><span style=display:flex><span>    if err := whsvr.server.ListenAndServeTLS(&#34;&#34;, &#34;&#34;); err != nil {
</span></span><span style=display:flex><span>        glog.Errorf(&#34;Filed to listen and serve webhook server: %v&#34;, err)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}()
</span></span></code></pre></div><p>Explanation for the above code:</p><ul><li><code>sidecarCfgFile</code> contains sidecar injector template defined in <code>ConfigMap</code> below.</li><li><code>certFile</code> and <code>keyFile</code> key pair that will be needed for TLS communication between <code>apiserver</code> and webhook server.</li><li>Line 19 starts https server listening on 443 on path <code>/mutate</code>.</li></ul><p>Next we’ll focus on the main logic of the handler function serve:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>// Serve method for webhook server
</span></span><span style=display:flex><span>func (whsvr *WebhookServer) serve(w http.ResponseWriter, r *http.Request) {
</span></span><span style=display:flex><span>	var body []byte
</span></span><span style=display:flex><span>	if r.Body != nil {
</span></span><span style=display:flex><span>		if data, err := ioutil.ReadAll(r.Body); err == nil {
</span></span><span style=display:flex><span>			body = data
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	var reviewResponse *v1beta1.AdmissionResponse
</span></span><span style=display:flex><span>	ar := v1beta1.AdmissionReview{}
</span></span><span style=display:flex><span>	deserializer := codecs.UniversalDeserializer()
</span></span><span style=display:flex><span>	if _, _, err := deserializer.Decode(body, nil, &amp;ar); err != nil {
</span></span><span style=display:flex><span>		glog.Error(err)
</span></span><span style=display:flex><span>		reviewResponse = toAdmissionResponse(err)
</span></span><span style=display:flex><span>	} else {
</span></span><span style=display:flex><span>		reviewResponse = mutate(ar)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	response := v1beta1.AdmissionReview{}
</span></span><span style=display:flex><span>	if reviewResponse != nil {
</span></span><span style=display:flex><span>		response.Response = reviewResponse
</span></span><span style=display:flex><span>		response.Response.UID = ar.Request.UID
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	// reset the Object and OldObject, they are not needed in a response.
</span></span><span style=display:flex><span>	ar.Request.Object = runtime.RawExtension{}
</span></span><span style=display:flex><span>	ar.Request.OldObject = runtime.RawExtension{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	resp, err := json.Marshal(response)
</span></span><span style=display:flex><span>	if err != nil {
</span></span><span style=display:flex><span>		glog.Error(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	if _, err := w.Write(resp); err != nil {
</span></span><span style=display:flex><span>		glog.Error(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>serve</code> function is a simple http handler with http request and response writer parameters.</p><ul><li>First demarshal the request to AdmissionReview, which contains information like <code>object</code>, <code>oldobject</code> and <code>userInfo</code>&mldr;</li><li>Then call Webhook core function <code>mutate</code> to create patch that injects sidecar container and volume.</li><li>Finally, demarshal the response with admission decision and optional patch, the send it back to <code>apiserver</code>.</li></ul><p>For the part of <code>mutate</code> function, you get the free rein to complete it in your preferred way. Let&rsquo;s take my implementation as an example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>// main mutation process
</span></span><span style=display:flex><span>func (whsvr *WebhookServer) mutate(ar *v1beta1.AdmissionReview) *v1beta1.AdmissionResponse {
</span></span><span style=display:flex><span>	req := ar.Request
</span></span><span style=display:flex><span>	var pod corev1.Pod
</span></span><span style=display:flex><span>	if err := json.Unmarshal(req.Object.Raw, &amp;pod); err != nil {
</span></span><span style=display:flex><span>		glog.Errorf(&#34;Could not unmarshal raw object: %v&#34;, err)
</span></span><span style=display:flex><span>		return &amp;v1beta1.AdmissionResponse {
</span></span><span style=display:flex><span>			Result: &amp;metav1.Status {
</span></span><span style=display:flex><span>				Message: err.Error(),
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	// determine whether to perform mutation
</span></span><span style=display:flex><span>	if !mutationRequired(ignoredNamespaces, &amp;pod.ObjectMeta) {
</span></span><span style=display:flex><span>		glog.Infof(&#34;Skipping mutation for %s/%s due to policy check&#34;, pod.Namespace, pod.Name)
</span></span><span style=display:flex><span>		return &amp;v1beta1.AdmissionResponse {
</span></span><span style=display:flex><span>			Allowed: true, 
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	annotations := map[string]string{admissionWebhookAnnotationStatusKey: &#34;injected&#34;}
</span></span><span style=display:flex><span>	patchBytes, err := createPatch(&amp;pod, whsvr.sidecarConfig, annotations)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	return &amp;v1beta1.AdmissionResponse {
</span></span><span style=display:flex><span>		Allowed: true,
</span></span><span style=display:flex><span>		Patch:   patchBytes,
</span></span><span style=display:flex><span>		PatchType: func() *v1beta1.PatchType {
</span></span><span style=display:flex><span>			pt := v1beta1.PatchTypeJSONPatch
</span></span><span style=display:flex><span>			return &amp;pt
</span></span><span style=display:flex><span>		}(),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From the code above, the <code>mutate</code> function calls <a href=https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go#L98-L130>mutationRequired</a> to detemine whether mutation is required or not. For those requiring mutation, the <code>mutate</code> function gets the mutation &lsquo;patch&rsquo; from another function <a href=https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go#L196-L205>createPatch</a>. Pay close attention to the little trick in function <code>mutationRequired</code>, we skip the pods without annotation <code>sidecar-injector-webhook.morven.me/inject: true</code>. That will be mentioned latter when we deployment applications. For complete code, please refer to <a href=https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go>https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go</a>.</p><h3 id=create-dockerfile-and-build-the-container>Create Dockerfile and Build the Container</h3><p>Create the <code>build</code> script:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>dep ensure
</span></span><span style=display:flex><span>CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o kube-mutating-webhook-tutorial .
</span></span><span style=display:flex><span>docker build --no-cache -t morvencao/sidecar-injector:v1 .
</span></span><span style=display:flex><span>rm -rf kube-mutating-webhook-tutorial
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker push morvencao/sidecar-injector:v1
</span></span></code></pre></div><p>And create <code>Dockerfile</code> as dependency of build script:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>FROM alpine:latest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ADD kube-mutating-webhook-tutorial /kube-mutating-webhook-tutorial
</span></span><span style=display:flex><span>ENTRYPOINT [&#34;./kube-mutating-webhook-tutorial&#34;]
</span></span></code></pre></div><p>Before actually building the container, you need a <a href=https://hub.docker.com/>Docker</a> account and change the image name&tag(in <code>Dockerfile</code> and <code>deployment.yaml</code>) to yours, then execute:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# ./build
</span></span><span style=display:flex><span>Sending build context to Docker daemon  44.89MB
</span></span><span style=display:flex><span>Step 1/3 : FROM alpine:latest
</span></span><span style=display:flex><span> ---&gt; 3fd9065eaf02
</span></span><span style=display:flex><span>Step 2/3 : ADD kube-mutating-webhook-tutorial /kube-mutating-webhook-tutorial
</span></span><span style=display:flex><span> ---&gt; 432de60c2b3f
</span></span><span style=display:flex><span>Step 3/3 : ENTRYPOINT [&#34;./kube-mutating-webhook-tutorial&#34;]
</span></span><span style=display:flex><span> ---&gt; Running in da6e956d1755
</span></span><span style=display:flex><span>Removing intermediate container da6e956d1755
</span></span><span style=display:flex><span> ---&gt; 619faa936145
</span></span><span style=display:flex><span>Successfully built 619faa936145
</span></span><span style=display:flex><span>Successfully tagged morvencao/sidecar-injector:v1
</span></span><span style=display:flex><span>The push refers to repository [docker.io/morvencao/sidecar-injector]
</span></span><span style=display:flex><span>efd05fe119bb: Pushed
</span></span><span style=display:flex><span>cd7100a72410: Layer already exists
</span></span><span style=display:flex><span>v1: digest: sha256:7a4889928ec5a8bcfb91b610dab812e5228d8dfbd2b540cd7a341c11f24729bf size: 739
</span></span></code></pre></div><h3 id=create-sidecar-injection-configuration>Create Sidecar Injection Configuration</h3><p>Now let’s create a Kubernetes <code>ConfigMap</code>, which includes <code>container</code> and <code>volume</code> information that will be injected into the target pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: ConfigMap
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: sidecar-injector-webhook-configmap
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  sidecarconfig.yaml: |
</span></span><span style=display:flex><span>    containers:
</span></span><span style=display:flex><span>      - name: sidecar-nginx
</span></span><span style=display:flex><span>        image: nginx:1.12.2
</span></span><span style=display:flex><span>        imagePullPolicy: IfNotPresent
</span></span><span style=display:flex><span>        ports:
</span></span><span style=display:flex><span>          - containerPort: 80
</span></span><span style=display:flex><span>        volumeMounts:
</span></span><span style=display:flex><span>          - name: nginx-conf
</span></span><span style=display:flex><span>            mountPath: /etc/nginx
</span></span><span style=display:flex><span>    volumes:
</span></span><span style=display:flex><span>      - name: nginx-conf
</span></span><span style=display:flex><span>        configMap:
</span></span><span style=display:flex><span>          name: nginx-configmap
</span></span></code></pre></div><p>From the above manifest, another ConfigMap including nginx conf is required. Here we put it in <a href=https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/deployment/nginxconfigmap.yaml>nginxconfigmap.yaml</a>.</p><p>Then deploy the two ConfigMaps to cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/nginxconfigmap.yaml
</span></span><span style=display:flex><span>configmap &#34;nginx-configmap&#34; created
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/configmap.yaml
</span></span><span style=display:flex><span>configmap &#34;sidecar-injector-webhook-configmap&#34; created
</span></span></code></pre></div><h3 id=create-secret-including-signed-keycert-pair>Create Secret Including Signed key/cert Pair</h3><p>Supporting <code>TLS</code> for external webhook server is also required because admission is a high security operation. As part of the process, we need to create a TLS certificate signed by the Kubernetes CA to secure the communication between the webhook server and <code>apiserver</code>. For the complete steps for creating and approving the process for <code>CSR</code>, please refer to <a href=https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/>https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/</a>.</p><p>For simplicity purposes, we referred to the <a href=https://github.com/istio/istio/blob/master/install/kubernetes/webhook-create-signed-cert.sh>script</a> from <code>Istio</code> and created a similar script called <code>webhook-create-signed-cert.sh</code> to automatically create the <code>cert/key</code> pair and include it in a Kubernetes secret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>[[</span> <span style=color:#000>$#</span> -gt <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#ce5c00;font-weight:700>]]</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>do</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>case</span> <span style=color:#4e9a06>${</span><span style=color:#000>1</span><span style=color:#4e9a06>}</span> in
</span></span><span style=display:flex><span>        --service<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>            <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;</span><span style=color:#000>$2</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#204a87>shift</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>;;</span>
</span></span><span style=display:flex><span>        --secret<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>            <span style=color:#000>secret</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;</span><span style=color:#000>$2</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#204a87>shift</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>;;</span>
</span></span><span style=display:flex><span>        --namespace<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>            <span style=color:#000>namespace</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;</span><span style=color:#000>$2</span><span style=color:#4e9a06>&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#204a87>shift</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>;;</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>esac</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87>shift</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>[</span> -z <span style=color:#4e9a06>${</span><span style=color:#000>service</span><span style=color:#4e9a06>}</span> <span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000>service</span><span style=color:#ce5c00;font-weight:700>=</span>sidecar-injector-webhook-svc
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>[</span> -z <span style=color:#4e9a06>${</span><span style=color:#000>secret</span><span style=color:#4e9a06>}</span> <span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000>secret</span><span style=color:#ce5c00;font-weight:700>=</span>sidecar-injector-webhook-certs
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>[</span> -z <span style=color:#4e9a06>${</span><span style=color:#000>namespace</span><span style=color:#4e9a06>}</span> <span style=color:#ce5c00;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000>namespace</span><span style=color:#ce5c00;font-weight:700>=</span>default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>csrName</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>service</span><span style=color:#4e9a06>}</span>.<span style=color:#4e9a06>${</span><span style=color:#000>namespace</span><span style=color:#4e9a06>}</span>
</span></span><span style=display:flex><span><span style=color:#000>tmpdir</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>mktemp -d<span style=color:#204a87;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;creating certs in tmpdir </span><span style=color:#4e9a06>${</span><span style=color:#000>tmpdir</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06> &#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF &gt;&gt; ${tmpdir}/csr.conf
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>[req]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>req_extensions = v3_req
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>distinguished_name = req_distinguished_name
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>[req_distinguished_name]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>[ v3_req ]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>basicConstraints = CA:FALSE
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>keyUsage = nonRepudiation, digitalSignature, keyEncipherment
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>extendedKeyUsage = serverAuth
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>subjectAltName = @alt_names
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>[alt_names]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>DNS.1 = ${service}
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>DNS.2 = ${service}.${namespace}
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>DNS.3 = ${service}.${namespace}.svc
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>openssl genrsa -out <span style=color:#4e9a06>${</span><span style=color:#000>tmpdir</span><span style=color:#4e9a06>}</span>/server-key.pem <span style=color:#0000cf;font-weight:700>2048</span>
</span></span><span style=display:flex><span>openssl req -new -key <span style=color:#4e9a06>${</span><span style=color:#000>tmpdir</span><span style=color:#4e9a06>}</span>/server-key.pem -subj <span style=color:#4e9a06>&#34;/CN=</span><span style=color:#4e9a06>${</span><span style=color:#000>service</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>.</span><span style=color:#4e9a06>${</span><span style=color:#000>namespace</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>.svc&#34;</span> -out <span style=color:#4e9a06>${</span><span style=color:#000>tmpdir</span><span style=color:#4e9a06>}</span>/server.csr -config <span style=color:#4e9a06>${</span><span style=color:#000>tmpdir</span><span style=color:#4e9a06>}</span>/csr.conf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># clean-up any previously created CSR for our service. Ignore errors if not present.</span>
</span></span><span style=display:flex><span>kubectl delete csr <span style=color:#4e9a06>${</span><span style=color:#000>csrName</span><span style=color:#4e9a06>}</span> 2&gt;/dev/null <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#204a87>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># create  server cert/key CSR and  send to k8s API</span>
</span></span><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl create -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: certificates.k8s.io/v1beta1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: CertificateSigningRequest
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: ${csrName}
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  groups:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - system:authenticated
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  request: $(cat ${tmpdir}/server.csr | base64 | tr -d &#39;\n&#39;)
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  usages:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - digital signature
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - key encipherment
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - server auth
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># verify CSR has been created</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>while</span> true<span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>do</span>
</span></span><span style=display:flex><span>    kubectl get csr <span style=color:#4e9a06>${</span><span style=color:#000>csrName</span><span style=color:#4e9a06>}</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>[</span> <span style=color:#4e9a06>&#34;</span><span style=color:#000>$?</span><span style=color:#4e9a06>&#34;</span> -eq <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#ce5c00;font-weight:700>]</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>then</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87>break</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>fi</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># approve and fetch the signed certificate</span>
</span></span><span style=display:flex><span>kubectl certificate approve <span style=color:#4e9a06>${</span><span style=color:#000>csrName</span><span style=color:#4e9a06>}</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># verify certificate has been signed</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>for</span> x in <span style=color:#204a87;font-weight:700>$(</span>seq 10<span style=color:#204a87;font-weight:700>)</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>do</span>
</span></span><span style=display:flex><span>    <span style=color:#000>serverCert</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get csr <span style=color:#4e9a06>${</span><span style=color:#000>csrName</span><span style=color:#4e9a06>}</span> -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.status.certificate}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>[[</span> <span style=color:#4e9a06>${</span><span style=color:#000>serverCert</span><span style=color:#4e9a06>}</span> !<span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#39;&#39;</span> <span style=color:#ce5c00;font-weight:700>]]</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>then</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87>break</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>fi</span>
</span></span><span style=display:flex><span>    sleep <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>done</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>[[</span> <span style=color:#4e9a06>${</span><span style=color:#000>serverCert</span><span style=color:#4e9a06>}</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#4e9a06>&#39;&#39;</span> <span style=color:#ce5c00;font-weight:700>]]</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>then</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;ERROR: After approving csr </span><span style=color:#4e9a06>${</span><span style=color:#000>csrName</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>, the signed certificate did not appear on the resource. Giving up after 10 attempts.&#34;</span> &gt;<span style=color:#000;font-weight:700>&amp;</span><span style=color:#0000cf;font-weight:700>2</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87>exit</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>fi</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>${</span><span style=color:#000>serverCert</span><span style=color:#4e9a06>}</span> <span style=color:#000;font-weight:700>|</span> openssl base64 -d -A -out <span style=color:#4e9a06>${</span><span style=color:#000>tmpdir</span><span style=color:#4e9a06>}</span>/server-cert.pem
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># create the secret with CA cert and server cert/key</span>
</span></span><span style=display:flex><span>kubectl create secret generic <span style=color:#4e9a06>${</span><span style=color:#000>secret</span><span style=color:#4e9a06>}</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>        --from-file<span style=color:#ce5c00;font-weight:700>=</span>key.pem<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>tmpdir</span><span style=color:#4e9a06>}</span>/server-key.pem <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>        --from-file<span style=color:#ce5c00;font-weight:700>=</span>cert.pem<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>tmpdir</span><span style=color:#4e9a06>}</span>/server-cert.pem <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>        --dry-run -o yaml <span style=color:#000;font-weight:700>|</span>
</span></span><span style=display:flex><span>    kubectl -n <span style=color:#4e9a06>${</span><span style=color:#000>namespace</span><span style=color:#4e9a06>}</span> apply -f -
</span></span></code></pre></div><p>We then execute it and a Kubernetes secret including <code>cert/key</code> pair is created:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# ./deployment/webhook-create-signed-cert.sh
</span></span><span style=display:flex><span>creating certs in tmpdir /tmp/tmp.wXZywp0wAF
</span></span><span style=display:flex><span>Generating RSA private key, 2048 bit long modulus
</span></span><span style=display:flex><span>...........................................+++
</span></span><span style=display:flex><span>..........+++
</span></span><span style=display:flex><span>e is 65537 (0x10001)
</span></span><span style=display:flex><span>certificatesigningrequest &#34;sidecar-injector-webhook-svc.default&#34; created
</span></span><span style=display:flex><span>NAME                                   AGE       REQUESTOR                                           CONDITION
</span></span><span style=display:flex><span>sidecar-injector-webhook-svc.default   0s        https://mycluster.icp:9443/oidc/endpoint/OP#admin   Pending
</span></span><span style=display:flex><span>certificatesigningrequest &#34;sidecar-injector-webhook-svc.default&#34; approved
</span></span><span style=display:flex><span>secret &#34;sidecar-injector-webhook-certs&#34; created
</span></span></code></pre></div><h3 id=create-the-sidecar-injector-deployment-and-service>Create the Sidecar Injector Deployment and Service</h3><p>The <code>deployment</code> brings up 1 pod in which the <code>sidecar-injector</code> container is running. The container starts with special arguments:</p><ul><li><code>sidecarCfgFile</code> pointing to the sidecar injector configuration file mounted from <code>sidecar-injector-webhook-configmap</code> ConfigMap created above.</li><li><code>tlsCertFile</code> and <code>tlsKeyFile</code> are <code>cert/key</code> pair mounted from <code>sidecar-injector-webhook-certs</code> Secret create by script above.</li><li><code>alsologtostderr</code> <code>v=4</code> and <code>2>&1</code> are logging arguments.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>apiVersion: extensions/v1beta1
</span></span><span style=display:flex><span>kind: Deployment
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: sidecar-injector-webhook-deployment
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    app: sidecar-injector
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  replicas: 1
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>        app: sidecar-injector
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>        - name: sidecar-injector
</span></span><span style=display:flex><span>          image: morvencao/sidecar-injector:v1
</span></span><span style=display:flex><span>          imagePullPolicy: IfNotPresent
</span></span><span style=display:flex><span>          args:
</span></span><span style=display:flex><span>            - -sidecarCfgFile=/etc/webhook/config/sidecarconfig.yaml
</span></span><span style=display:flex><span>            - -tlsCertFile=/etc/webhook/certs/cert.pem
</span></span><span style=display:flex><span>            - -tlsKeyFile=/etc/webhook/certs/key.pem
</span></span><span style=display:flex><span>            - -alsologtostderr
</span></span><span style=display:flex><span>            - -v=4
</span></span><span style=display:flex><span>            - 2&gt;&amp;1
</span></span><span style=display:flex><span>          volumeMounts:
</span></span><span style=display:flex><span>            - name: webhook-certs
</span></span><span style=display:flex><span>              mountPath: /etc/webhook/certs
</span></span><span style=display:flex><span>              readOnly: true
</span></span><span style=display:flex><span>            - name: webhook-config
</span></span><span style=display:flex><span>              mountPath: /etc/webhook/config
</span></span><span style=display:flex><span>      volumes:
</span></span><span style=display:flex><span>        - name: webhook-certs
</span></span><span style=display:flex><span>          secret:
</span></span><span style=display:flex><span>            secretName: sidecar-injector-webhook-certs
</span></span><span style=display:flex><span>        - name: webhook-config
</span></span><span style=display:flex><span>          configMap:
</span></span><span style=display:flex><span>            name: sidecar-injector-webhook-configmap
</span></span></code></pre></div><p>The <code>service</code> exposes the pod defined above labeled by <code>app=sidecar-injector</code> to make it accessible in cluster. This service will be referred by the <code>MutatingWebhookConfiguration</code> in <code>clientConfig</code> section and by default spec.ports.port should be <strong>443</strong>(default https port).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Service
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: sidecar-injector-webhook-svc
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    app: sidecar-injector
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ports:
</span></span><span style=display:flex><span>  - port: 443
</span></span><span style=display:flex><span>    targetPort: 443
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    app: sidecar-injector
</span></span></code></pre></div><p>Next we deploy the above <code>Deployment</code> and <code>Service</code> to cluster and verify the sidecar injector webhook server is running:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/deployment.yaml
</span></span><span style=display:flex><span>deployment &#34;sidecar-injector-webhook-deployment&#34; created
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/service.yaml
</span></span><span style=display:flex><span>service &#34;sidecar-injector-webhook-svc&#34; created
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get deployment
</span></span><span style=display:flex><span>NAME                                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-deployment   1         1         1            1           2m
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pod
</span></span><span style=display:flex><span>NAME                                                  READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running   0          3m
</span></span></code></pre></div><h3 id=configure-webhook-admission-controller-on-the-fly>Configure webhook admission controller on the fly</h3><p><code>MutatingWebhookConfiguration</code> specifies which webhook admission servers are enabled and which resources are subject to the admission server. It is recommended that you firstly deploy the webhook admission server and make sure it is working properly before creating the <code>MutatingWebhookConfiguration</code>. Otherwise, requests will be unconditionally accepted or rejected based on <code>failurePolicy</code>.</p><p>For now, we create the <code>MutatingWebhookConfiguration</code> manifest with the following content:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>apiVersion: admissionregistration.k8s.io/v1beta1
</span></span><span style=display:flex><span>kind: MutatingWebhookConfiguration
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: sidecar-injector-webhook-cfg
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    app: sidecar-injector
</span></span><span style=display:flex><span>webhooks:
</span></span><span style=display:flex><span>  - name: sidecar-injector.morven.me
</span></span><span style=display:flex><span>    clientConfig:
</span></span><span style=display:flex><span>      service:
</span></span><span style=display:flex><span>        name: sidecar-injector-webhook-svc
</span></span><span style=display:flex><span>        namespace: default
</span></span><span style=display:flex><span>        path: &#34;/mutate&#34;
</span></span><span style=display:flex><span>      caBundle: ${CA_BUNDLE}
</span></span><span style=display:flex><span>    rules:
</span></span><span style=display:flex><span>      - operations: [ &#34;CREATE&#34; ]
</span></span><span style=display:flex><span>        apiGroups: [&#34;&#34;]
</span></span><span style=display:flex><span>        apiVersions: [&#34;v1&#34;]
</span></span><span style=display:flex><span>        resources: [&#34;pods&#34;]
</span></span><span style=display:flex><span>    namespaceSelector:
</span></span><span style=display:flex><span>      matchLabels:
</span></span><span style=display:flex><span>        sidecar-injector: enabled
</span></span></code></pre></div><p>Line 8: <code>name</code> - name for the webhook, should be fully qualified. Mutiple mutating webhooks are sorted by providing order.
Line 9: <code>clientConfig</code> - describes how to connect to the webhook admission server and the TLS certificate. In our case, we specify the sidecar injector service. Line 15: <code>rules</code> - specifies what resources and what actions the webhook server handles. In our case, only intercepts request for creating of pods.
Line 20: <code>namespaceSelector</code> - <code>namespaceSelector</code> decides whether to send admission request the webhook server on an object based on whether the namespace for that object matches the selector.</p><p>Before deploying the <code>MutatingWebhookConfiguration</code>, we need to replace the <code>${CA_BUNDLE}</code> with apiserver&rsquo;s default caBundle. Let&rsquo;s write the script <code>webhook-patch-ca-bundle.sh</code> to automate this process:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -o errexit
</span></span><span style=display:flex><span><span style=color:#204a87>set</span> -o nounset
</span></span><span style=display:flex><span><span style=color:#204a87>set</span> -o pipefail
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>ROOT</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span><span style=color:#204a87>cd</span> <span style=color:#204a87;font-weight:700>$(</span>dirname <span style=color:#000>$0</span><span style=color:#204a87;font-weight:700>)</span>/../../<span style=color:#000;font-weight:700>;</span> <span style=color:#204a87>pwd</span><span style=color:#204a87;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>CA_BUNDLE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get configmap -n kube-system extension-apiserver-authentication -o<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.data.client-ca-file}&#39;</span> <span style=color:#000;font-weight:700>|</span> base64 <span style=color:#000;font-weight:700>|</span> tr -d <span style=color:#4e9a06>&#39;\n&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#204a87>command</span> -v envsubst &gt;/dev/null 2&gt;<span style=color:#000;font-weight:700>&amp;</span>1<span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>then</span>
</span></span><span style=display:flex><span>    envsubst
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>else</span>
</span></span><span style=display:flex><span>    sed -e <span style=color:#4e9a06>&#34;s|\${CA_BUNDLE}|</span><span style=color:#4e9a06>${</span><span style=color:#000>CA_BUNDLE</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>|g&#34;</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>fi</span>
</span></span></code></pre></div><p>Then execute:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# cat ./deployment/mutatingwebhook.yaml |\
</span></span><span style=display:flex><span>&gt;   ./deployment/webhook-patch-ca-bundle.sh &gt;\
</span></span><span style=display:flex><span>&gt;   ./deployment/mutatingwebhook-ca-bundle.yaml
</span></span></code></pre></div><p>Finally we can deploy <code>MutatingWebhookConfiguration</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/mutatingwebhook-ca-bundle.yaml
</span></span><span style=display:flex><span>mutatingwebhookconfiguration &#34;sidecar-injector-webhook-cfg&#34; created
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get mutatingwebhookconfiguration
</span></span><span style=display:flex><span>NAME                           AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-cfg   11s
</span></span></code></pre></div><h3 id=verification-and-troubleshooting>Verification and Troubleshooting</h3><p>Now it’s time to verify sidecar injector works as expected and try to see how to troubleshoot if you encounter issues. Typically we create and deploy a sleep application in <code>default</code> namespace to see if the sidecar can be injected.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# cat &lt;&lt;EOF | kubectl create -f -
</span></span><span style=display:flex><span>&gt; apiVersion: extensions/v1beta1
</span></span><span style=display:flex><span>&gt; kind: Deployment
</span></span><span style=display:flex><span>&gt; metadata:
</span></span><span style=display:flex><span>&gt;   name: sleep
</span></span><span style=display:flex><span>&gt; spec:
</span></span><span style=display:flex><span>&gt;   replicas: 1
</span></span><span style=display:flex><span>&gt;   template:
</span></span><span style=display:flex><span>&gt;     metadata:
</span></span><span style=display:flex><span>&gt;       annotations:
</span></span><span style=display:flex><span>&gt;         sidecar-injector-webhook.morven.me/inject: &#34;true&#34;
</span></span><span style=display:flex><span>&gt;       labels:
</span></span><span style=display:flex><span>&gt;         app: sleep
</span></span><span style=display:flex><span>&gt;     spec:
</span></span><span style=display:flex><span>&gt;       containers:
</span></span><span style=display:flex><span>&gt;       - name: sleep
</span></span><span style=display:flex><span>&gt;         image: tutum/curl
</span></span><span style=display:flex><span>&gt;         command: [&#34;/bin/sleep&#34;,&#34;infinity&#34;]
</span></span><span style=display:flex><span>&gt;         imagePullPolicy: IfNotPresent
</span></span><span style=display:flex><span>&gt; EOF
</span></span><span style=display:flex><span>deployment &#34;sleep&#34; created
</span></span></code></pre></div><p>Pay close attention to the <code>spec.template.metadata.annotations</code> as there is a new annotation added:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>sidecar-injector-webhook.morven.me/inject: &#34;true&#34;
</span></span></code></pre></div><p>The sidecar injector has some logic to check the existence of the above annotation before injecting sidecar container and volume. You’re free to delete the logic or customize it before build the sidecar injector container.</p><p>Check the deployment and pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get deployment
</span></span><span style=display:flex><span>NAME                                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-deployment   1         1         1            1           18m
</span></span><span style=display:flex><span>sleep                                 1         1         1            1           58s
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pod
</span></span><span style=display:flex><span>NAME                                                  READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running   0          18m
</span></span><span style=display:flex><span>sleep-6d79d8dc54-r66vz                                1/1       Running   0          1m
</span></span></code></pre></div><p>It’s not there. What’s going on? Let’s check the sidecar injector logs:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl logs -f sidecar-injector-webhook-deployment-bbb689d69-fdbgj
</span></span><span style=display:flex><span>I0314 08:48:15.140858       1 webhook.go:88] New configuration: sha256sum 21669464280f76170b88241fd79ecbca3dcebaec5c152a4a9a3e921ff742157f
</span></span></code></pre></div><p>We can’t find any logs that indicate webhook server got admission request, seems that request hadn’t been sent to sidecar injector webhook server. So there is a possibility that the issue is caused by configuration in <code>MutatingWebhookConfiguration</code>. Do a double check of <code>MutatingWebhookConfiguration</code> and we find following content:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>namespaceSelector:
</span></span><span style=display:flex><span>      matchLabels:
</span></span><span style=display:flex><span>        sidecar-injector: enabled
</span></span></code></pre></div><h3 id=control-sidecar-injector-with-namespaceselector>Control sidecar injector with namespaceSelector</h3><p>We have configured ‘namespaceSelector’ in <code>MutatingWebhookConfiguration</code>, which means only resources in namespace matching the selector will be sent to webhook server. So we need label the <code>default</code> namespace with <code>sidecar-injector=enabled</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl label namespace default sidecar-injector=enabled
</span></span><span style=display:flex><span>namespace &#34;default&#34; labeled
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get namespace -L sidecar-injector
</span></span><span style=display:flex><span>NAME          STATUS    AGE       sidecar-injector
</span></span><span style=display:flex><span>default       Active    1d        enabled
</span></span><span style=display:flex><span>kube-public   Active    1d
</span></span><span style=display:flex><span>kube-system   Active    1d
</span></span></code></pre></div><p>We have now configured the <code>MutatingWebhookConfiguration</code> resulting in the sidecar injection occurring at pod creation time. Kill the running pod and verify a new pod is created with the injected sidecar.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl delete pod sleep-6d79d8dc54-r66vz
</span></span><span style=display:flex><span>pod &#34;sleep-6d79d8dc54-r66vz&#34; deleted
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pods
</span></span><span style=display:flex><span>NAME                                                  READY     STATUS              RESTARTS   AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running             0          29m
</span></span><span style=display:flex><span>sleep-6d79d8dc54-b8ztx                                0/2       ContainerCreating   0          3s
</span></span><span style=display:flex><span>sleep-6d79d8dc54-r66vz                                1/1       Terminating         0          11m
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pod sleep-6d79d8dc54-b8ztx -o yaml
</span></span><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Pod
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    kubernetes.io/psp: default
</span></span><span style=display:flex><span>    sidecar-injector-webhook.morven.me/inject: &#34;true&#34;
</span></span><span style=display:flex><span>    sidecar-injector-webhook.morven.me/status: injected
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    app: sleep
</span></span><span style=display:flex><span>    pod-template-hash: &#34;2835848710&#34;
</span></span><span style=display:flex><span>  name: sleep-6d79d8dc54-b8ztx
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  containers:
</span></span><span style=display:flex><span>  - command:
</span></span><span style=display:flex><span>    - /bin/sleep
</span></span><span style=display:flex><span>    - infinity
</span></span><span style=display:flex><span>    image: tutum/curl
</span></span><span style=display:flex><span>    imagePullPolicy: IfNotPresent
</span></span><span style=display:flex><span>    name: sleep
</span></span><span style=display:flex><span>    resources: {}
</span></span><span style=display:flex><span>    volumeMounts:
</span></span><span style=display:flex><span>    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
</span></span><span style=display:flex><span>      name: default-token-d7t2r
</span></span><span style=display:flex><span>      readOnly: true
</span></span><span style=display:flex><span>  - image: nginx:1.12.2
</span></span><span style=display:flex><span>    imagePullPolicy: IfNotPresent
</span></span><span style=display:flex><span>    name: sidecar-nginx
</span></span><span style=display:flex><span>    ports:
</span></span><span style=display:flex><span>    - containerPort: 80
</span></span><span style=display:flex><span>      protocol: TCP
</span></span><span style=display:flex><span>    resources: {}
</span></span><span style=display:flex><span>    terminationMessagePath: /dev/termination-log
</span></span><span style=display:flex><span>    terminationMessagePolicy: File
</span></span><span style=display:flex><span>    volumeMounts:
</span></span><span style=display:flex><span>    - mountPath: /etc/nginx
</span></span><span style=display:flex><span>      name: nginx-conf
</span></span><span style=display:flex><span>  volumes:
</span></span><span style=display:flex><span>  - name: default-token-d7t2r
</span></span><span style=display:flex><span>    secret:
</span></span><span style=display:flex><span>      defaultMode: 420
</span></span><span style=display:flex><span>      secretName: default-token-d7t2r
</span></span><span style=display:flex><span>  - configMap:
</span></span><span style=display:flex><span>      defaultMode: 420
</span></span><span style=display:flex><span>      name: nginx-configmap
</span></span><span style=display:flex><span>    name: nginx-conf
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>We can see that sidecar container and volume have been injected into sleep application successfully. Until now, we have working sidecar injector with <code>MutatingAdmissionWebhook</code>. With <code>namespaceSelector</code> we can easily control whether the pods in specified namespace will be injected or not.</p><p>But there is a problem for this, with the above configurations, all of the pods in <code>default</code> namespace will be injected with a sidecar, this may be not expected for some cases.</p><h3 id=control-sidecar-injector-with-annotation>Control sidecar injector with annotation</h3><p>Thanks to flexibility of <code>MutatingAdmissionWebhook</code>, we can easily customized the mutating logic to filter resources with specified annotations. Remember the annotation <code>sidecar-injector-webhook.morven.me/inject: "true"</code> mentioned above. It can be used as an extra control on sidecar injector. I have written <a href=https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go#L98-L130>some code</a> in webhook server to skip injecting for pod without the annotation.</p><p>Let’s give it a try. In this case, we create another sleep application without <code>sidecar-injector-webhook.morven.me/inject: "true"</code> annotation in <code>podTemplateSpec</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl delete deployment sleep
</span></span><span style=display:flex><span>deployment &#34;sleep&#34; deleted
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# cat &lt;&lt;EOF | kubectl create -f -
</span></span><span style=display:flex><span>apiVersion: extensions/v1beta1
</span></span><span style=display:flex><span>&gt; kind: Deployment
</span></span><span style=display:flex><span>&gt; metadata:
</span></span><span style=display:flex><span>&gt;   name: sleep
</span></span><span style=display:flex><span>&gt; spec:
</span></span><span style=display:flex><span>&gt;   replicas: 1
</span></span><span style=display:flex><span>&gt;   template:
</span></span><span style=display:flex><span>&gt;     metadata:
</span></span><span style=display:flex><span>&gt;       labels:
</span></span><span style=display:flex><span>&gt;         app: sleep
</span></span><span style=display:flex><span>&gt;     spec:
</span></span><span style=display:flex><span>&gt;       containers:
</span></span><span style=display:flex><span>&gt;       - name: sleep
</span></span><span style=display:flex><span>&gt;         image: tutum/curl
</span></span><span style=display:flex><span>&gt;         command: [&#34;/bin/sleep&#34;,&#34;infinity&#34;]
</span></span><span style=display:flex><span>&gt;         imagePullPolicy: IfNotPresent
</span></span><span style=display:flex><span>&gt; EOF
</span></span><span style=display:flex><span>deployment &#34;sleep&#34; created
</span></span></code></pre></div><p>And then verify the sidecar injector skipped the pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get deployment
</span></span><span style=display:flex><span>NAME                                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-deployment   1         1         1            1           45m
</span></span><span style=display:flex><span>sleep                                 1         1         1            1           17s
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pod
</span></span><span style=display:flex><span>NAME                                                  READY     STATUS        RESTARTS   AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running       0          45m
</span></span><span style=display:flex><span>sleep-776b7bcdcd-4bz58                                1/1       Running       0          21s
</span></span></code></pre></div><p>The output shows that the sleep application contains only one container, no extra container and volume injected. Then we patch the sleep deployment to add the additional annotation and verify it will be injected after recreated:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl patch deployment sleep -p &#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;sidecar-injector-webhook.morven.me/inject&#34;: &#34;true&#34;}}}}}&#39;
</span></span><span style=display:flex><span>deployment &#34;sleep&#34; patched
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl delete pod sleep-776b7bcdcd-4bz58
</span></span><span style=display:flex><span>pod &#34;sleep-776b7bcdcd-4bz58&#34; deleted
</span></span><span style=display:flex><span>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pods
</span></span><span style=display:flex><span>NAME                                                  READY     STATUS              RESTARTS   AGE
</span></span><span style=display:flex><span>sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running             0          49m
</span></span><span style=display:flex><span>sleep-3e42ff9e6c-6f87b                                0/2       ContainerCreating   0          18s
</span></span><span style=display:flex><span>sleep-776b7bcdcd-4bz58                                1/1       Terminating         0          3m
</span></span></code></pre></div><p>As expected, the pod has been injected with extra sidecar container. Now, we got working sidecar injector with <code>mutatingAdmissionWebhook</code> and its coarse-grained control by <code>namespaceSelector</code> and fine-grained control by additional annotation.</p><h2 id=conclusion>Conclusion</h2><p><code>MutatingAdmissionWebhook</code> is one of easiest ways of extending Kubernetes with new policy controls and resources mutation and a host of other options.</p><p>This feature will enable more workloads and support more ecosystem components, including <a href=https://github.com/istio/istio>Istio</a> service mesh platform. Starting with Istio 0.5.0, Istio has been refactored to support their auto injection code with <code>MutatingAdmissionWebhook</code> replacing <code>initializers</code>.</p><h2 id=reference>Reference</h2><ul><li><a href=http://blog.kubernetes.io/2018/01/extensible-admission-is-beta.html>http://blog.kubernetes.io/2018/01/extensible-admission-is-beta.html</a></li><li><a href=https://docs.google.com/document/d/1c4kdkY3ha9rm0OIRbGleCeaHknZ-NR1nNtDp-i8eH8E/view>https://docs.google.com/document/d/1c4kdkY3ha9rm0OIRbGleCeaHknZ-NR1nNtDp-i8eH8E/view</a></li><li><a href=https://v1-8.docs.kubernetes.io/docs/admin/extensible-admission-controllers/>https://v1-8.docs.kubernetes.io/docs/admin/extensible-admission-controllers/</a></li><li><a href=https://github.com/kubernetes/kubernetes/tree/release-1.9/test/images/webhook>https://github.com/kubernetes/kubernetes/tree/release-1.9/test/images/webhook</a></li></ul></div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=https://morven.life/en/categories/note/>note</a></div><div class=post-category><a href=https://morven.life/en/categories/tech/>tech</a></div></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=https://morven.life/about/ target=_blank>About Me</a></div></div></div></div></article><script src=https://morven.life/js/lazyload.min.js></script>
<script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script><script></script></body></html>