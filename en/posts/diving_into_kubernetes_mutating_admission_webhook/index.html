<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hugo 0.54.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Morven Cao"><meta property="og:url" content="https://morven.life/en/posts/diving_into_kubernetes_mutating_admission_webhook/"><link rel="canonical" href="https://morven.life/en/posts/diving_into_kubernetes_mutating_admission_webhook/"><link rel="shortcut icon" href="https://morven.life/favicon.ico" type="image/x-png"><script type="application/ld+json">{
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https://morven.life/"
      },
      "articleSection" : "posts",
      "name" : "Diving into Kubernetes MutatingAdmissionWebhook",
      "headline" : "Diving into Kubernetes MutatingAdmissionWebhook",
      "description" : "Admission controllers are powerful tools for intercepting requests to the Kubernetes API server prior to persistence of the object. However, they are not very flexible due to the requirement that they are compiled as a binary in the kube-apiserver that is configured by the cluster administrator. Starting in Kubernetes 1.7, Initializers and External Admission Webhooks are introduced to address this limitation. In Kubernetes 1.9, Initializers stays in alpha phase while External Admission Webhooks are promoted to beta and split into MutatingAdmissionWebhook and ValidatingAdmissionWebhook.",
      "inLanguage" : "en-US",
      "author" : "Morven Cao",
      "creator" : "Morven Cao",
      "publisher": "Morven Cao",
      "accountablePerson" : "Morven Cao",
      "copyrightHolder" : "Morven Cao",
      "copyrightYear" : "2018",
      "datePublished": "2018-04-10 00:00:00 &#43;0000 UTC",
      "dateModified" : "2018-04-10 00:00:00 &#43;0000 UTC",
      "url" : "https://morven.life/en/posts/diving_into_kubernetes_mutating_admission_webhook/",
      "keywords" : [  ]
  }</script><title>Diving into Kubernetes MutatingAdmissionWebhook - Morven&#39;s Blog</title><meta property="og:title" content="Diving into Kubernetes MutatingAdmissionWebhook - Morven&#39;s Blog"><meta property="og:type" content="article"><meta name="description" content="Admission controllers are powerful tools for intercepting requests to the Kubernetes API server prior to persistence of the object. However, they are not very flexible due to the requirement that they are compiled as a binary in the kube-apiserver that is configured by the cluster administrator. Starting in Kubernetes 1.7, Initializers and External Admission Webhooks are introduced to address this limitation. In Kubernetes 1.9, Initializers stays in alpha phase while External Admission Webhooks are promoted to beta and split into MutatingAdmissionWebhook and ValidatingAdmissionWebhook."><link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css"><link rel="stylesheet" href="https://morven.life/css/index.css"><link href="https://morven.life/index.xml" rel="alternate" type="application/rss+xml" title="Morven&#39;s Blog"><script>(function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});</script></head><body><article class="post English" id="article"><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href="https://morven.life/en/"><div class="head-line"></div></a><header class="post-header"><h1 class="post-title">Diving into Kubernetes MutatingAdmissionWebhook</h1><div class="row"><div class="col-xs-6"><time class="post-date" datetime="2018-04-10 00:00:00 UTC">10 Apr 2018</time></div><div class="col-xs-6"><div class="post-author"><a target="_blank" href="https://morven.life/">@Morven Cao</a></div></div></div></header><div class="post-content markdown-body"><p><a href="https://kubernetes.io/docs/admin/admission-controllers/">Admission controllers</a> are powerful tools for intercepting requests to the Kubernetes API server prior to persistence of the object. However, they are not very flexible due to the requirement that they are compiled as a binary in the <code>kube-apiserver</code> that is configured by the cluster administrator. Starting in Kubernetes 1.7, <a href="https://v1-8.docs.kubernetes.io/docs/admin/extensible-admission-controllers/#initializers">Initializers</a> and <a href="https://v1-8.docs.kubernetes.io/docs/admin/extensible-admission-controllers/#external-admission-webhooks">External Admission Webhooks</a> are introduced to address this limitation. In Kubernetes 1.9, <code>Initializers</code> stays in alpha phase while <code>External Admission Webhooks</code> are promoted to beta and split into <a href="https://kubernetes.io/docs/admin/admission-controllers/#mutatingadmissionwebhook-beta-in-19">MutatingAdmissionWebhook</a> and <a href="https://kubernetes.io/docs/admin/admission-controllers/#validatingadmissionwebhook-alpha-in-18-beta-in-19">ValidatingAdmissionWebhook</a>.</p><p><code>MutatingAdmissionWebhook</code> together with <code>ValidatingAdmissionWebhook</code> are a special kind of <code>admission controllers</code> which process mutations and validations. This validation is done by matching the rules that are defined in the <a href="https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#mutatingwebhookconfiguration-v1beta1-admissionregistration">MutatingWebhookConfiguration</a>(explained below).</p><p>In this article, I will dive into the details of a <code>MutatingAdmissionWebhook</code> and write a working webhook admission server step-by-step.</p><h2 id="benefit-of-webhooks">Benefit of Webhooks</h2><p>Kubernetes cluster administrators can use <code>webhooks</code> to create additional mutating and validating admission plugins to the admission chain of <code>apiserver</code> without recompiling them. This provides developers with the freedom and flexibility to customize admission logic on multiple actions such CREATE, UPDATE, and DELETE on any resource. The number of applications that can be used are vast. Some common use cases include:</p><ul><li>Mutating resources before creating them. <a href="https://github.com/istio">Istio</a>, a representative example, injects an <a href="https://github.com/envoyproxy/envoy">Envoy</a> sidecar container to target pods to implement traffic management and policy enforcement.</li><li>Automated provisioning of <code>StorageClass</code>. Observes creation of <code>PersistentVolumeClaim</code> objects and automatically adds storage class to them based on predefined policy. Users that do not need to care about <code>StorageClass</code> creating.</li><li>Validating complex custom resource. Make sure custom resource can only be created after its definition and all dependencies created and available.</li><li>Restricting namespace. On multi-tenant systems, avoid resources created in reserved namespaces.</li></ul><p>Besides the user-cases listed above, many more applications can be created based on the power of <code>webhooks</code>.</p><h2 id="webhooks-vs-initializers">Webhooks vs Initializers</h2><p>Based on feedback from the community and use cases in alpha phase for both <code>External Admission Webhooks</code> and <code>Initializers</code>, the Kubernetes community decided to promote webhooks to beta and split it into two types of webhooks (<code>MutatingAdmissionWebhook</code> and <code>ValidatingAdmissionWebhook</code>). These updates make webhooks consistent with other admission controllers and enforce <code>mutate-before-validate</code>. <code>Initializers</code> can also implement dynamic admission control by modifying Kubernetes resources before they are actually created. If you&rsquo;re unfamiliar with <code>Initializers</code>, please refer to the article: <a href="https://medium.com/ibm-cloud/kubernetes-initializers-deep-dive-and-tutorial-3bc416e4e13e">https://medium.com/ibm-cloud/kubernetes-initializers-deep-dive-and-tutorial-3bc416e4e13e</a>.</p><p>So whatâ€™s the difference between <code>Webhooks</code> and <code>Initializers</code>?</p><ul><li><code>Webhooks</code> can be applied on more actions, including &lsquo;mutate&rsquo; or &lsquo;admit&rsquo; on resoures &lsquo;CREATE&rsquo; &lsquo;UPDATE&rsquo; and &lsquo;DELETE&rsquo;, whereas <code>Initializers</code> can&rsquo;t &lsquo;admit&rsquo; resources for &lsquo;DELETE&rsquo; requests.</li><li><code>Webhooks</code> are not allowed to query resources before created, while <code>Initializers</code> are capable of watching the uninitialized resources by the query parameter <code>?includeUninitialized=true</code>, which makes the resource creation progress transparent.</li><li>Since <code>Initializers</code> persist the &lsquo;pre-create&rsquo; states to <code>etcd</code>, higher latency and increased <code>etcd</code> burden will be introduced accordingly, especially when <code>apiserver</code> upgrades or fails. <code>Webhooks</code>, however, consume less memory and computing resources.</li><li><code>Webhooks</code> provide more robustness on failures than <code>Initializers</code>. Failure policies can be configured in <code>Webhooks</code> configuraton to avoid hanging onto resources that are created. Buggy <code>Initializers</code>, on the other hand, may block all matched resources attempted to be created.</li></ul><p>Besides the differences listed above, <code>Initializer</code> has some significant issues currently as open issues with long expected development time including quota replenishment bug. Promotion of <code>Webhooks</code> to beta may be a signal that more support for it in the future, but that depends. If stable behavior is preferred, I suggest you choose <code>Webhooks</code>.</p><h2 id="how-mutatingadmissionwebhook-works">How MutatingAdmissionWebhook works</h2><p><code>MutatingAdmissionWebhook</code> intercepts requests matching the rules defined in <code>MutatingWebhookConfiguration</code> before presisting into <code>etcd</code>. <code>MutatingAdmissionWebhook</code> executes the mutation by sending admission requests to webhook server. Webhook server is just plain http server that adhere to the <a href="https://github.com/kubernetes/kubernetes/blob/v1.9.0/pkg/apis/admission/types.go">API</a>.</p><p>The following diagram describes how <code>MutatingAdmissionWebhook</code> works in details:</p><p><img src="https://i.loli.net/2019/03/17/5c8dede75dfde.jpg" alt=""></p><p>The <code>MutatingAdmissionWebhook</code> needs three objects to function:</p><ol><li><strong>MutatingWebhookConfiguration</strong></li></ol><p><code>MutatingAdmissionWebhook</code> needs to be registered in the <code>apiserver</code> by providing <code>MutatingWebhookConfiguration</code>. During the registration process, <code>MutatingAdmissionWebhook</code> states:</p><ul><li>How to connect to the webhook admission server</li><li>How to verify the webhook admission server</li><li>The URL path of the webhook admission server</li><li>Rules defining which resource and what action it handles</li><li>How unrecognized errors from the webhook admission server are handled</li></ul><ol><li><strong>MutatingAdmissionWebhook itself</strong></li></ol><p><code>MutatingAdmissionWebhook</code> is a plugin-style admission controller that can be configured into the <code>apiserver</code>. The <code>MutatingAdmissionWebhook</code> plugin get the list of interested admission webhooks from <code>MutatingWebhookConfiguration</code>. Then the <code>MutatingAdmissionWebhook</code> observes the requests to <code>apiserver</code> and intercepts requests matching the rules in admission webhooks and calls them in parallel.</p><ol><li><strong>Webhook Admission Server</strong></li></ol><p>Webhook Admission Server is just plain http server that adhere to Kubernetes <a href="https://github.com/kubernetes/kubernetes/blob/v1.9.0/pkg/apis/admission/types.go">admission API</a>. For each request to the <code>apiserver</code>, the <code>MutatingAdmissionWebhook</code> sends an <code>admissionReview</code>(<a href="https://github.com/kubernetes/kubernetes/blob/v1.9.0/pkg/apis/admission/types.go">API</a> for reference) to the relevant webhook admission server. The webhook admission server gathers information like <code>object</code>, <code>oldobject</code>, and <code>userInfo</code> from <code>admissionReview</code>, and sends back an <code>admissionReview</code> response including <code>AdmissionResponse</code> whose <code>Allowed</code> and <code>Result</code> fields are filled with the admission decision and optional <code>Patch</code> to mutate the resoures.</p><h2 id="tutorial-for-mutatingadmissionwebhook">Tutorial for MutatingAdmissionWebhook</h2><p>Writing a complete Webhook Admission Server may be intimidating. To make it easier, weâ€™ll write a simple Webhook Admission Server that implements injecting nginx sidecar container and volume. The complete code can be found in the <a href="https://github.com/morvencao/kube-mutating-webhook-tutorial">kube-mutating-webhook-tutorial</a>. This project refers to `Kunernetes webhook example](<a href="https://github.com/kubernetes/kubernetes/tree/release-1.9/test/images/webhook">https://github.com/kubernetes/kubernetes/tree/release-1.9/test/images/webhook</a>) and <a href="https://github.com/istio/istio/tree/master/pilot/pkg/kube/inject">Istio sidecar injection implementation</a>.</p><p>In the following sections, Iâ€™ll show you how to write a working containerized webhook admission server and deploy it to a Kubernetes cluster.</p><h3 id="prerequisites">Prerequisites</h3><p><code>MutatingAdmissionWebhook</code> requires a Kubernetes 1.9.0 or above with the <code>admissionregistration.k8s.io/v1beta1</code> API enabled. Verify that by the following command:</p><pre><code>kubectl api-versions | grep admissionregistration.k8s.io/v1beta1
</code></pre><p>The result should not be empty.</p><p>In addition, the <code>MutatingAdmissionWebhook</code> and <code>ValidatingAdmissionWebhook</code> admission controllers should be added and listed in the correct order in the <code>admission-control</code> flag of <code>kube-apiserver</code>.</p><h3 id="write-the-webhook-server">Write the Webhook Server</h3><p>Webhook Admission Server is just a simple http server that adheres to the <a href="https://github.com/kubernetes/kubernetes/blob/v1.9.0/pkg/apis/admission/types.go">Kubernetes admission API</a>. I&rsquo;ll paste some pseudo code to describe the main logic:</p><pre><code>sidecarConfig, err := loadConfig(parameters.sidecarCfgFile)
pair, err := tls.LoadX509KeyPair(parameters.certFile, parameters.keyFile)

whsvr := &amp;WebhookServer {
    sidecarConfig:    sidecarConfig,
    server:           &amp;http.Server {
        Addr:        fmt.Sprintf(&quot;:%v&quot;, 443),
        TLSConfig:   &amp;tls.Config{Certificates: []tls.Certificate{pair}},
    },
}
	
// define http server and server handler
mux := http.NewServeMux()
mux.HandleFunc(&quot;/mutate&quot;, whsvr.serve)
whsvr.server.Handler = mux

// start webhook server in new rountine
go func() {
    if err := whsvr.server.ListenAndServeTLS(&quot;&quot;, &quot;&quot;); err != nil {
        glog.Errorf(&quot;Filed to listen and serve webhook server: %v&quot;, err)
    }
}()
</code></pre><p>Explanation for the above code:</p><ul><li><code>sidecarCfgFile</code> contains sidecar injector template defined in <code>ConfigMap</code> below.</li><li><code>certFile</code> and <code>keyFile</code> key pair that will be needed for TLS communication between <code>apiserver</code> and webhook server.</li><li>Line 19 starts https server listening on 443 on path <code>/mutate</code>.</li></ul><p>Next weâ€™ll focus on the main logic of the handler function serve:</p><pre><code>// Serve method for webhook server
func (whsvr *WebhookServer) serve(w http.ResponseWriter, r *http.Request) {
	var body []byte
	if r.Body != nil {
		if data, err := ioutil.ReadAll(r.Body); err == nil {
			body = data
		}
	}

	var reviewResponse *v1beta1.AdmissionResponse
	ar := v1beta1.AdmissionReview{}
	deserializer := codecs.UniversalDeserializer()
	if _, _, err := deserializer.Decode(body, nil, &amp;ar); err != nil {
		glog.Error(err)
		reviewResponse = toAdmissionResponse(err)
	} else {
		reviewResponse = mutate(ar)
	}

	response := v1beta1.AdmissionReview{}
	if reviewResponse != nil {
		response.Response = reviewResponse
		response.Response.UID = ar.Request.UID
	}
	// reset the Object and OldObject, they are not needed in a response.
	ar.Request.Object = runtime.RawExtension{}
	ar.Request.OldObject = runtime.RawExtension{}

	resp, err := json.Marshal(response)
	if err != nil {
		glog.Error(err)
	}
	if _, err := w.Write(resp); err != nil {
		glog.Error(err)
	}
}
</code></pre><p>The <code>serve</code> function is a simple http handler with http request and response writer parameters.</p><ul><li>First demarshal the request to AdmissionReview, which contains information like <code>object</code>, <code>oldobject</code> and <code>userInfo</code>&hellip;</li><li>Then call Webhook core function <code>mutate</code> to create patch that injects sidecar container and volume.</li><li>Finally, demarshal the response with admission decision and optional patch, the send it back to <code>apiserver</code>.</li></ul><p>For the part of <code>mutate</code> function, you get the free rein to complete it in your preferred way. Let&rsquo;s take my implementation as an example:</p><pre><code>// main mutation process
func (whsvr *WebhookServer) mutate(ar *v1beta1.AdmissionReview) *v1beta1.AdmissionResponse {
	req := ar.Request
	var pod corev1.Pod
	if err := json.Unmarshal(req.Object.Raw, &amp;pod); err != nil {
		glog.Errorf(&quot;Could not unmarshal raw object: %v&quot;, err)
		return &amp;v1beta1.AdmissionResponse {
			Result: &amp;metav1.Status {
				Message: err.Error(),
			},
		}
	}
	
	// determine whether to perform mutation
	if !mutationRequired(ignoredNamespaces, &amp;pod.ObjectMeta) {
		glog.Infof(&quot;Skipping mutation for %s/%s due to policy check&quot;, pod.Namespace, pod.Name)
		return &amp;v1beta1.AdmissionResponse {
			Allowed: true, 
		}
	}

	annotations := map[string]string{admissionWebhookAnnotationStatusKey: &quot;injected&quot;}
	patchBytes, err := createPatch(&amp;pod, whsvr.sidecarConfig, annotations)
	
	return &amp;v1beta1.AdmissionResponse {
		Allowed: true,
		Patch:   patchBytes,
		PatchType: func() *v1beta1.PatchType {
			pt := v1beta1.PatchTypeJSONPatch
			return &amp;pt
		}(),
	}
}
</code></pre><p>From the code above, the <code>mutate</code> function calls <a href="https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go#L98-L130">mutationRequired</a> to detemine whether mutation is required or not. For those requiring mutation, the <code>mutate</code> function gets the mutation &lsquo;patch&rsquo; from another function <a href="https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go#L196-L205">createPatch</a>. Pay close attention to the little trick in function <code>mutationRequired</code>, we skip the pods without annotation <code>sidecar-injector-webhook.morven.me/inject: true</code>. That will be mentioned latter when we deployment applications. For complete code, please refer to <a href="https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go">https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go</a>.</p><h3 id="create-dockerfile-and-build-the-container">Create Dockerfile and Build the Container</h3><p>Create the <code>build</code> script:</p><pre><code>dep ensure
CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o kube-mutating-webhook-tutorial .
docker build --no-cache -t morvencao/sidecar-injector:v1 .
rm -rf kube-mutating-webhook-tutorial

docker push morvencao/sidecar-injector:v1
</code></pre><p>And create <code>Dockerfile</code> as dependency of build script:</p><pre><code>FROM alpine:latest

ADD kube-mutating-webhook-tutorial /kube-mutating-webhook-tutorial
ENTRYPOINT [&quot;./kube-mutating-webhook-tutorial&quot;]
</code></pre><p>Before actually building the container, you need a <a href="https://hub.docker.com/">Docker</a> account and change the image name&amp;tag(in <code>Dockerfile</code> and <code>deployment.yaml</code>) to yours, then execute:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# ./build
Sending build context to Docker daemon  44.89MB
Step 1/3 : FROM alpine:latest
 ---&gt; 3fd9065eaf02
Step 2/3 : ADD kube-mutating-webhook-tutorial /kube-mutating-webhook-tutorial
 ---&gt; 432de60c2b3f
Step 3/3 : ENTRYPOINT [&quot;./kube-mutating-webhook-tutorial&quot;]
 ---&gt; Running in da6e956d1755
Removing intermediate container da6e956d1755
 ---&gt; 619faa936145
Successfully built 619faa936145
Successfully tagged morvencao/sidecar-injector:v1
The push refers to repository [docker.io/morvencao/sidecar-injector]
efd05fe119bb: Pushed
cd7100a72410: Layer already exists
v1: digest: sha256:7a4889928ec5a8bcfb91b610dab812e5228d8dfbd2b540cd7a341c11f24729bf size: 739
</code></pre><h3 id="create-sidecar-injection-configuration">Create Sidecar Injection Configuration</h3><p>Now letâ€™s create a Kubernetes <code>ConfigMap</code>, which includes <code>container</code> and <code>volume</code> information that will be injected into the target pod.</p><pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: sidecar-injector-webhook-configmap
data:
  sidecarconfig.yaml: |
    containers:
      - name: sidecar-nginx
        image: nginx:1.12.2
        imagePullPolicy: IfNotPresent
        ports:
          - containerPort: 80
        volumeMounts:
          - name: nginx-conf
            mountPath: /etc/nginx
    volumes:
      - name: nginx-conf
        configMap:
          name: nginx-configmap
</code></pre><p>From the above manifest, another ConfigMap including nginx conf is required. Here we put it in <a href="https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/deployment/nginxconfigmap.yaml">nginxconfigmap.yaml</a>.</p><p>Then deploy the two ConfigMaps to cluster:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/nginxconfigmap.yaml
configmap &quot;nginx-configmap&quot; created
[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/configmap.yaml
configmap &quot;sidecar-injector-webhook-configmap&quot; created
</code></pre><h3 id="create-secret-including-signed-key-cert-pair">Create Secret Including Signed key/cert Pair</h3><p>Supporting <code>TLS</code> for external webhook server is also required because admission is a high security operation. As part of the process, we need to create a TLS certificate signed by the Kubernetes CA to secure the communication between the webhook server and <code>apiserver</code>. For the complete steps for creating and approving the process for <code>CSR</code>, please refer to <a href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/">https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/</a>.</p><p>For simplicity purposes, we referred to the <a href="https://github.com/istio/istio/blob/master/install/kubernetes/webhook-create-signed-cert.sh">script</a> from <code>Istio</code> and created a similar script called <code>webhook-create-signed-cert.sh</code> to automatically create the <code>cert/key</code> pair and include it in a Kubernetes secret.</p><pre><code>#!/bin/bash
while [[ $# -gt 0 ]]; do
    case ${1} in
        --service)
            service=&quot;$2&quot;
            shift
            ;;
        --secret)
            secret=&quot;$2&quot;
            shift
            ;;
        --namespace)
            namespace=&quot;$2&quot;
            shift
            ;;
    esac
    shift
done

[ -z ${service} ] &amp;&amp; service=sidecar-injector-webhook-svc
[ -z ${secret} ] &amp;&amp; secret=sidecar-injector-webhook-certs
[ -z ${namespace} ] &amp;&amp; namespace=default

csrName=${service}.${namespace}
tmpdir=$(mktemp -d)
echo &quot;creating certs in tmpdir ${tmpdir} &quot;

cat &lt;&lt;EOF &gt;&gt; ${tmpdir}/csr.conf
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = ${service}
DNS.2 = ${service}.${namespace}
DNS.3 = ${service}.${namespace}.svc
EOF

openssl genrsa -out ${tmpdir}/server-key.pem 2048
openssl req -new -key ${tmpdir}/server-key.pem -subj &quot;/CN=${service}.${namespace}.svc&quot; -out ${tmpdir}/server.csr -config ${tmpdir}/csr.conf

# clean-up any previously created CSR for our service. Ignore errors if not present.
kubectl delete csr ${csrName} 2&gt;/dev/null || true

# create  server cert/key CSR and  send to k8s API
cat &lt;&lt;EOF | kubectl create -f -
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: ${csrName}
spec:
  groups:
  - system:authenticated
  request: $(cat ${tmpdir}/server.csr | base64 | tr -d '\n')
  usages:
  - digital signature
  - key encipherment
  - server auth
EOF

# verify CSR has been created
while true; do
    kubectl get csr ${csrName}
    if [ &quot;$?&quot; -eq 0 ]; then
        break
    fi
done

# approve and fetch the signed certificate
kubectl certificate approve ${csrName}
# verify certificate has been signed
for x in $(seq 10); do
    serverCert=$(kubectl get csr ${csrName} -o jsonpath='{.status.certificate}')
    if [[ ${serverCert} != '' ]]; then
        break
    fi
    sleep 1
done
if [[ ${serverCert} == '' ]]; then
    echo &quot;ERROR: After approving csr ${csrName}, the signed certificate did not appear on the resource. Giving up after 10 attempts.&quot; &gt;&amp;2
    exit 1
fi
echo ${serverCert} | openssl base64 -d -A -out ${tmpdir}/server-cert.pem


# create the secret with CA cert and server cert/key
kubectl create secret generic ${secret} \
        --from-file=key.pem=${tmpdir}/server-key.pem \
        --from-file=cert.pem=${tmpdir}/server-cert.pem \
        --dry-run -o yaml |
    kubectl -n ${namespace} apply -f -
</code></pre><p>We then execute it and a Kubernetes secret including <code>cert/key</code> pair is created:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# ./deployment/webhook-create-signed-cert.sh
creating certs in tmpdir /tmp/tmp.wXZywp0wAF
Generating RSA private key, 2048 bit long modulus
...........................................+++
..........+++
e is 65537 (0x10001)
certificatesigningrequest &quot;sidecar-injector-webhook-svc.default&quot; created
NAME                                   AGE       REQUESTOR                                           CONDITION
sidecar-injector-webhook-svc.default   0s        https://mycluster.icp:9443/oidc/endpoint/OP#admin   Pending
certificatesigningrequest &quot;sidecar-injector-webhook-svc.default&quot; approved
secret &quot;sidecar-injector-webhook-certs&quot; created
</code></pre><h3 id="create-the-sidecar-injector-deployment-and-service">Create the Sidecar Injector Deployment and Service</h3><p>The <code>deployment</code> brings up 1 pod in which the <code>sidecar-injector</code> container is running. The container starts with special arguments:</p><ul><li><code>sidecarCfgFile</code> pointing to the sidecar injector configuration file mounted from <code>sidecar-injector-webhook-configmap</code> ConfigMap created above.</li><li><code>tlsCertFile</code> and <code>tlsKeyFile</code> are <code>cert/key</code> pair mounted from <code>sidecar-injector-webhook-certs</code> Secret create by script above.</li><li><code>alsologtostderr</code> <code>v=4</code> and <code>2&gt;&amp;1</code> are logging arguments.</li></ul><pre><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: sidecar-injector-webhook-deployment
  labels:
    app: sidecar-injector
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: sidecar-injector
    spec:
      containers:
        - name: sidecar-injector
          image: morvencao/sidecar-injector:v1
          imagePullPolicy: IfNotPresent
          args:
            - -sidecarCfgFile=/etc/webhook/config/sidecarconfig.yaml
            - -tlsCertFile=/etc/webhook/certs/cert.pem
            - -tlsKeyFile=/etc/webhook/certs/key.pem
            - -alsologtostderr
            - -v=4
            - 2&gt;&amp;1
          volumeMounts:
            - name: webhook-certs
              mountPath: /etc/webhook/certs
              readOnly: true
            - name: webhook-config
              mountPath: /etc/webhook/config
      volumes:
        - name: webhook-certs
          secret:
            secretName: sidecar-injector-webhook-certs
        - name: webhook-config
          configMap:
            name: sidecar-injector-webhook-configmap
</code></pre><p>The <code>service</code> exposes the pod defined above labeled by <code>app=sidecar-injector</code> to make it accessible in cluster. This service will be referred by the <code>MutatingWebhookConfiguration</code> in <code>clientConfig</code> section and by default spec.ports.port should be <strong>443</strong>(default https port).</p><pre><code>apiVersion: v1
kind: Service
metadata:
  name: sidecar-injector-webhook-svc
  labels:
    app: sidecar-injector
spec:
  ports:
  - port: 443
    targetPort: 443
  selector:
    app: sidecar-injector
</code></pre><p>Next we deploy the above <code>Deployment</code> and <code>Service</code> to cluster and verify the sidecar injector webhook server is running:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/deployment.yaml
deployment &quot;sidecar-injector-webhook-deployment&quot; created
[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/service.yaml
service &quot;sidecar-injector-webhook-svc&quot; created
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get deployment
NAME                                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
sidecar-injector-webhook-deployment   1         1         1            1           2m
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pod
NAME                                                  READY     STATUS    RESTARTS   AGE
sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running   0          3m
</code></pre><h3 id="configure-webhook-admission-controller-on-the-fly">Configure webhook admission controller on the fly</h3><p><code>MutatingWebhookConfiguration</code> specifies which webhook admission servers are enabled and which resources are subject to the admission server. It is recommended that you firstly deploy the webhook admission server and make sure it is working properly before creating the <code>MutatingWebhookConfiguration</code>. Otherwise, requests will be unconditionally accepted or rejected based on <code>failurePolicy</code>.</p><p>For now, we create the <code>MutatingWebhookConfiguration</code> manifest with the following content:</p><pre><code>apiVersion: admissionregistration.k8s.io/v1beta1
kind: MutatingWebhookConfiguration
metadata:
  name: sidecar-injector-webhook-cfg
  labels:
    app: sidecar-injector
webhooks:
  - name: sidecar-injector.morven.me
    clientConfig:
      service:
        name: sidecar-injector-webhook-svc
        namespace: default
        path: &quot;/mutate&quot;
      caBundle: ${CA_BUNDLE}
    rules:
      - operations: [ &quot;CREATE&quot; ]
        apiGroups: [&quot;&quot;]
        apiVersions: [&quot;v1&quot;]
        resources: [&quot;pods&quot;]
    namespaceSelector:
      matchLabels:
        sidecar-injector: enabled
</code></pre><p>Line 8: <code>name</code> - name for the webhook, should be fully qualified. Mutiple mutating webhooks are sorted by providing order. Line 9: <code>clientConfig</code> - describes how to connect to the webhook admission server and the TLS certificate. In our case, we specify the sidecar injector service. Line 15: <code>rules</code> - specifies what resources and what actions the webhook server handles. In our case, only intercepts request for creating of pods. Line 20: <code>namespaceSelector</code> - <code>namespaceSelector</code> decides whether to send admission request the webhook server on an object based on whether the namespace for that object matches the selector.</p><p>Before deploying the <code>MutatingWebhookConfiguration</code>, we need to replace the <code>${CA_BUNDLE}</code> with apiserver&rsquo;s default caBundle. Let&rsquo;s write the script <code>webhook-patch-ca-bundle.sh</code> to automate this process:</p><pre><code>#!/bin/bash
set -o errexit
set -o nounset
set -o pipefail

ROOT=$(cd $(dirname $0)/../../; pwd)

export CA_BUNDLE=$(kubectl get configmap -n kube-system extension-apiserver-authentication -o=jsonpath='{.data.client-ca-file}' | base64 | tr -d '\n')

if command -v envsubst &gt;/dev/null 2&gt;&amp;1; then
    envsubst
else
    sed -e &quot;s|\${CA_BUNDLE}|${CA_BUNDLE}|g&quot;
fi
</code></pre><p>Then execute:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# cat ./deployment/mutatingwebhook.yaml |\
&gt;   ./deployment/webhook-patch-ca-bundle.sh &gt;\
&gt;   ./deployment/mutatingwebhook-ca-bundle.yaml
</code></pre><p>Finally we can deploy <code>MutatingWebhookConfiguration</code>:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl create -f ./deployment/mutatingwebhook-ca-bundle.yaml
mutatingwebhookconfiguration &quot;sidecar-injector-webhook-cfg&quot; created
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get mutatingwebhookconfiguration
NAME                           AGE
sidecar-injector-webhook-cfg   11s
</code></pre><h3 id="verification-and-troubleshooting">Verification and Troubleshooting</h3><p>Now itâ€™s time to verify sidecar injector works as expected and try to see how to troubleshoot if you encounter issues. Typically we create and deploy a sleep application in <code>default</code> namespace to see if the sidecar can be injected.</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# cat &lt;&lt;EOF | kubectl create -f -
&gt; apiVersion: extensions/v1beta1
&gt; kind: Deployment
&gt; metadata:
&gt;   name: sleep
&gt; spec:
&gt;   replicas: 1
&gt;   template:
&gt;     metadata:
&gt;       annotations:
&gt;         sidecar-injector-webhook.morven.me/inject: &quot;true&quot;
&gt;       labels:
&gt;         app: sleep
&gt;     spec:
&gt;       containers:
&gt;       - name: sleep
&gt;         image: tutum/curl
&gt;         command: [&quot;/bin/sleep&quot;,&quot;infinity&quot;]
&gt;         imagePullPolicy: IfNotPresent
&gt; EOF
deployment &quot;sleep&quot; created
</code></pre><p>Pay close attention to the <code>spec.template.metadata.annotations</code> as there is a new annotation added:</p><pre><code>sidecar-injector-webhook.morven.me/inject: &quot;true&quot;
</code></pre><p>The sidecar injector has some logic to check the existence of the above annotation before injecting sidecar container and volume. Youâ€™re free to delete the logic or customize it before build the sidecar injector container.</p><p>Check the deployment and pod:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get deployment
NAME                                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
sidecar-injector-webhook-deployment   1         1         1            1           18m
sleep                                 1         1         1            1           58s
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pod
NAME                                                  READY     STATUS    RESTARTS   AGE
sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running   0          18m
sleep-6d79d8dc54-r66vz                                1/1       Running   0          1m
</code></pre><p>Itâ€™s not there. Whatâ€™s going on? Letâ€™s check the sidecar injector logs:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl logs -f sidecar-injector-webhook-deployment-bbb689d69-fdbgj
I0314 08:48:15.140858       1 webhook.go:88] New configuration: sha256sum 21669464280f76170b88241fd79ecbca3dcebaec5c152a4a9a3e921ff742157f
</code></pre><p>We canâ€™t find any logs that indicate webhook server got admission request, seems that request hadnâ€™t been sent to sidecar injector webhook server. So there is a possibility that the issue is caused by configuration in <code>MutatingWebhookConfiguration</code>. Do a double check of <code>MutatingWebhookConfiguration</code> and we find following content:</p><pre><code>namespaceSelector:
      matchLabels:
        sidecar-injector: enabled
</code></pre><h3 id="control-sidecar-injector-with-namespaceselector">Control sidecar injector with namespaceSelector</h3><p>We have configured â€˜namespaceSelectorâ€™ in <code>MutatingWebhookConfiguration</code>, which means only resources in namespace matching the selector will be sent to webhook server. So we need label the <code>default</code> namespace with <code>sidecar-injector=enabled</code>:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl label namespace default sidecar-injector=enabled
namespace &quot;default&quot; labeled
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get namespace -L sidecar-injector
NAME          STATUS    AGE       sidecar-injector
default       Active    1d        enabled
kube-public   Active    1d
kube-system   Active    1d
</code></pre><p>We have now configured the <code>MutatingWebhookConfiguration</code> resulting in the sidecar injection occurring at pod creation time. Kill the running pod and verify a new pod is created with the injected sidecar.</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl delete pod sleep-6d79d8dc54-r66vz
pod &quot;sleep-6d79d8dc54-r66vz&quot; deleted
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pods
NAME                                                  READY     STATUS              RESTARTS   AGE
sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running             0          29m
sleep-6d79d8dc54-b8ztx                                0/2       ContainerCreating   0          3s
sleep-6d79d8dc54-r66vz                                1/1       Terminating         0          11m
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pod sleep-6d79d8dc54-b8ztx -o yaml
apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubernetes.io/psp: default
    sidecar-injector-webhook.morven.me/inject: &quot;true&quot;
    sidecar-injector-webhook.morven.me/status: injected
  labels:
    app: sleep
    pod-template-hash: &quot;2835848710&quot;
  name: sleep-6d79d8dc54-b8ztx
  namespace: default
spec:
  containers:
  - command:
    - /bin/sleep
    - infinity
    image: tutum/curl
    imagePullPolicy: IfNotPresent
    name: sleep
    resources: {}
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: default-token-d7t2r
      readOnly: true
  - image: nginx:1.12.2
    imagePullPolicy: IfNotPresent
    name: sidecar-nginx
    ports:
    - containerPort: 80
      protocol: TCP
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /etc/nginx
      name: nginx-conf
  volumes:
  - name: default-token-d7t2r
    secret:
      defaultMode: 420
      secretName: default-token-d7t2r
  - configMap:
      defaultMode: 420
      name: nginx-configmap
    name: nginx-conf
...
</code></pre><p>We can see that sidecar container and volume have been injected into sleep application successfully. Until now, we have working sidecar injector with <code>MutatingAdmissionWebhook</code>. With <code>namespaceSelector</code> we can easily control whether the pods in specified namespace will be injected or not.</p><p>But there is a problem for this, with the above configurations, all of the pods in <code>default</code> namespace will be injected with a sidecar, this may be not expected for some cases.</p><h3 id="control-sidecar-injector-with-annotation">Control sidecar injector with annotation</h3><p>Thanks to flexibility of <code>MutatingAdmissionWebhook</code>, we can easily customized the mutating logic to filter resources with specified annotations. Remember the annotation <code>sidecar-injector-webhook.morven.me/inject: &quot;true&quot;</code> mentioned above. It can be used as an extra control on sidecar injector. I have written <a href="https://github.com/morvencao/kube-mutating-webhook-tutorial/blob/master/webhook.go#L98-L130">some code</a> in webhook server to skip injecting for pod without the annotation.</p><p>Letâ€™s give it a try. In this case, we create another sleep application without <code>sidecar-injector-webhook.morven.me/inject: &quot;true&quot;</code> annotation in <code>podTemplateSpec</code>:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl delete deployment sleep
deployment &quot;sleep&quot; deleted
[root@mstnode kube-mutating-webhook-tutorial]# cat &lt;&lt;EOF | kubectl create -f -
apiVersion: extensions/v1beta1
&gt; kind: Deployment
&gt; metadata:
&gt;   name: sleep
&gt; spec:
&gt;   replicas: 1
&gt;   template:
&gt;     metadata:
&gt;       labels:
&gt;         app: sleep
&gt;     spec:
&gt;       containers:
&gt;       - name: sleep
&gt;         image: tutum/curl
&gt;         command: [&quot;/bin/sleep&quot;,&quot;infinity&quot;]
&gt;         imagePullPolicy: IfNotPresent
&gt; EOF
deployment &quot;sleep&quot; created
</code></pre><p>And then verify the sidecar injector skipped the pod:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl get deployment
NAME                                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
sidecar-injector-webhook-deployment   1         1         1            1           45m
sleep                                 1         1         1            1           17s
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pod
NAME                                                  READY     STATUS        RESTARTS   AGE
sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running       0          45m
sleep-776b7bcdcd-4bz58                                1/1       Running       0          21s
</code></pre><p>The output shows that the sleep application contains only one container, no extra container and volume injected. Then we patch the sleep deployment to add the additional annotation and verify it will be injected after recreated:</p><pre><code>[root@mstnode kube-mutating-webhook-tutorial]# kubectl patch deployment sleep -p '{&quot;spec&quot;:{&quot;template&quot;:{&quot;metadata&quot;:{&quot;annotations&quot;:{&quot;sidecar-injector-webhook.morven.me/inject&quot;: &quot;true&quot;}}}}}'
deployment &quot;sleep&quot; patched
[root@mstnode kube-mutating-webhook-tutorial]# kubectl delete pod sleep-776b7bcdcd-4bz58
pod &quot;sleep-776b7bcdcd-4bz58&quot; deleted
[root@mstnode kube-mutating-webhook-tutorial]# kubectl get pods
NAME                                                  READY     STATUS              RESTARTS   AGE
sidecar-injector-webhook-deployment-bbb689d69-fdbgj   1/1       Running             0          49m
sleep-3e42ff9e6c-6f87b                                0/2       ContainerCreating   0          18s
sleep-776b7bcdcd-4bz58                                1/1       Terminating         0          3m
</code></pre><p>As expected, the pod has been injected with extra sidecar container. Now, we got working sidecar injector with <code>mutatingAdmissionWebhook</code> and its coarse-grained control by <code>namespaceSelector</code> and fine-grained control by additional annotation.</p><h2 id="conclusion">Conclusion</h2><p><code>MutatingAdmissionWebhook</code> is one of easiest ways of extending Kubernetes with new policy controls and resources mutation and a host of other options.</p><p>This feature will enable more workloads and support more ecosystem components, including <a href="https://github.com/istio/istio">Istio</a> service mesh platform. Starting with Istio 0.5.0, Istio has been refactored to support their auto injection code with <code>MutatingAdmissionWebhook</code> replacing <code>initializers</code>.</p><h2 id="reference">Reference</h2><ul><li><a href="http://blog.kubernetes.io/2018/01/extensible-admission-is-beta.html">http://blog.kubernetes.io/2018/01/extensible-admission-is-beta.html</a></li><li><a href="https://docs.google.com/document/d/1c4kdkY3ha9rm0OIRbGleCeaHknZ-NR1nNtDp-i8eH8E/view">https://docs.google.com/document/d/1c4kdkY3ha9rm0OIRbGleCeaHknZ-NR1nNtDp-i8eH8E/view</a></li><li><a href="https://v1-8.docs.kubernetes.io/docs/admin/extensible-admission-controllers/">https://v1-8.docs.kubernetes.io/docs/admin/extensible-admission-controllers/</a></li><li><a href="https://github.com/kubernetes/kubernetes/tree/release-1.9/test/images/webhook">https://github.com/kubernetes/kubernetes/tree/release-1.9/test/images/webhook</a></li></ul></div></div></div></article><script src="https://morven.life/js/highlight.pack.js"></script><script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@10.19.0/dist/lazyload.min.js"></script><script>var lazyImage = new LazyLoad({
    container: document.getElementById('article')
  });</script><script>hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });</script></body></html>