<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hugo 0.58.3"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Morven&#39;s Life"><meta property="og:url" content="https://morven.life/notes/the_knowledge_of_docker/"><link rel="canonical" href="https://morven.life/notes/the_knowledge_of_docker/"><link rel="shortcut icon" href="https://morven.life/favicon.ico" type="image/x-png"><script type="application/ld+json">{
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/morven.life\/"
      },
      "articleSection" : "notes",
      "name" : "Docker知识点拾遗",
      "headline" : "Docker知识点拾遗",
      "description" : "Docker是一个划时代的产品，它彻底地释放了计算机虚拟化的威力，极大的提高了应用的部署、测试和分发。虽然我们几乎每天都使用docker，但还是有一些特别容易被忽略却很重要的docker知识，今天，我们就集中起来聊一聊。\nDocker与传统虚拟机的区别 经常有人说“docker是一种性能非常好的虚拟机”，这种说法是错误的。Docker相比于传统虚拟机的技术来说更为轻便，具体表现在docker不是在宿主机上虚拟出一套硬件后再运行一个完整的操作系统，然后再在其上运行所需的应用进程，而是docker容器里面的进程直接运行在宿主的内核（Docker会做文件系统、网络互联到进程隔离等等），容器内没有自己的内核，而且也没有进行硬件虚拟。这样一来docker会相对于传统虚拟机来说“体积更轻、跑的更快、同宿主机下可创建的个数更多”。\nDocker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用systemd去启动后台服务，容器内没有后台服务的概念。举个例子，常有人在dockerfile里面这样写：\nCMD service nginx start  然后发现容器执行后就立即退出了，甚至在容器内去使用systemctl命令结果却发现根本执行不了。没有区分docker容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。对于docker容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。而使用CMD指令service nginx start，则是以后台守护进程形式启动nginx服务。CMD service nginx start最终会被docker引擎转化为CMD [ \x26quot;sh\x26quot;, \x26quot;-c\x26quot;, \x26quot;service nginx start\x26quot;]，因此主进程实际上是sh。那么当service nginx start命令结束后，sh也就结束了，sh作为主进程退出了，自然就会令容器退出。\n正确的做法是直接执行nginx可执行文件，并且要求以前台形式运行：\nCMD [\x26quot;nginx\x26quot;, \x26quot;-g\x26quot;, \x26quot;daemon off;\x26quot;]  慎用docker commit 知道使用docker commit可以在基础镜像层的基础上定制新的镜像。我们知道镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。\n举个例子，我们使用docker commit的定制一个nginx镜像：\n$ docker run --name mynginx -d -p 80:80 nginx  上面的命令帮我们启动一个nginx的容器，接着我们就可以使用http:\/\/localhost来访问这个容器提供的web服务了，如果没啥意外的话，我们会看到 接着我们访问如下输出：\n$ curl http:\/\/localhost \x26lt;!DOCTYPE html\x26gt; \x26lt;html\x26gt; \x26lt;head\x26gt; \x26lt;title\x26gt;Welcome to nginx!\x26lt;\/title\x26gt; \x26lt;style\x26gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \x26lt;\/style\x26gt; \x26lt;\/head\x26gt; \x26lt;body\x26gt; \x26lt;h1\x26gt;Welcome to nginx!",
      "inLanguage" : "en-US",
      "author" : "Morven\x27s Life",
      "creator" : "Morven\x27s Life",
      "publisher": "Morven\x27s Life",
      "accountablePerson" : "Morven\x27s Life",
      "copyrightHolder" : "Morven\x27s Life",
      "copyrightYear" : "2018",
      "datePublished": "2018-11-13 00:00:00 \x2b0000 UTC",
      "dateModified" : "2018-11-13 00:00:00 \x2b0000 UTC",
      "url" : "https:\/\/morven.life\/notes\/the_knowledge_of_docker\/",
      "keywords" : [  ]
  }</script><title>Docker知识点拾遗 - Morven&#39;s Life</title><meta property="og:title" content="Docker知识点拾遗 - Morven&#39;s Life"><meta property="og:type" content="article"><meta name="description" content="Docker是一个划时代的产品，它彻底地释放了计算机虚拟化的威力，极大的提高了应用的部署、测试和分发。虽然我们几乎每天都使用docker，但还是有一些特别容易被忽略却很重要的docker知识，今天，我们就集中起来聊一聊。
Docker与传统虚拟机的区别 经常有人说“docker是一种性能非常好的虚拟机”，这种说法是错误的。Docker相比于传统虚拟机的技术来说更为轻便，具体表现在docker不是在宿主机上虚拟出一套硬件后再运行一个完整的操作系统，然后再在其上运行所需的应用进程，而是docker容器里面的进程直接运行在宿主的内核（Docker会做文件系统、网络互联到进程隔离等等），容器内没有自己的内核，而且也没有进行硬件虚拟。这样一来docker会相对于传统虚拟机来说“体积更轻、跑的更快、同宿主机下可创建的个数更多”。
Docker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用systemd去启动后台服务，容器内没有后台服务的概念。举个例子，常有人在dockerfile里面这样写：
CMD service nginx start  然后发现容器执行后就立即退出了，甚至在容器内去使用systemctl命令结果却发现根本执行不了。没有区分docker容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。对于docker容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。而使用CMD指令service nginx start，则是以后台守护进程形式启动nginx服务。CMD service nginx start最终会被docker引擎转化为CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]，因此主进程实际上是sh。那么当service nginx start命令结束后，sh也就结束了，sh作为主进程退出了，自然就会令容器退出。
正确的做法是直接执行nginx可执行文件，并且要求以前台形式运行：
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]  慎用docker commit 知道使用docker commit可以在基础镜像层的基础上定制新的镜像。我们知道镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。
举个例子，我们使用docker commit的定制一个nginx镜像：
$ docker run --name mynginx -d -p 80:80 nginx  上面的命令帮我们启动一个nginx的容器，接着我们就可以使用http://localhost来访问这个容器提供的web服务了，如果没啥意外的话，我们会看到 接着我们访问如下输出：
$ curl http://localhost &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to nginx!&lt;/title&gt; &lt;style&gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to nginx!"><link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css"><link rel="stylesheet" href="https://morven.life/css/index.css"><link href="https://morven.life/index.xml" rel="alternate" type="application/rss+xml" title="Morven&#39;s Life"><script>(function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});</script></head><body><article class="post Chinese" id="article"><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href="https://morven.life/"><div class="head-line"></div></a><header class="post-header"><h1 class="post-title">Docker知识点拾遗</h1><div class="row"><div class="col-xs-6"><time class="post-date" datetime="2018-11-13 00:00:00 UTC">13 Nov 2018</time></div><div class="col-xs-6"><div class="post-author"><a target="_blank" href="https://morven.life/">@Morven&#39;s Life</a></div></div></div></header><div class="post-content markdown-body"><p><a href="https://www.docker.com/">Docker</a>是一个划时代的产品，它彻底地释放了计算机虚拟化的威力，极大的提高了应用的部署、测试和分发。虽然我们几乎每天都使用docker，但还是有一些特别容易被忽略却很重要的docker知识，今天，我们就集中起来聊一聊。</p><h2 id="docker与传统虚拟机的区别">Docker与传统虚拟机的区别</h2><p>经常有人说“docker是一种性能非常好的虚拟机”，这种说法是错误的。Docker相比于传统虚拟机的技术来说更为轻便，具体表现在docker不是在宿主机上虚拟出一套硬件后再运行一个完整的操作系统，然后再在其上运行所需的应用进程，而是docker容器里面的进程直接运行在宿主的内核（Docker会做文件系统、网络互联到进程隔离等等），容器内没有自己的内核，而且也没有进行硬件虚拟。这样一来docker会相对于传统虚拟机来说“体积更轻、跑的更快、同宿主机下可创建的个数更多”。</p><p>Docker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用<code>systemd</code>去启动后台服务，容器内没有后台服务的概念。举个例子，常有人在dockerfile里面这样写：</p><pre><code>CMD service nginx start
</code></pre><p>然后发现容器执行后就立即退出了，甚至在容器内去使用<code>systemctl</code>命令结果却发现根本执行不了。没有区分docker容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。对于docker容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。而使用CMD指令<code>service nginx start</code>，则是以后台守护进程形式启动nginx服务。<code>CMD service nginx start</code>最终会被docker引擎转化为<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是<code>sh</code>。那么当<code>service nginx start</code>命令结束后，<code>sh</code>也就结束了，<code>sh</code>作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行<code>nginx</code>可执行文件，并且要求以前台形式运行：</p><pre><code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
</code></pre><h2 id="慎用docker-commit">慎用docker commit</h2><p>知道使用<code>docker commit</code>可以在基础镜像层的基础上定制新的镜像。我们知道镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>举个例子，我们使用<code>docker commit</code>的定制一个nginx镜像：</p><pre><code>$ docker run --name mynginx -d -p 80:80 nginx
</code></pre><p>上面的命令帮我们启动一个nginx的容器，接着我们就可以使用<code>http://localhost</code>来访问这个容器提供的web服务了，如果没啥意外的话，我们会看到 接着我们访问如下输出：</p><pre><code>$ curl http://localhost
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>现在我们想定制这个镜像的输出，可以交互式终端方式进入<code>mynginx</code>容器，并执行了<code>bash</code>命令：</p><pre><code>$ docker exec -it mynginx bash
$ echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html
$ exit
exit
</code></pre><p>我们修改了容器的文件，也就是改动了容器的存储层，可以通过<code>docker diff</code>命令看到具体的改动：</p><pre><code>$ docker diff mynginx
C /var
C /var/cache
C /var/cache/nginx
A /var/cache/nginx/scgi_temp
A /var/cache/nginx/uwsgi_temp
A /var/cache/nginx/client_temp
A /var/cache/nginx/fastcgi_temp
A /var/cache/nginx/proxy_temp
C /root
A /root/.bash_history
C /run
A /run/nginx.pid
C /usr
C /usr/share
C /usr/share/nginx
C /usr/share/nginx/html
C /usr/share/nginx/html/index.html
</code></pre><p>紧接着就能像<code>git</code>一样提交保存我们的定制：</p><pre><code>$ docker commit --message &quot;update index.html&quot; mynginx nginx:v2
sha256:f186f20e1afc40dc16cd93bd9843e15aea7e9d0db67057850f15ff7fed10d2f2
</code></pre><p>可以使用<code>docker history</code>查看新镜像的更改历史：</p><pre><code>$ docker history nginx:v2
IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT
f186f20e1afc        About a minute ago   nginx -g daemon off;                            97B                 update index.html
2bcb04bdb83f        13 hours ago         /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B
&lt;missing&gt;           13 hours ago         /bin/sh -c #(nop)  STOPSIGNAL SIGTERM           0B
&lt;missing&gt;           13 hours ago         /bin/sh -c #(nop)  EXPOSE 80                    0B
&lt;missing&gt;           13 hours ago         /bin/sh -c ln -sf /dev/stdout /var/log/nginx…   22B
&lt;missing&gt;           13 hours ago         /bin/sh -c set -x  &amp;&amp; apt-get update  &amp;&amp; apt…   54MB
&lt;missing&gt;           13 hours ago         /bin/sh -c #(nop)  ENV NJS_VERSION=1.15.10.0…   0B
&lt;missing&gt;           13 hours ago         /bin/sh -c #(nop)  ENV NGINX_VERSION=1.15.10…   0B
&lt;missing&gt;           13 hours ago         /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B
&lt;missing&gt;           14 hours ago         /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B
&lt;missing&gt;           14 hours ago         /bin/sh -c #(nop) ADD file:4fc310c0cb879c876…   55.3MB
</code></pre><p>测试我们的新镜像：</p><pre><code>$ docker run -d -p 81:80 nginx:v2
14951d3027633d59b86458211d7fd234949a04c878c508fc904a96e5d79c42bb
$ curl http://localhost:81
&lt;h1&gt;Hello, Docker!&lt;/h1&gt;
</code></pre><p>确实，<code>docker commit</code>可以帮助我们保存容器运行现场，实验docker镜像的分层存储，但是仔细观察之前<code>docker diff mynginx</code>的结果，可以看到除了我们自己的修改之外，还有很多文件也被改动了，仅仅是简单的一个文件就如此，当遇到安装更新软件包等复杂操作的时候，会有大量我们无法控制的改动，可能会是镜像变得无比臃肿。所以要慎用<code>docker commit</code>，尤其是生产环境。</p><p>此外，使用<code>docker commit</code>意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，这就是说就是除了制作镜像人知道新镜像是怎么生成的，别人根本无从得知。虽然<code>docker diff</code>或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>所以要定制镜像，推荐使用<code>dockerfile</code>，它可以很好地解决制作镜像无法重复的问题、镜像构建透明性的问题等。</p><h2 id="docker指令run的最佳实践">Docker指令RUN的最佳实践</h2><p>Docker镜像的分层存储特性决定了dockerfile中每一个指令都会建立一层，<code>RUN</code>也不例外。每一个<code>RUN</code>指令新建一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。所以我们在使用RUN指令的时候一定要注意不要将多个无意义且有关联的命令写到不同的RUN指令中，因为这不但会使镜像层数增加，而且有些中间层完全没有必要保存。另外，<code>Union FS</code>是有最大层数限制的，之前的docker版本规定是最大不得超过42层，现在是不得超过127层。推荐的做法是使用一个RUN指令，并使用<code>&amp;&amp;</code>将各个关联的命令串联起来，来建立新的一层，同时最好在命令的最后有相关的清理工作，例如：</p><pre><code>FROM debian:stretch

RUN buildDeps='gcc libc6-dev make wget' \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y $buildDeps \
    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \
    &amp;&amp; mkdir -p /usr/src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    &amp;&amp; make -C /usr/src/redis \
    &amp;&amp; make -C /usr/src/redis install \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r /usr/src/redis \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps
</code></pre><blockquote><p>Note: 相关的清理工作一定要在执行命令的同一层，因为镜像是多层存储，每一层的东西并不会在下一层被删除。</p></blockquote><h2 id="docker镜像构建上下文-context">Docker镜像构建上下文(Context)</h2><p>我们使用dockerfile构建镜像的常用操作是：</p><pre><code>$ docker build -t &lt;image&gt;:&lt;tag&gt; .
</code></pre><p>看到在命令的最后有一个<code>.</code>。<code>.</code>表示当前目录，而<code>dockerfile</code>就在当前目录，因此很多人认为这个<code>.</code>是指dockerfile所在路径。这么理解其实是不准确的，其实这在指定镜像构建的<strong>上下文路径</strong>。何为上下文呢？</p><p>要了解镜像构建的上下文，先要知道docker的架构。Docker是典型的CS(Client/Server)架构的软件，以后台服务运行的docker引擎作为服务器端，而实际和终端用户进行交互的是docker客户端。docker引擎暴露一组<a href="https://docs.docker.com/develop/sdk/">Rest API</a>供客户端调用，从而完成各种实际功能。虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过<code>RUN</code>指令完成，经常会需要将一些本地文件复制进镜像，比如通过<code>COPY</code>指令、<code>ADD</code>指令等。而<code>docker build</code>命令构建镜像，其实并非在本地构建，而是在服务端，也就是docker引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了<strong>上下文</strong>的概念。当构建的时候，用户需要指定构建镜像上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给docker引擎。这样docker引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>比如，我们在有着一个dockerfile：</p><pre><code>FROM node:slim
COPY ./package.json /app/
</code></pre><p>上面的COPY指令并不是复制dockerfile所在目录下的<code>package.json</code>，而是复制<strong>上下文</strong>目录下的<code>package.json</code>到新镜像中。像COPY这类指令中的源文件的路径都是相对路径。这也是为什么<code>COPY ../package.json /app</code>或者<code>COPY /opt/xxxx /app</code>无法工作的原因，因为这些路径已经超出了<strong>上下文</strong>的范围，Docker引擎无法获得这些位置的文件，如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在仔细观察一下构建的过程，我们会发现有这个发送上下文的过程：</p><pre><code>$ docker build -t myapp:v1 .
Sending build context to Docker daemon   2.56kB
Step 1/2 : FROM node:slim
 ---&gt; 6a8b33e0406d
Step 2/2 : COPY ./package.json /app/
 ---&gt; 5bc4ede5a3aa
Successfully built 5bc4ede5a3aa
Successfully tagged myapp:v1
</code></pre><p>了解<strong>上下文</strong>对于镜像构建是很重要的，避免犯一些不应该的错误。比如有人常常把dockerfile放到硬盘某个目录下面去构建镜像，结果发现<code>docker build</code>执行后，在发送一个几十GB的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让<code>docker build</code>打包整个硬盘，这显然是使用错误。</p><p>推荐的做法是，应该会将<code>dockerfile</code>置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给docker引擎，那么可以用<code>.gitignore</code>一样的语法写一个<code>.dockerignore</code>，该文件是用于剔除构建上下文中不需要传送给docker引擎的文件或目录。</p><p>另外，需要关注的是<code>docker build</code>还支持从URL(比如git仓库)、tar压缩包构建，甚至还可以从标准输入读取dockerfile来构建镜像。</p><h2 id="copy和add的区别">COPY和ADD的区别</h2><p>COPY指令的作用是复制文件到新镜像中，有两种格式：</p><pre><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;source1&gt;, ... &lt;destionation&gt;
COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;source1&gt;&quot;,... &quot;&lt;destionation&gt;&quot;]
</code></pre><p>使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用Git进行管理的时候。</p><p>ADD指令和COPY的格式和性质基本一样，却是更高级的复制。</p><p>1）比如<code>&lt;source&gt;</code>可以是URL。这种情况下，docker引擎会试图去下载这个URL的文件放到<code>&lt;destination&gt;</code>，下载后的文件权限自动设置为<code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层RUN进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层RUN指令进行解压缩。</p><p>所以不如直接使用 RUN 指令，然后使用<code>wget</code>或者<code>curl</code>工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>2）如果<code>&lt;source&gt;</code>为一个tar压缩文件的话，压缩格式为<code>gzip</code>,<code>bzip2</code>以及<code>xz</code>的情况下，ADD指令将会自动解压缩这个压缩文件到<code>&lt;destination&gt;</code>。</p><p>此外，需要注意的是ADD指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>所以在COPY和ADD指令中选择最佳实践是：<strong>所有的文件复制均使用COPY指令，仅在需要自动解压缩的场合使用ADD</strong>。</p><h2 id="cmd和entrypoint的区别">CMD和ENTRYPOINT的区别</h2><p>CMD指令和ENTRYPOINT指令都是用来指定默认的容器主进程的启动命令的。</p><p>CMD指令指定的默认启动命令及参数，在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code>镜像默认的<code>CMD</code>是<code>/bin/bash</code>，如果我们直接<code>docker run -it ubuntu</code>的话，会直接进入<code>bash</code>。我们也可以在运行时指定运行别的命令，如<code>docker run -it ubuntu cat /etc/os-release</code>。这就是用<code>cat /etc/os-release</code>命令替换了默认的<code>/bin/bash</code>命令了，输出了系统版本信息。</p><p>ENTRYPOINT指令指定的默认命令在运行时也可以替代，不过比CMD要略显繁琐，需要通过<code>docker run</code>的参数<code>--entrypoint</code>来指定新的命令。同时，当指定了ENTRYPOINT指令后，CMD指令的含义就发生了改变，不再是直接的运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT指令，换句话说实际执行时，将变为：</p><pre><code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;
</code></pre><p>ENTRYPOINT指令还有一个作用是做程序运行前的一些准备工作。</p><p>例如<code>mysql</code>之类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的<code>mysql</code>服务器运行之前解决。此外，可能希望避免使用<code>root</code>用户去启动服务，从而提高安全性，而在启动服务前还需要以<code>root</code>身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用<code>root</code>身份执行，方便调试等。</p><p>这些准备工作是和容器CMD指令的内容无关，这种情况下，可以写一个脚本，然后放入ENTRYPOINT指令中去执行，而这个脚本会将接到的参数（也就是<code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像redis中就是这么做的：</p><pre><code>FROM alpine:3.6
...
RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis
...
ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]

EXPOSE 6379
CMD [ &quot;redis-server&quot; ]
</code></pre><p>可以看到其中为了redis服务创建了<code>redis</code>用户以用户组，并在最后指定了ENTRYPOINT为<code>docker-entrypoint.sh</code>脚本：</p><pre><code>#!/bin/sh
...
# allow the container to be started with `--user`
if [ &quot;$1&quot; = 'redis-server' -a &quot;$(id -u)&quot; = '0' ]; then
    chown -R redis .
    exec su-exec redis &quot;$0&quot; &quot;$@&quot;
fi

exec &quot;$@&quot;
</code></pre><p>该脚本的内容就是根据CMD的内容来判断，如果是<code>redis-server</code>的话，则切换到<code>redis</code>用户身份启动服务器，否则依旧使用<code>root</code>身份执行。比如：</p><pre><code>$ docker run -it redis id
uid=0(root) gid=0(root) groups=0(root)
</code></pre></div></div></div></article><script src="https://morven.life/js/highlight.pack.js"></script><script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@10.19.0/dist/lazyload.min.js"></script><script>var lazyImage = new LazyLoad({
    container: document.getElementById('article')
  });</script><script>hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });</script></body></html>