<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hugo 0.55.1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Morven&#39;s Life"><meta property="og:url" content="https://morven.life/notes/the_go_channel/"><link rel="canonical" href="https://morven.life/notes/the_go_channel/"><link rel="shortcut icon" href="https://morven.life/favicon.ico" type="image/x-png"><script type="application/ld+json">{
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/morven.life\/"
      },
      "articleSection" : "notes",
      "name" : "Go Routine \x26 Channel",
      "headline" : "Go Routine \x26 Channel",
      "description" : "说到Go语言，不得不提一下Go语言的并发编程。Go从语言层面增加了对并发编程的良好支持，不像Python、Java等其他语言使用Thread库来新建线程，同时使用线程安全队列库来共享数据。Go语言对于并发编程的支持依赖于Go语言的两个基础概念：Go Routine和Go Channel。\n Note: 也许我们还对并发(Concurrency)和并行(Parallelism)傻傻分不清楚，在这里再次强调两者的不同点：\nConcurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.\n也就是说，并发是在同一时间处理多件事情，往往是通过编程的手段，目的是将CPU的利用率提到最高；而并行是在同一时间做多件事情，需要多核CPU的支持。\n Go Routine Go Routine是Go语言并行编程的核心概念之一，有人将它称作为“协程”，是比Thread更轻量级的并发单元，最小Go Routine只需极少的栈内存(大约是4~5KB)，这样十几个Go Routine的规模可能体现在底层就是五六个线程的大小，最高同时运行成千上万个并发任务；同时，Go语言内部实现了Go Routine之间的内存共享使得它比Thread更高效，更易用，我们不必再使用类似于晦涩难用的线程安全的队列库来同步数据。\n创建Go Routine 要创建一个Go Routine，我们只需要在函数调⽤语句前添加go关键字，Go语言的调度器会自动将其安排到合适的系统线程上执行。实际上，我们在并发编程的过程中经常将一个大的任务分成好几块可以并行的小任务，为每一个小任务创建一个Go Routine。当一个程序启动时，其主函数即在一个单独的Go Routine中运行，我们叫它main routine，然后在主函数中使用go关键字来创建其他的Go Routine：\nfunc subTask() { i := 0 for { i\x2b\x2b fmt.Printf(\x26quot;new goroutine: i = %d\\n\x26quot;, i) time.Sleep(1 * time.Second) } } func main() { go subTask() \/\/ Create go rountine to execute sub task i := 0 \/\/ main goroutine for { i\x2b\x2b fmt.",
      "inLanguage" : "en-US",
      "author" : "Morven\x27s Life",
      "creator" : "Morven\x27s Life",
      "publisher": "Morven\x27s Life",
      "accountablePerson" : "Morven\x27s Life",
      "copyrightHolder" : "Morven\x27s Life",
      "copyrightYear" : "2018",
      "datePublished": "2018-02-12 00:00:00 \x2b0000 UTC",
      "dateModified" : "2018-02-12 00:00:00 \x2b0000 UTC",
      "url" : "https:\/\/morven.life\/notes\/the_go_channel\/",
      "keywords" : [  ]
  }</script><title>Go Routine &amp; Channel - Morven&#39;s Life</title><meta property="og:title" content="Go Routine &amp; Channel - Morven&#39;s Life"><meta property="og:type" content="article"><meta name="description" content="说到Go语言，不得不提一下Go语言的并发编程。Go从语言层面增加了对并发编程的良好支持，不像Python、Java等其他语言使用Thread库来新建线程，同时使用线程安全队列库来共享数据。Go语言对于并发编程的支持依赖于Go语言的两个基础概念：Go Routine和Go Channel。
 Note: 也许我们还对并发(Concurrency)和并行(Parallelism)傻傻分不清楚，在这里再次强调两者的不同点：
Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.
也就是说，并发是在同一时间处理多件事情，往往是通过编程的手段，目的是将CPU的利用率提到最高；而并行是在同一时间做多件事情，需要多核CPU的支持。
 Go Routine Go Routine是Go语言并行编程的核心概念之一，有人将它称作为“协程”，是比Thread更轻量级的并发单元，最小Go Routine只需极少的栈内存(大约是4~5KB)，这样十几个Go Routine的规模可能体现在底层就是五六个线程的大小，最高同时运行成千上万个并发任务；同时，Go语言内部实现了Go Routine之间的内存共享使得它比Thread更高效，更易用，我们不必再使用类似于晦涩难用的线程安全的队列库来同步数据。
创建Go Routine 要创建一个Go Routine，我们只需要在函数调⽤语句前添加go关键字，Go语言的调度器会自动将其安排到合适的系统线程上执行。实际上，我们在并发编程的过程中经常将一个大的任务分成好几块可以并行的小任务，为每一个小任务创建一个Go Routine。当一个程序启动时，其主函数即在一个单独的Go Routine中运行，我们叫它main routine，然后在主函数中使用go关键字来创建其他的Go Routine：
func subTask() { i := 0 for { i&#43;&#43; fmt.Printf(&quot;new goroutine: i = %d\n&quot;, i) time.Sleep(1 * time.Second) } } func main() { go subTask() // Create go rountine to execute sub task i := 0 // main goroutine for { i&#43;&#43; fmt."><link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css"><link rel="stylesheet" href="https://morven.life/css/index.css"><link href="https://morven.life/index.xml" rel="alternate" type="application/rss+xml" title="Morven&#39;s Life"><script>(function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});</script></head><body><article class="post Chinese" id="article"><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href="https://morven.life/"><div class="head-line"></div></a><header class="post-header"><h1 class="post-title">Go Routine &amp; Channel</h1><div class="row"><div class="col-xs-6"><time class="post-date" datetime="2018-02-12 00:00:00 UTC">12 Feb 2018</time></div><div class="col-xs-6"><div class="post-author"><a target="_blank" href="https://morven.life/">@Morven&#39;s Life</a></div></div></div></header><div class="post-content markdown-body"><p>说到Go语言，不得不提一下Go语言的并发编程。Go从语言层面增加了对并发编程的良好支持，不像Python、Java等其他语言使用Thread库来新建线程，同时使用线程安全队列库来共享数据。Go语言对于并发编程的支持依赖于Go语言的两个基础概念：<code>Go Routine</code>和<code>Go Channel</code>。</p><blockquote><p>Note: 也许我们还对并发(Concurrency)和并行(Parallelism)傻傻分不清楚，在这里再次强调两者的不同点：</p><p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.</p><p>也就是说，并发是在同一时间处理多件事情，往往是通过编程的手段，目的是将CPU的利用率提到最高；而并行是在同一时间做多件事情，需要多核CPU的支持。</p></blockquote><h2 id="go-routine">Go Routine</h2><p>Go Routine是Go语言并行编程的核心概念之一，有人将它称作为“协程”，是比Thread更轻量级的并发单元，最小Go Routine只需极少的栈内存(大约是4~5KB)，这样十几个Go Routine的规模可能体现在底层就是五六个线程的大小，最高同时运行成千上万个并发任务；同时，Go语言内部实现了Go Routine之间的内存共享使得它比Thread更高效，更易用，我们不必再使用类似于晦涩难用的线程安全的队列库来同步数据。</p><h3 id="创建go-routine">创建Go Routine</h3><p>要创建一个Go Routine，我们只需要在函数调⽤语句前添加<code>go</code>关键字，Go语言的调度器会自动将其安排到合适的系统线程上执行。实际上，我们在并发编程的过程中经常将一个大的任务分成好几块可以并行的小任务，为每一个小任务创建一个Go Routine。当一个程序启动时，其主函数即在一个单独的Go Routine中运行，我们叫它<code>main routine</code>，然后在主函数中使用<code>go</code>关键字来创建其他的Go Routine：</p><pre><code>func subTask() {
    i := 0
    for {
        i++
        fmt.Printf(&quot;new goroutine: i = %d\n&quot;, i)
        time.Sleep(1 * time.Second)
    }
}

func main() {
    go subTask() // Create go rountine to execute sub task

    i := 0
    // main goroutine
    for {
        i++
        fmt.Printf(&quot;main goroutine: i = %d\n&quot;, i)
        time.Sleep(1 * time.Second)
    }
}
</code></pre><p>需要注意的是，<code>main routine</code>退出之后，由它创建的其他Go Routine也会自动退出。这就提醒我们，在并发编程的时候，一定要在<code>main routine</code>退出之前优雅的关闭其他的Go Routine。</p><h3 id="runtime包">Runtime包</h3><p>说到Go Routine，不得不提<a href="https://golang.org/pkg/runtime/">Runtime包</a>。</p><blockquote><p>Package runtime contains operations that interact with Go&rsquo;s runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect&rsquo;s documentation for the programmable interface to the run-time type system.</p></blockquote><p>可以看到Runtime包主要是负责和与Go语言运行时打交道的接口程序包，它可以控制Go Routine，通过反射机制动态获取运行时底层信息。这里，我们主要关注Runtime包控制Go Routine的接口。</p><p>1）Gosched</p><p><code>runtime.Gosched()</code>的作用是让当前Go Routine主动CPU时间片，让Go语言调度器安排其他等待Go Routine的运行，并在下次某个时候从该位置恢复执行，非常类似于Java线程库的<code>Thread.yield</code>。</p><p>举个例子：</p><pre><code>func main() {
    runtime.GOMAXPROCS(1)
    exit := make(chan int)
    go func() {
        defer close(exit)
        go func() {
            fmt.Println(&quot;b&quot;)
        }()
    }()

    for i := 0; i &lt; 6; i++ {
        if i == 4 {
            runtime.Gosched() // switch go routine
        }
        fmt.Println(&quot;a:&quot;, i)
    }
    &lt;-exit
}
</code></pre><p>上述这段程序的输出：</p><pre><code>a: 0
a: 1
a: 2
a: 3
b
a: 5
a: 6
</code></pre><p>2）Goexit</p><p><code>runtime.Goexit()</code>主要用于立即终止当前Go Routine的执⾏，Go语言调度器确保所有已注册<code>defer</code>语句调用被执行。</p><pre><code>func main() {
    go func() {
        defer fmt.Println(&quot;A.defer&quot;)

        func() {
            defer fmt.Println(&quot;B.defer&quot;)
            runtime.Goexit() // exit current go routine, import &quot;runtime&quot;
            fmt.Println(&quot;B&quot;) // never execute this
        }()

        fmt.Println(&quot;A&quot;)
    }()

    // for loop
    for {
    }
}
</code></pre><p>程序的输出：</p><pre><code>B.defer
A.defer
</code></pre><p>3) GOMAXPROCS</p><p>如果要在Go Routine中使用多核，可以使用<code>runtime.GOMAXPROCS()</code>函数设置可以并行计算的CPU核数的最大值，并返回之前的值，当参数小于1时使用默认值。</p><pre><code>func main() {
    //runtime.GOMAXPROCS(1)
    runtime.GOMAXPROCS(2)

    var wg sync.WaitGroup // import &quot;sync&quot;
    wg.Add(2)

    fmt.Println(&quot;Starting Go Routines&quot;)
    go func() {
        defer wg.Done()

        for char := 'a'; char &lt; 'a'+26; char++ {
            fmt.Printf(&quot;%c &quot;, char)
        }
    }()

    go func() {
        defer wg.Done()

        for number := 1; number &lt; 27; number++ {
            fmt.Printf(&quot;%d &quot;, number)
        }
    }()

    fmt.Println(&quot;Waiting To Finish&quot;)
    wg.Wait()

    fmt.Println(&quot;\nTerminating Program&quot;)
}
</code></pre><h2 id="go-channel">Go Channel</h2><p>有了Go Routine，我们可以并发地启动多个子任务，极大地提高处理的效率，但是当多个子任务之间有数据要同步怎么办？比如说我有两个子任务，子任务2必须等子任务1将处理了某个数据之后才能启动子任务2，怎么保证这样的数据共享与同步？这就是Go Channel的作用。</p><p>Go Channel是并发的Go Routine之间进行通信的一种方式，它与Unix中的管道类似，底层是一种先入先出（FIFO）的队列。</p><h3 id="go-channel的类型与声明">Go Channel的类型与声明</h3><p><strong>Go Channel的类型</strong></p><p>Go Channel是类型相关的，一个channel只能传递一种类型的数据，类型的定义格式如下：</p><pre><code>ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType
</code></pre><p>箭头(&lt;-)的指向就是数据的流向，如果没有指定方向，那么channel就是双向的，既可以接收数据，也可以发送数据。<code>ElementType</code>指定channel传递的数据类型。</p><pre><code>chan T          // Send or Receive Data of type T
chan&lt;- T        // only Send Data of type T
&lt;-chan int      // only Receive Data of type T
</code></pre><p>Go Channel必须先创建再使用，和<code>map</code>和<code>slice</code>数据类型一样，我们使用<code>make</code>来创建Go Channel</p><pre><code>make(chan T[, capacity])
</code></pre><p>可选的第二个参数<code>capacity</code>代表Go Channel最多可容纳元素的数量，代表Go Channel的缓存区的大小。如果没有设置容量，或者容量设置为0, 说明Go Channel没有缓存，只有sender和receiver都准备好了后它们的通讯才会发生(之前一直blocking)。如果设置了缓存，只有buffer满了后 sender才会被阻塞，而只有缓存空了后receiver才会被阻塞。一个<code>nil</code>的Go Channel不会通信。</p><h3 id="go-channel的操作">Go Channel的操作</h3><p>Go Channel的操作符是箭头<code>&lt;-</code>，支持multi-valued assignment：</p><pre><code>ch &lt;- v       // Send value 'v' to channel 'ch'
v := &lt;-ch     // Receive value fron channel 'ch' and assign it to v
v, ok := &lt;-ch // Receive value fron channel 'ch' and assign it to v, get the status to 'ok'
</code></pre><p>上面第三个例子的返回结果中<code>ok</code>用来检查Go Channel的状态，如果<code>ok</code>是<code>false</code>，表明接收的<code>v</code>是Channel传递类型的零值，这个Go Channel被关闭了或者为空。</p><p><strong>Send</strong></p><p>Send操作是用来往Go Channel中发送数据，如<code>ch &lt;- 3</code>，它的定义如下:</p><pre><code>SendStmt = Channel &quot;&lt;-&quot; Expression
Channel  = Expression
</code></pre><p>在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。</p><pre><code>c := make(chan int)
defer close(c)
go func() { c &lt;- 3 + 4 }()
i := &lt;-c
fmt.Println(i)
</code></pre><p>Send操作被执行前通讯一直被阻塞着。如前所言，对于无缓存的Go Channel而言，只有在Receiver准备好后Send操作才被执行；如果有缓存，并且缓存未满，则send操作也会被执行。</p><blockquote><p>Note: - 向一个已经被close的Go Channel中发送数据会导致<code>run-time panic</code> - 向nil的Go Channel中发送数据会一直被block</p></blockquote><p><strong>Receive</strong></p><p><code>&lt;-ch</code>用来从Go Channel中接收数据，对于无缓存的Go Channel而言，只有在Sender准备好后receive操作才被执行；如果有缓存，并且缓存不为空，则receive操作也会被执行。</p><blockquote><p>Note: - 从nil的Go Channel中接收数据会一直被block - 从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值</p></blockquote><p><strong>Range</strong></p><p>Go语言中的经常使用<code>for ... range</code>从Go Channel中读取所有值。</p><pre><code>func main() {
	c := make(chan int)
	go func() {
		for i := 0; i &lt; 10; i = i + 1 {
			c &lt;- i
		}
		close(c)
	}()
	for i := range c {
		fmt.Println(i)
	}
	fmt.Println(&quot;Finished&quot;)
}
</code></pre><p>上面的代码片段中，<code>range c</code>产生的迭代值为向Go Channel中发送的值，它会一直迭代直到Channel <code>c</code>被关闭。如果将上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p><p><strong>Select</strong></p><p><code>select</code>语句类似于<code>switch</code>语句，只是用来处理Go Channel直接的并发通信的。<code>select</code>对应的<code>case</code>子句可以是Send表达式，也可以是Receive表达式，亦或者<code>default</code>表达式，<code>select</code>子句可以选择一组可能的Send操作和Receive操作去处理；如果有多个<code>case</code>子句都可以运行，<code>select</code>会随机公平地选出一个执行；如果没有<code>case</code>子句满足处理条件，则会默认选择<code>default</code>去处理；如果没有<code>default</code>子句存在，则<code>select</code>语句会一直被阻塞，直到某个<code>case</code>需要被处理。</p><blockquote><p>Note： 最多允许有一个<code>default</code>子句，它可以放在<code>case</code>子句列表的任何位置，但一般会将它放在最后。<code>nil</code> channel上的<code>select</code>操作会一直被阻塞；如果没有<code>default</code>子句，只有<code>nil</code>的Go Channel上的<code>select</code>语句会一直被阻塞。</p></blockquote><pre><code>func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c &lt;- x:
			x, y = y, x+y
		case &lt;-quit:
			fmt.Println(&quot;quit&quot;)
			return
		}
	}
}
func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i &lt; 10; i++ {
			fmt.Println(&lt;-c)
		}
		quit &lt;- 0
	}()
	fibonacci(c, quit)
}
</code></pre><p><code>select</code>语句和<code>switch</code>语句一样，它不是循环，它只会选择一个<code>case</code>来处理，如果想一直处理Go Channel，可以在外面加一个无限的<code>for</code>循环：</p><pre><code>for {
	select {
	case c &lt;- x:
		x, y = y, x+y
	case &lt;-quit:
		fmt.Println(&quot;quit&quot;)
		return
	}
}
</code></pre><p><strong>Timer和Ticker</strong></p><p><code>select</code>语句一个非常重要的应用就是<strong>超时处理</strong>。 之前提到，如果没有<code>case</code>需要处理，<code>select</code>语句就会一直阻塞着，这时我们就需要一个处理超时的<code>case</code>。</p><p>下面这个例子我们会在2秒后往channel <code>c</code>中发送一个数据，但是<code>select</code>设置为1秒超时，因此我们会打印出<code>timeout 1</code>，而不是<code>result 1</code>：</p><pre><code>import &quot;time&quot;
import &quot;fmt&quot;
func main() {
    c := make(chan string, 1)
    go func() {
        time.Sleep(time.Second * 2)
        c &lt;- &quot;result 1&quot;
    }()
    select {
    case res := &lt;-c:
        fmt.Println(res)
    case &lt;-time.After(time.Second * 1):
        fmt.Println(&quot;timeout 1&quot;)
    }
}
</code></pre><p>利用的是<code>time.After</code>方法，它返回一个类型为<code>&lt;-chan Time</code>的单向的Go Channel，在指定的时间发送一个当前时间给返回的Go Channel中。</p><p>事实上，<code>timer</code>是一个定时器，代表未来的某个事件，在创建<code>timer</code>的时候可以告诉<code>timer</code>要等待多长时间，它将创建并返回一个Go Channel，在将来的那个时间向那个Go Channel提供了一个时间值。下面的例子中第二行会阻塞2秒钟左右的时间，直到时间到了才会继续执行：</p><pre><code>timer1 := time.NewTimer(time.Second * 2)
&lt;-timer1.C
fmt.Println(&quot;Timer 1 expired&quot;)
</code></pre><p><code>ticker</code>是一个定时触发的计时器，它会以一个间隔(interval)向Go Channel发送一个事件(当前时间)，receiver可以以固定的时间间隔从Go Channel中读取事件。下面的例子每500毫秒触发一次，可以观察输出的时间：</p><pre><code>ticker := time.NewTicker(time.Millisecond * 500)
go func() {
	for t := range ticker.C {
		fmt.Println(&quot;Tick at&quot;, t)
	}
}()
</code></pre><p><code>timer</code>和<code>ticker</code>都可以通过<code>Stop()</code>方法来停止。一旦它停止，接收者不再会从Go Channel中接收数据了。</p></div></div></div></article><script src="https://morven.life/js/highlight.pack.js"></script><script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@10.19.0/dist/lazyload.min.js"></script><script>var lazyImage = new LazyLoad({
    container: document.getElementById('article')
  });</script><script>hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });</script></body></html>