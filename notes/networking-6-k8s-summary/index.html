<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hugo 0.55.6"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Morven&#39;s Life"><meta property="og:url" content="https://morven.life/notes/networking-6-k8s-summary/"><link rel="canonical" href="https://morven.life/notes/networking-6-k8s-summary/"><link rel="shortcut icon" href="https://morven.life/favicon.ico" type="image/x-png"><script type="application/ld+json">{
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/morven.life\/"
      },
      "articleSection" : "notes",
      "name" : "Kubernetes网络(一)",
      "headline" : "Kubernetes网络(一)",
      "description" : "通过前面的一些列笔记，我们对于容器网络的各种模型的实现原理已经有了基本的认识，而Kubernetes作为一种容器编排平台，通过整合规模庞大的容器实例形成集群才真正将容器技术发扬光大。这些容器可能运行在异构的底层网络环境中，如何保证这些容器间的互通是实际生产环境中首要考虑的问题。\nKubernetes网络基本要求 Kubernetes对容器技术做了更多的抽象，其中最重要的一点是提出pod的概念，pod是Kubernetes资源调度的基本单元，我们可以简单地认为pod是容器的一种延伸扩展，同一个pod内的所有容器共享同一个netns网络命名空间，并且基于此提出Kubernetes网络设计的原则：\n 每一个Pod都有一个独特的IP地址，所有pod都在一个可以直接连通的、扁平的网络空间中。\n 由此我们可知：\n 同一个pod内的所有容器之间共享端口，可直接通过localhost\x2b对应的端口来访问 每个pod有单独的IP，所以不需要考虑容器端口与主机端口映射以及端口冲突问题  同时，Kubernetes进一步确定了对一个合格集群网络的基本要求： 1. 任意两个pod之间其实是可以直接通信的，无需显式地使用NAT进行地址的转换； 2. 任意集群节点node与任意pod之间是可以直接通信的，无需使用明显的地址转换，反之亦然； 3. 任意pod看到自己的IP跟别人看见它所用的IP是一样的，中间不能经过地址转换；\n也就是说，必须同时满足以上三点的网络模型才能适用于kubernetes，事实上，在早期的Kubernetes中，并没有什么网络标准，只是提出了以上基本要求，只有满足这些要求的网络才可以部署Kubernetes，基于这样的底层网络假设，Kubernetes设计了pod-deployment-service的经典三层服务访问机制。直到1.1发布，Kubernetes才开始采用全新的CNI(Container Network Interface)网络标准。\nCNI 其实，我们在前面介绍容器网络的时候，就提到了CNI网络规范，CNI相对于CNM(Container Network Model)对开发者的约束更少，更开放，不依赖于Docker。事实上，CNI规范确实非常简单，详见：https:\/\/github.com\/containernetworking\/cni\/blob\/master\/SPEC.md\n实现一个CNI网络插件只需要一个配置文件和一个可执行的文件： - 配置文件描述插件的版本、名称、描述等基本信息 - 可执行文件会被上层的容器管理平台调用，一个CNI可执行文件自需要实现将容器加入到网络的ADD操作以及将容器从网络中删除的DEL操作（以及一个可选的VERSION查看版本操作）\n调用CNI网络插件的数据通过两种方式传递： - 环境变量 - 标准输入\nkubernetes使用了CNI网络插件的工作流程： 1. kubelet先创建pause容器生成对应的netns网络命名空间 2. 网络driver根据配置调用具体的CNI插件，可以配置成CNI插件链来进行链式调用 3. 当一个CNI插件被调用时，它根据环境变量以及1个命令行参数来获得需要执行的操作、目标网络netns、容器的网络设备必要信息，然后执行ADD操作 3. CNI插件给pause容器配置正确的网络，pod中其他的容器都是用pause容器的网络\n那么，什么是pause容器，它在pod中处于什么样的位置呢？这就涉及到单个pod的基本网络模型。\npod的网络模型 pod作为容器的一种扩展技术",
      "inLanguage" : "en-US",
      "author" : "Morven\x27s Life",
      "creator" : "Morven\x27s Life",
      "publisher": "Morven\x27s Life",
      "accountablePerson" : "Morven\x27s Life",
      "copyrightHolder" : "Morven\x27s Life",
      "copyrightYear" : "2020",
      "datePublished": "2020-02-03 00:00:00 \x2b0000 UTC",
      "dateModified" : "2020-02-03 00:00:00 \x2b0000 UTC",
      "url" : "https:\/\/morven.life\/notes\/networking-6-k8s-summary\/",
      "keywords" : [  ]
  }</script><title>Kubernetes网络(一) - Morven&#39;s Life</title><meta property="og:title" content="Kubernetes网络(一) - Morven&#39;s Life"><meta property="og:type" content="article"><meta name="description" content="通过前面的一些列笔记，我们对于容器网络的各种模型的实现原理已经有了基本的认识，而Kubernetes作为一种容器编排平台，通过整合规模庞大的容器实例形成集群才真正将容器技术发扬光大。这些容器可能运行在异构的底层网络环境中，如何保证这些容器间的互通是实际生产环境中首要考虑的问题。
Kubernetes网络基本要求 Kubernetes对容器技术做了更多的抽象，其中最重要的一点是提出pod的概念，pod是Kubernetes资源调度的基本单元，我们可以简单地认为pod是容器的一种延伸扩展，同一个pod内的所有容器共享同一个netns网络命名空间，并且基于此提出Kubernetes网络设计的原则：
 每一个Pod都有一个独特的IP地址，所有pod都在一个可以直接连通的、扁平的网络空间中。
 由此我们可知：
 同一个pod内的所有容器之间共享端口，可直接通过localhost&#43;对应的端口来访问 每个pod有单独的IP，所以不需要考虑容器端口与主机端口映射以及端口冲突问题  同时，Kubernetes进一步确定了对一个合格集群网络的基本要求： 1. 任意两个pod之间其实是可以直接通信的，无需显式地使用NAT进行地址的转换； 2. 任意集群节点node与任意pod之间是可以直接通信的，无需使用明显的地址转换，反之亦然； 3. 任意pod看到自己的IP跟别人看见它所用的IP是一样的，中间不能经过地址转换；
也就是说，必须同时满足以上三点的网络模型才能适用于kubernetes，事实上，在早期的Kubernetes中，并没有什么网络标准，只是提出了以上基本要求，只有满足这些要求的网络才可以部署Kubernetes，基于这样的底层网络假设，Kubernetes设计了pod-deployment-service的经典三层服务访问机制。直到1.1发布，Kubernetes才开始采用全新的CNI(Container Network Interface)网络标准。
CNI 其实，我们在前面介绍容器网络的时候，就提到了CNI网络规范，CNI相对于CNM(Container Network Model)对开发者的约束更少，更开放，不依赖于Docker。事实上，CNI规范确实非常简单，详见：https://github.com/containernetworking/cni/blob/master/SPEC.md
实现一个CNI网络插件只需要一个配置文件和一个可执行的文件： - 配置文件描述插件的版本、名称、描述等基本信息 - 可执行文件会被上层的容器管理平台调用，一个CNI可执行文件自需要实现将容器加入到网络的ADD操作以及将容器从网络中删除的DEL操作（以及一个可选的VERSION查看版本操作）
调用CNI网络插件的数据通过两种方式传递： - 环境变量 - 标准输入
kubernetes使用了CNI网络插件的工作流程： 1. kubelet先创建pause容器生成对应的netns网络命名空间 2. 网络driver根据配置调用具体的CNI插件，可以配置成CNI插件链来进行链式调用 3. 当一个CNI插件被调用时，它根据环境变量以及1个命令行参数来获得需要执行的操作、目标网络netns、容器的网络设备必要信息，然后执行ADD操作 3. CNI插件给pause容器配置正确的网络，pod中其他的容器都是用pause容器的网络
那么，什么是pause容器，它在pod中处于什么样的位置呢？这就涉及到单个pod的基本网络模型。
pod的网络模型 pod作为容器的一种扩展技术"><link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css"><link rel="stylesheet" href="https://morven.life/css/index.css"><link href="https://morven.life/index.xml" rel="alternate" type="application/rss+xml" title="Morven&#39;s Life"><script>(function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});</script></head><body><article class="post Chinese" id="article"><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href="https://morven.life/"><div class="head-line"></div></a><header class="post-header"><h1 class="post-title">Kubernetes网络(一)</h1><div class="row"><div class="col-xs-6"><time class="post-date" datetime="2020-02-03 00:00:00 UTC">03 Feb 2020</time></div><div class="col-xs-6"><div class="post-author"><a target="_blank" href="https://morven.life/">@Morven&#39;s Life</a></div></div></div></header><div class="post-content markdown-body"><p>通过前面的一些列笔记，我们对于容器网络的各种模型的实现原理已经有了基本的认识，而Kubernetes作为一种容器编排平台，通过整合规模庞大的容器实例形成集群才真正将容器技术发扬光大。这些容器可能运行在异构的底层网络环境中，如何保证这些容器间的互通是实际生产环境中首要考虑的问题。</p><h2 id="kubernetes网络基本要求">Kubernetes网络基本要求</h2><p>Kubernetes对容器技术做了更多的抽象，其中最重要的一点是提出pod的概念，pod是Kubernetes资源调度的基本单元，我们可以简单地认为pod是容器的一种延伸扩展，同一个pod内的所有容器共享同一个netns网络命名空间，并且基于此提出Kubernetes网络设计的原则：</p><blockquote><p>每一个Pod都有一个独特的IP地址，所有pod都在一个可以直接连通的、扁平的网络空间中。</p></blockquote><p>由此我们可知：</p><ol><li>同一个pod内的所有容器之间共享端口，可直接通过<code>localhost</code>+对应的端口来访问</li><li>每个pod有单独的IP，所以不需要考虑容器端口与主机端口映射以及端口冲突问题</li></ol><p>同时，Kubernetes进一步确定了对一个合格集群网络的基本要求： 1. 任意两个pod之间其实是可以直接通信的，无需显式地使用NAT进行地址的转换； 2. 任意集群节点node与任意pod之间是可以直接通信的，无需使用明显的地址转换，反之亦然； 3. 任意pod看到自己的IP跟别人看见它所用的IP是一样的，中间不能经过地址转换；</p><p>也就是说，必须同时满足以上三点的网络模型才能适用于kubernetes，事实上，在早期的Kubernetes中，并没有什么网络标准，只是提出了以上基本要求，只有满足这些要求的网络才可以部署Kubernetes，基于这样的底层网络假设，Kubernetes设计了<code>pod-deployment-service</code>的经典三层服务访问机制。直到1.1发布，Kubernetes才开始采用全新的<a href="https://github.com/containernetworking/cni">CNI(Container Network Interface)</a>网络标准。</p><h2 id="cni">CNI</h2><p>其实，我们在前面介绍容器网络的时候，就提到了CNI网络规范，CNI相对于<a href="https://github.com/docker/libnetwork/blob/master/docs/design.md">CNM(Container Network Model)</a>对开发者的约束更少，更开放，不依赖于Docker。事实上，CNI规范确实非常简单，详见：<a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">https://github.com/containernetworking/cni/blob/master/SPEC.md</a></p><p><img src="https://i.loli.net/2020/02/04/Iz3AwFR6lPdbcmp.jpg" alt="networking-cni.jpg"></p><p>实现一个CNI网络插件只需要<strong>一个配置文件</strong>和<strong>一个可执行的文件</strong>： - 配置文件描述插件的版本、名称、描述等基本信息 - 可执行文件会被上层的容器管理平台调用，一个CNI可执行文件自需要实现将容器加入到网络的ADD操作以及将容器从网络中删除的DEL操作（以及一个可选的VERSION查看版本操作）</p><p>调用CNI网络插件的数据通过两种方式传递： - 环境变量 - 标准输入</p><p>kubernetes使用了CNI网络插件的工作流程： 1. kubelet先创建pause容器生成对应的netns网络命名空间 2. 网络driver根据配置调用具体的CNI插件，可以配置成CNI插件链来进行链式调用 3. 当一个CNI插件被调用时，它根据环境变量以及1个命令行参数来获得需要执行的操作、目标网络netns、容器的网络设备必要信息，然后执行ADD操作 3. CNI插件给pause容器配置正确的网络，pod中其他的容器都是用pause容器的网络</p><p>那么，什么是pause容器，它在pod中处于什么样的位置呢？这就涉及到单个pod的基本网络模型。</p><h2 id="pod的网络模型">pod的网络模型</h2><p>pod作为容器的一种扩展技术</p></div></div></div></article><script src="https://morven.life/js/highlight.pack.js"></script><script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@10.19.0/dist/lazyload.min.js"></script><script>var lazyImage = new LazyLoad({
    container: document.getElementById('article')
  });</script><script>hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });</script></body></html>