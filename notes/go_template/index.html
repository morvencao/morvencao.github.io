<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hugo 0.54.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Morven&#39;s Life"><meta property="og:url" content="https://morven.life/notes/go_template/"><link rel="canonical" href="https://morven.life/notes/go_template/"><link rel="shortcut icon" href="https://morven.life/favicon.ico" type="image/x-png"><script type="application/ld+json">{
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https://morven.life/"
      },
      "articleSection" : "notes",
      "name" : "深入理解GoTemplate",
      "headline" : "深入理解GoTemplate",
      "description" : "虽然近几年Restful架构的盛行推动前后端分离大行其道，模板渲染的地方由后端转移到了前端，类似于JSP和PHP的传统技术没多少人在用了。但是在Go语言中，模板技术不只局限于服务端HTML页面的渲染，可以实现文本化的输出，对于某些云计算的场景十分友好。今天，我们就来详细聊一聊Go Template的技术细节。
运行机制 模板的渲染技术本质上都是一样的，一句话来说明就是字串模板和结构化数据的结合。再详细的讲就是将定义好的模板应用于结构化的数据，使用注解语法引用数据结构中的元素（例如Struct中的特定feild，Map中的key）并显示它们的值。模板在执行过程中遍历数据结构并且设置当前光标（&quot;.&quot;表示当前的作用域）标识当前位置的元素。
类似于Python的jinja，Node的jade等模版引擎，Go语言模板引擎的运行机制也是类似：
 创建模板对象 解析模板字串 加载数据渲染模板  Warning Up Go提供了两个标准库用来处理模板text/template和html/template，它们的接口基本一样，其中text/template用来处理普通文本的模板渲染，而html/template专门用来格式化html字符串。
下面的例子我们使用text/template来处理普通文本模板的渲染：
package main import ( &quot;os&quot; &quot;text/template&quot; ) type Student struct { ID uint Name string } func main() { stu := Student{0, &quot;jason&quot;} tmpl, err := template.New(&quot;test&quot;).Parse(&quot;The name for student {{.ID}} is {{.Name}}&quot;) if err != nil { panic(err) } err = tmpl.Execute(os.Stdout, stu) if err != nil { panic(err) } }  上述代码第4行引入text/template来处理普通文本模板渲染，第14行定义一个模板对象test来解析变量&quot;The name for student {{.",
      "inLanguage" : "en-US",
      "author" : "Morven&#39;s Life",
      "creator" : "Morven&#39;s Life",
      "publisher": "Morven&#39;s Life",
      "accountablePerson" : "Morven&#39;s Life",
      "copyrightHolder" : "Morven&#39;s Life",
      "copyrightYear" : "2018",
      "datePublished": "2018-08-24 00:00:00 &#43;0000 UTC",
      "dateModified" : "2018-08-24 00:00:00 &#43;0000 UTC",
      "url" : "https://morven.life/notes/go_template/",
      "keywords" : [  ]
  }</script><title>深入理解GoTemplate - Morven&#39;s Life</title><meta property="og:title" content="深入理解GoTemplate - Morven&#39;s Life"><meta property="og:type" content="article"><meta name="description" content="虽然近几年Restful架构的盛行推动前后端分离大行其道，模板渲染的地方由后端转移到了前端，类似于JSP和PHP的传统技术没多少人在用了。但是在Go语言中，模板技术不只局限于服务端HTML页面的渲染，可以实现文本化的输出，对于某些云计算的场景十分友好。今天，我们就来详细聊一聊Go Template的技术细节。
运行机制 模板的渲染技术本质上都是一样的，一句话来说明就是字串模板和结构化数据的结合。再详细的讲就是将定义好的模板应用于结构化的数据，使用注解语法引用数据结构中的元素（例如Struct中的特定feild，Map中的key）并显示它们的值。模板在执行过程中遍历数据结构并且设置当前光标（&quot;.&quot;表示当前的作用域）标识当前位置的元素。
类似于Python的jinja，Node的jade等模版引擎，Go语言模板引擎的运行机制也是类似：
 创建模板对象 解析模板字串 加载数据渲染模板  Warning Up Go提供了两个标准库用来处理模板text/template和html/template，它们的接口基本一样，其中text/template用来处理普通文本的模板渲染，而html/template专门用来格式化html字符串。
下面的例子我们使用text/template来处理普通文本模板的渲染：
package main import ( &quot;os&quot; &quot;text/template&quot; ) type Student struct { ID uint Name string } func main() { stu := Student{0, &quot;jason&quot;} tmpl, err := template.New(&quot;test&quot;).Parse(&quot;The name for student {{.ID}} is {{.Name}}&quot;) if err != nil { panic(err) } err = tmpl.Execute(os.Stdout, stu) if err != nil { panic(err) } }  上述代码第4行引入text/template来处理普通文本模板渲染，第14行定义一个模板对象test来解析变量&quot;The name for student {{."><link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css"><link rel="stylesheet" href="https://morven.life/css/index.css"><link href="https://morven.life/index.xml" rel="alternate" type="application/rss+xml" title="Morven&#39;s Life"><script>(function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});</script></head><body><article class="post Chinese" id="article"><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href="https://morven.life/"><div class="head-line"></div></a><header class="post-header"><h1 class="post-title">深入理解GoTemplate</h1><div class="row"><div class="col-xs-6"><time class="post-date" datetime="2018-08-24 00:00:00 UTC">24 Aug 2018</time></div><div class="col-xs-6"><div class="post-author"><a target="_blank" href="https://morven.life/">@Morven&#39;s Life</a></div></div></div></header><div class="post-content markdown-body"><p>虽然近几年Restful架构的盛行推动前后端分离大行其道，模板渲染的地方由后端转移到了前端，类似于JSP和PHP的传统技术没多少人在用了。但是在Go语言中，模板技术不只局限于服务端HTML页面的渲染，可以实现文本化的输出，对于某些云计算的场景十分友好。今天，我们就来详细聊一聊Go Template的技术细节。</p><h2 id="运行机制">运行机制</h2><p>模板的渲染技术本质上都是一样的，一句话来说明就是<strong>字串模板和结构化数据的结合</strong>。再详细的讲就是将定义好的模板应用于结构化的数据，使用注解语法引用数据结构中的元素（例如Struct中的特定feild，Map中的key）并显示它们的值。模板在执行过程中遍历数据结构并且设置当前光标（<code>&quot;.&quot;</code>表示当前的作用域）标识当前位置的元素。</p><p>类似于Python的<a href="http://jinja.pocoo.org/">jinja</a>，Node的<a href="http://jade-lang.com/">jade</a>等模版引擎，Go语言模板引擎的运行机制也是类似：</p><ol><li>创建模板对象</li><li>解析模板字串</li><li>加载数据渲染模板</li></ol><p><img src="https://i.loli.net/2019/03/31/5ca036206c6f3.jpg" alt=""></p><h2 id="warning-up">Warning Up</h2><p>Go提供了两个标准库用来处理模板<code>text/template</code>和<code>html/template</code>，它们的接口基本一样，其中<code>text/template</code>用来处理普通文本的模板渲染，而<code>html/template</code>专门用来格式化<code>html</code>字符串。</p><p>下面的例子我们使用<code>text/template</code>来处理普通文本模板的渲染：</p><pre><code>package main

import (
	&quot;os&quot;
        &quot;text/template&quot;
)

type Student struct {
    ID      uint
    Name    string
}

func main() {
    stu := Student{0, &quot;jason&quot;}
    tmpl, err := template.New(&quot;test&quot;).Parse(&quot;The name for student {{.ID}} is {{.Name}}&quot;)
    if err != nil { panic(err) }
    err = tmpl.Execute(os.Stdout, stu)
    if err != nil { panic(err) }
}
</code></pre><p>上述代码第4行引入<code>text/template</code>来处理普通文本模板渲染，第14行定义一个模板对象<code>test</code>来解析变量<code>&quot;The name for student {{.ID}} is {{.Name}}&quot;</code>模板字符串，第16行使用定义好的结构化数据来渲染模版到标准输出。</p><blockquote><p>Note: 要引用的模板数据一定是export出来的，也就是说对应的字段必须以大写字母开头，比如例子中的<code>ID</code>, <code>Name</code>。</p></blockquote><p>我们再来看一个HTML字符串默板渲染的例子：</p><pre><code>func templateHandler(w http.ResponseWriter, r *http.Request){
    tmpl := `&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Go Template Demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        {{ . }}
    &lt;/body&gt;
&lt;/html&gt;`
    
    t := template.New(&quot;hello.html&quot;)
    t, _ = t.Parse(tmpl)
    t.Execute(w, &quot;Hello, Go Template!&quot;)
}
</code></pre><blockquote><p>Note: 在Go语言中不倾向于使用单引号来表示字符串，请根据需要使用双引号或反引号。另外，Go语言的字符串类型在本质上就与其他语言的字符串类型不同。Java的<code>String</code>、C++的<code>std::string</code>以及python3的<code>str</code>类型都只是<strong>定宽字符序列</strong>，而Go语言的字符串是一个用<code>UTF-8</code>编码的<strong>变宽字符序列</strong>，也就是说，它的每一个字符都用一个或多个字节表示。 Go语言中的字符串字面量使用双引号或反引号(&rdquo;`&ldquo;)来创建： - 双引号用来创建可解析的字符串字面量 (支持转义，但不能用来引用多行)； - 反引号用来创建原生(raw)字符串字面量，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。</p></blockquote><p>本地部署执行：</p><pre><code>curl -i http://127.0.0.1:8080/
HTTP/1.1 200 OK
Date: Fri, 09 Dec 2016 09:04:36 GMT
Content-Length: 223
Content-Type: text/html; charset=utf-8

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Go Template Demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello, Go Template!
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>go不仅可以直接解析模板字串，也可以使用<a href="https://golang.org/pkg/html/template/#ParseFiles">ParseFile</a>解析模板文件，还是就是标准的处理流程：<strong>创建-加载-渲染</strong>。</p><h2 id="模板命名">模板命名</h2><p>之前的例子模板对象是有名字的，可以在创建模板对象的时候显示命名，也可以让Go Template自动命名。但是如果涉及到嵌套模板的时候，该如何命名模板呢，这种情况下，模板文件有好多个！</p><p>Go Template提供了<a href="https://golang.org/pkg/html/template/#Template.ExecuteTemplate">ExecuteTemplate方法</a>，用于执行指定名字的Go模板。比如加载<code>hello</code>模板的时候，可以指定layout.html</p><pre><code>tmplstr := `{{ define &quot;stu_info&quot; }}
The name for student {{.ID}} is {{.Name}}
{{ end }}
{{ define &quot;stu_name&quot; }}
Student name is {{.Name}}
{{ end }}
`
stu := Student{0, &quot;jason&quot;}
tmpl, err := template.New(&quot;test&quot;).Parse(tmplstr)
if err != nil { panic(err) }
err = tmpl.ExecuteTemplate(os.Stdout, &quot;stu_info&quot;, stu)
if err != nil { panic(err) }
}
</code></pre><p>在模板字符串中，使用了<code>define</code>这个action定义了两个命名模版<code>stu_info</code>，<code>stu_name</code>。这是虽然<code>Parse</code>方法返回的模板对象里面包含两个模板名， 但是<code>ExecuteTemplate</code>执行的模板还是<code>stu_info</code>。</p><p>不仅可以通过<code>define</code>定义模板，还可以通过<code>template</code>引入定义好的模板，类似jinja的<code>include</code>特性：</p><pre><code>tmplstr := `{{ define &quot;stu_name&quot; }}
Student name is {{.Name}}
{{ end }}
{{ define &quot;stu_info&quot; }}
{{ template &quot;stu_name&quot; . }}
{{ end }}
`
stu := Student{0, &quot;jason&quot;}
tmpl, err := template.New(&quot;test&quot;).Parse(tmplstr)
if err != nil { panic(err) }
err = tmpl.ExecuteTemplate(os.Stdout, &quot;stu_info&quot;, stu)
if err != nil { panic(err) }
}
</code></pre><p>上面的例子当中我们在<code>stu_into</code>模板中使用<code>template</code>引入了<code>stu_name</code>模板，同时传给<code>stu_name</code>模板当前作用域的数据(<code>.</code>)，第三个参数是可选的，如果为空，则表示传给嵌套模版的数据为<code>nil</code>。</p><p>总而言之，创建模板对象后和加载多个模板文件，执行模板文件的时候需要指定base模板（<code>stu_info</code>），在base模板中可以引入其他命名的模板。无论点<code>.</code>，<code>define</code>，<code>template</code>这些在双花括号的关键字其实都是Go Template的action（模板标签）。</p><h2 id="action">Action</h2><p>Go Template的action是用于动态执行一些逻辑和展示数据的形式，大致分为下面几类：</p><ul><li>条件语句</li><li>迭代</li><li>封装</li><li>引用</li></ul><p>我们在之前的例子中看到了<code>define</code>以及<code>template</code>的用法，下面再看看其他的action怎么使用：</p><h4 id="条件判断">条件判断</h4><p>条件判断的语法很简单：</p><pre><code>{{if pipeline}} T1 {{end}}
	If the value of the pipeline is empty, no output is generated;
	otherwise, T1 is executed. The empty values are false, 0, any
	nil pointer or interface value, and any array, slice, map, or
	string of length zero.
	Dot is unaffected.

{{if pipeline}} T1 {{else}} T0 {{end}}
	If the value of the pipeline is empty, T0 is executed;
	otherwise, T1 is executed. Dot is unaffected.

{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}
	To simplify the appearance of if-else chains, the else action
	of an if may include another if directly; the effect is exactly
	the same as writing
		{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}
</code></pre><h4 id="迭代">迭代</h4><p>对于一些数组，Slice或者是Map，可以使用迭代的action，与Go语言本身的迭代类似，使用<code>range</code>进行处理：</p><p>详细规范如下：</p><pre><code>{{range pipeline}} T1 {{end}}
	The value of the pipeline must be an array, slice, map, or channel.
	If the value of the pipeline has length zero, nothing is output;
	otherwise, dot is set to the successive elements of the array,
	slice, or map and T1 is executed. If the value is a map and the
	keys are of basic type with a defined order (&quot;comparable&quot;), the
	elements will be visited in sorted key order.

{{range pipeline}} T1 {{else}} T0 {{end}}
	The value of the pipeline must be an array, slice, map, or channel.
	If the value of the pipeline has length zero, dot is unaffected and
	T0 is executed; otherwise, dot is set to the successive elements
	of the array, slice, or map and T1 is executed.
</code></pre><pre><code>{{ range . }}
    &lt;li&gt;{{ . }}&lt;/li&gt;
{{ else }}
 empty
{{ end }}
</code></pre><p>当<code>range</code>的结构为空的时候，则会执行<code>else</code>分支的逻辑。</p><h4 id="with封装">with封装</h4><p><code>with</code>语言在Python中可以开启一个上下文环境。对于Go Template，<code>with</code>语句类似，其含义就是创建一个封闭的作用域，在其范围内，可以使用<code>.action</code>，而与外面的<code>.</code>无关，只与<code>with</code>的参数有关：</p><p>详细规范如下：</p><pre><code>{{with pipeline}} T1 {{end}}
	If the value of the pipeline is empty, no output is generated;
	otherwise, dot is set to the value of the pipeline and T1 is
	executed.

{{with pipeline}} T1 {{else}} T0 {{end}}
	If the value of the pipeline is empty, dot is unaffected and T0
	is executed; otherwise, dot is set to the value of the pipeline
	and T1 is executed.
</code></pre><p>举个例子：</p><pre><code>{{ with arg }}
    .
{{ end }}
</code></pre><p>在上面<code>with</code>里面的<code>.</code>代表with新开辟的作用域，而不是with外面的作用域。<code>with</code>语句的<code>.</code>与其外面的<code>.</code>是两个不相关的对象。<code>with</code>语句也可以有<code>else</code>。<code>else</code>中的<code>.</code>则和<code>with</code>外面的<code>.</code>一样，毕竟只有with语句内才有封闭的上下文：</p><pre><code>{{ with &quot;&quot;}}
 Now the dot is set to {{ . }}
{{ else }}
 {{ . }}
{{ end }}
</code></pre><h4 id="参数和管道">参数和管道</h4><p>前面我们提到过<code>template</code> action可以有可选的参数来传递给内部嵌套模版。实际上，引用除了模板的include，还包括参数的传递。</p><p>模板的参数可以是Go中的基本数据类型，如数字，布尔值，字符串，数组切片或者一个结构体。在模板中设置变量可以使用：</p><pre><code>$variable := value
</code></pre><p>Go还有一个特性就是模板的管道函数，熟悉django和jinja的开发者应该很熟悉这种手法。通过定义函数过滤器，实现模板的一些简单格式化处理。并且通过管道哲学，这样的处理方式可以连成一起。</p><p>例如，模板内置了一些函数，比如格式化输出：</p><pre><code>{{ 3.1415926 | printf &quot;%.3f&quot; }}
</code></pre><h4 id="函数">函数</h4><p>既然管道符可以成为模板中的过滤器，那么除了内建的函数，Go Template还支持自定义函数可以扩展模板的功能：</p><p>在Go Template中定义一个函数分两步：</p><ol><li>创建一个<code>FuncMap</code>类型的map，key是模板函数的名字，value是其函数的定义</li><li>将<code>FuncMap</code>注入到模板中</li></ol><pre><code>funcMap := template.FuncMap{&quot;fdate&quot;: formDate}
tmpl := template.New(&quot;test&quot;).Funcs(funcMap)
tmpl = template.Must(t.Parse(`test data: {{.}}`))
tmpl.ExecuteTemplate(os.Stdout, &quot;test&quot;, time.Now())
</code></pre><p>在模板中可以使用<code>{{ . | fdate }}</code>，当然也可以不用管道过滤器，而是使用正常的函数调用形式<code>{{ fdate . }}</code>。</p><h2 id="summary">Summary</h2><p>Go Template经常用来处理譬如插入特定数据的文本转化等，虽然没有正则表达式那么灵活，但是渲染速度超过正则表达式，而且使用起来也更简单。</p></div></div></div></article><script src="https://morven.life/js/highlight.pack.js"></script><script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@10.19.0/dist/lazyload.min.js"></script><script>var lazyImage = new LazyLoad({
    container: document.getElementById('article')
  });</script><script>hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });</script></body></html>