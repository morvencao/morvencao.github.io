<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.119.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Morven's Life"><meta property="og:url" content="https://morven.life/posts/git-like-os-fs/"><link rel=canonical href=https://morven.life/posts/git-like-os-fs/><link rel=apple-touch-icon href=https://morven.life/favicon.ico><link rel=icon href=https://morven.life/favicon.ico><link rel=shortcut href=https://morven.life/favicon.ico><link rel=alternate type=application/atom+xml href=https://morven.life/index.xml title="Morven's Life"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/morven.life\/"},"articleSection":"posts","name":"类Git的Linux操作系统","headline":"类Git的Linux操作系统","description":"Linux从诞生之初就简洁灵活，它严格继承了Unix的KISS（Keep It Simple, Stupid）设计哲学，但是随着新的计算场景的出现，有些问题也逐渐显现出来，比如：操作系统生命周期的管理。\n实际上，围绕这个问题开发者已经做了各种尝试，包括但不只限于各种类型的包管理软件，漏洞自动修复工具等等。但是，我们有没有更好的办法呢？答案是肯定的，那就是类Git的操作系统。想象一下，管理操作系统的生命周期就像管理Git仓库一样，我们可以随时切换到任何一个版本，或者创建一个新的分支，然后合并到主分支，或者回滚到任何一个版本，这样的话，我们就可以随时随地的管理操作系统的生命周期了。\n为什么要重新造轮子 我们常说“less is more”, 如果你的智能手机提供了GPS地图应用程序，你可能就不会购买物理GPS导航器。如果你的Linux系统可以提供有效且易于使用的开箱即用功能，为什么还需要配置和维护额外的工具呢？\n仔细想想那些声称支持操作系统回滚、增量更新、一致性或变更历史跟踪的解决方案的复杂性（以及成本）。如果我只需使用操作系统的功能就能实现这些，那不是太好了吗？当然，前提是开箱即用的功能至少与额外工具提供的功能一样出色。我们接下来将看看这种新的操作系统生命周期管理方法是如何将这变为可能。\n这个新的轮子叫做libostree，当然很多人也习惯称之为OSTree。OSTree的模型类似于Git，因为它对文件进行了校验和，并具有一个内容寻址的对象存储。但与Git不同的是，它通过硬链接来“checkout”文件，因此需要使它们不可变以防止损坏。\n在开始深入研究OSTree之前，我们先来看看一些相关的基础知识。\nchroot 监狱 在多年前，一些Linux的开发者觉得在开发操作系统的核心功能是如履薄冰，他们想要一种安全的方式来进行开发，以防止“破坏”环境。他们最终开发了一种可以在同一系统中快速创建操作系统的新“实例”的方式，这使得他们可以“安全地破坏”环境，因为就像拥有时光机器一样，你随时可以回退到破坏前的环境。它还有一些附加的好处，比如在多个“版本”之间共享数据、使用系统安装的应用程序、特定硬件的使用等等。\n也许你会说，这种超能力完全可以使用虚拟化、容器等技术来实现，但问题是虚拟机和容器创建过程较慢，并且共享系统数据、应用程序和硬件也有些困难。此外，更重要的是，回滚能力是不可用的。因此，开发者们决定使用chroot来实现这种超能力。\n“chroot”是在Unix早期引入的一项操作，它改变了系统使用的“根目录”，从而可以为运行在其中的应用程序创建一个“监狱”环境。它用于为进程创建沙盒，以防止它们恶意更改chroot目录外的数据，或者作为虚拟机的轻量级替代品。这听起来和容器技术有点相似，容器技术使用“namespace”来获取额外的隔离，但是chroot同样也可以实现类似的隔离而且更快。\n回到操作系统的生命周期管理问题，核心的想法是使从不同的chroot目录引导成为可能，这样开发者可以在一个chroot监狱环境上开发新功能，能够访问一些共享数据以及其他应用程序，如果新环境出现“破坏”问题，只需返回到“原始”的chroot监狱，而不会受到“破坏”的影响。\n但仅仅使用chroot是不够的，因为为了提供这些功能，你需要让它与其他不同的引导加载程序组件（如GRUB、内核初始化文件、文件系统挂载等）协同工作，不仅如此，还需要考虑如何执行诸如平台更新之类的操作，这就是 libostree 的核心功能。\n类Git的可引导文件系统 先来看看libostree的官方定义：\nLibostree is both a shared library and suite of command line tools that combines a “git-like” model for committing and downloading bootable filesystem trees, along with a layer for deploying them and managing the bootloader configuration.\n换句话说，libostree是用于维护基于多个chroot监狱环境的完整可引导操作系统生命周期的组件，它遵循“类似于Git的模型”，这意味着libostree采用了类似Git版本控制系统的工作模式。与Git一样，libostree也使用校验和来管理文件，将操作系统的不同版本存储为一组不可变的对象，这些对象可以像源代码一样进行版本控制和回滚。这使得libostree能够轻松地管理不同版本的操作系统，并实现类似Git的分支、合并和回滚操作，从而为操作系统的生命周期管理提供了强大的工具。\n但是，也许你也发现了其中的问题，我们一直在谈论使用chroot来创建可以引导的不同“版本”的根文件系统。这些版本可能会有许多相同的文件。将相同的文件复制到每个“chroot监狱”中将占用大量空间，因此必须有另一种方式，可以在不复制或共享文件的情况下将相同的文件放在不同的根文件夹中，并同时跟踪版本更改。\n或许我们只知道使用Git，对其中的实现细节知之甚少，但我们多少会对象存储的概念和在扁平数据环境中如何使用哈希字符串存储的非结构化数据有一些了解，就像key-value存储一样，将哈希与文件元数据以及最终的实际数据位绑定。\nGit以类似的方式工作，它是一个由哈希标识的对象组成的数据库，使用键值数据存储概念进行存储。它具有四种不同类型的对象，用于标识文件的内容（blob）、目录结构（tree）、版本信息（commit）以及标签（tag）。\n尽管“blobs”和“trees”足以表示完整的文件系统，但“commits”包含对描述存储库根目录的“tree”对象的引用，从而提供了完整的版本控制系统。如果两个不同的版本之间的位没有发生更改，那么它们可以指向相同的“blob”，这样就无需在它们之间复制这些位。\nlibostree不仅仅是Git，它借用了Git的概念，并以非常相似的方式应用这些概念，但具体实现并不完全相同。Git被设计为源代码仓库版本控制系统，这意味着它的功能侧重于“文本文件”。相比之下，我们需要的主要是对“文本文件”和“二进制文件”的混合版本控制，因此功能必须对两者进行优化，而不仅仅是文本。\n“有效地”复制文件系统 既然我们已经理解了chroot是创建“监狱式”根文件系统环境的合适技术，并且我们希望拥有类似Git的版本控制系统，那么我们需要将它们联系在一起的Linux功能，这就是文件的“硬链接”。\n在Linux中有两种类型的文件链接：软链接和硬链接。软链接（符号链接）是一种指向另一个常规文件的特殊文件（该文件指向数据），而硬链接是不同的文件名直接指向相同的数据和属性（inode）。这两种不同类型的链接有一个关键区别，使得硬链接更适合我们类似Git的版本控制用例。使用硬链接，如果你删除“目标”文件，你仍然可以访问数据，而使用软链接，如果你删除目标文件，符号链接将停止工作并变得无用。我们需要在同一磁盘分区上拥有多个“文件副本”，并且这些副本必须是独立的，因此当你删除一个文件时，你不希望“自动删除”其他“副本”。\n在此，我们知道libostree使用硬链接来“checkout”文件，这意味着它可以在不复制文件的情况下创建多个文件系统版本，这是非常有效的。但是，使用硬链接也带来一个额外的问题。试想一下，你的系统中有两个操作系统的“快照”（让我们从现在开始称它们为“部署”）：部署A和部署B，它们是相同的。当在版本B上运行时，你更改了一个二进制版本，但在更改之后，你意识到出现了问题，于是回到了版本A，但问题是，你在部署B中做出的相同更改导致了系统崩溃，而这些更改也应用于部署A，因此你无法摆脱更改带来的问题。","inLanguage":"en-US","author":"Morven\u0027s Life","creator":"Morven\u0027s Life","publisher":"Morven\u0027s Life","accountablePerson":"Morven\u0027s Life","copyrightHolder":"Morven\u0027s Life","copyrightYear":"2023","datePublished":"2023-08-14 00:00:00 \u002b0000 UTC","dateModified":"2023-08-14 00:00:00 \u002b0000 UTC","url":"https:\/\/morven.life\/posts\/git-like-os-fs\/","keywords":[]}</script><title>类Git的Linux操作系统</title><meta property="og:title" content="类Git的Linux操作系统"><meta property="og:type" content="article"><meta property="og:description" content="Linux从诞生之初就简洁灵活，它严格继承了Unix的KISS（Keep It Simple, Stupid）设计哲学，但是随着新的计算场景的出现，有些问题也逐渐显现出来，比如：操作系统生命周期的管理。
实际上，围绕这个问题开发者已经做了各种尝试，包括但不只限于各种类型的包管理软件，漏洞自动修复工具等等。但是，我们有没有更好的办法呢？答案是肯定的，那就是类Git的操作系统。想象一下，管理操作系统的生命周期就像管理Git仓库一样，我们可以随时切换到任何一个版本，或者创建一个新的分支，然后合并到主分支，或者回滚到任何一个版本，这样的话，我们就可以随时随地的管理操作系统的生命周期了。
为什么要重新造轮子 我们常说“less is more”, 如果你的智能手机提供了GPS地图应用程序，你可能就不会购买物理GPS导航器。如果你的Linux系统可以提供有效且易于使用的开箱即用功能，为什么还需要配置和维护额外的工具呢？
仔细想想那些声称支持操作系统回滚、增量更新、一致性或变更历史跟踪的解决方案的复杂性（以及成本）。如果我只需使用操作系统的功能就能实现这些，那不是太好了吗？当然，前提是开箱即用的功能至少与额外工具提供的功能一样出色。我们接下来将看看这种新的操作系统生命周期管理方法是如何将这变为可能。
这个新的轮子叫做libostree，当然很多人也习惯称之为OSTree。OSTree的模型类似于Git，因为它对文件进行了校验和，并具有一个内容寻址的对象存储。但与Git不同的是，它通过硬链接来“checkout”文件，因此需要使它们不可变以防止损坏。
在开始深入研究OSTree之前，我们先来看看一些相关的基础知识。
chroot 监狱 在多年前，一些Linux的开发者觉得在开发操作系统的核心功能是如履薄冰，他们想要一种安全的方式来进行开发，以防止“破坏”环境。他们最终开发了一种可以在同一系统中快速创建操作系统的新“实例”的方式，这使得他们可以“安全地破坏”环境，因为就像拥有时光机器一样，你随时可以回退到破坏前的环境。它还有一些附加的好处，比如在多个“版本”之间共享数据、使用系统安装的应用程序、特定硬件的使用等等。
也许你会说，这种超能力完全可以使用虚拟化、容器等技术来实现，但问题是虚拟机和容器创建过程较慢，并且共享系统数据、应用程序和硬件也有些困难。此外，更重要的是，回滚能力是不可用的。因此，开发者们决定使用chroot来实现这种超能力。
“chroot”是在Unix早期引入的一项操作，它改变了系统使用的“根目录”，从而可以为运行在其中的应用程序创建一个“监狱”环境。它用于为进程创建沙盒，以防止它们恶意更改chroot目录外的数据，或者作为虚拟机的轻量级替代品。这听起来和容器技术有点相似，容器技术使用“namespace”来获取额外的隔离，但是chroot同样也可以实现类似的隔离而且更快。
回到操作系统的生命周期管理问题，核心的想法是使从不同的chroot目录引导成为可能，这样开发者可以在一个chroot监狱环境上开发新功能，能够访问一些共享数据以及其他应用程序，如果新环境出现“破坏”问题，只需返回到“原始”的chroot监狱，而不会受到“破坏”的影响。
但仅仅使用chroot是不够的，因为为了提供这些功能，你需要让它与其他不同的引导加载程序组件（如GRUB、内核初始化文件、文件系统挂载等）协同工作，不仅如此，还需要考虑如何执行诸如平台更新之类的操作，这就是 libostree 的核心功能。
类Git的可引导文件系统 先来看看libostree的官方定义：
Libostree is both a shared library and suite of command line tools that combines a “git-like” model for committing and downloading bootable filesystem trees, along with a layer for deploying them and managing the bootloader configuration.
换句话说，libostree是用于维护基于多个chroot监狱环境的完整可引导操作系统生命周期的组件，它遵循“类似于Git的模型”，这意味着libostree采用了类似Git版本控制系统的工作模式。与Git一样，libostree也使用校验和来管理文件，将操作系统的不同版本存储为一组不可变的对象，这些对象可以像源代码一样进行版本控制和回滚。这使得libostree能够轻松地管理不同版本的操作系统，并实现类似Git的分支、合并和回滚操作，从而为操作系统的生命周期管理提供了强大的工具。
但是，也许你也发现了其中的问题，我们一直在谈论使用chroot来创建可以引导的不同“版本”的根文件系统。这些版本可能会有许多相同的文件。将相同的文件复制到每个“chroot监狱”中将占用大量空间，因此必须有另一种方式，可以在不复制或共享文件的情况下将相同的文件放在不同的根文件夹中，并同时跟踪版本更改。
或许我们只知道使用Git，对其中的实现细节知之甚少，但我们多少会对象存储的概念和在扁平数据环境中如何使用哈希字符串存储的非结构化数据有一些了解，就像key-value存储一样，将哈希与文件元数据以及最终的实际数据位绑定。
Git以类似的方式工作，它是一个由哈希标识的对象组成的数据库，使用键值数据存储概念进行存储。它具有四种不同类型的对象，用于标识文件的内容（blob）、目录结构（tree）、版本信息（commit）以及标签（tag）。
尽管“blobs”和“trees”足以表示完整的文件系统，但“commits”包含对描述存储库根目录的“tree”对象的引用，从而提供了完整的版本控制系统。如果两个不同的版本之间的位没有发生更改，那么它们可以指向相同的“blob”，这样就无需在它们之间复制这些位。
libostree不仅仅是Git，它借用了Git的概念，并以非常相似的方式应用这些概念，但具体实现并不完全相同。Git被设计为源代码仓库版本控制系统，这意味着它的功能侧重于“文本文件”。相比之下，我们需要的主要是对“文本文件”和“二进制文件”的混合版本控制，因此功能必须对两者进行优化，而不仅仅是文本。
“有效地”复制文件系统 既然我们已经理解了chroot是创建“监狱式”根文件系统环境的合适技术，并且我们希望拥有类似Git的版本控制系统，那么我们需要将它们联系在一起的Linux功能，这就是文件的“硬链接”。
在Linux中有两种类型的文件链接：软链接和硬链接。软链接（符号链接）是一种指向另一个常规文件的特殊文件（该文件指向数据），而硬链接是不同的文件名直接指向相同的数据和属性（inode）。这两种不同类型的链接有一个关键区别，使得硬链接更适合我们类似Git的版本控制用例。使用硬链接，如果你删除“目标”文件，你仍然可以访问数据，而使用软链接，如果你删除目标文件，符号链接将停止工作并变得无用。我们需要在同一磁盘分区上拥有多个“文件副本”，并且这些副本必须是独立的，因此当你删除一个文件时，你不希望“自动删除”其他“副本”。
在此，我们知道libostree使用硬链接来“checkout”文件，这意味着它可以在不复制文件的情况下创建多个文件系统版本，这是非常有效的。但是，使用硬链接也带来一个额外的问题。试想一下，你的系统中有两个操作系统的“快照”（让我们从现在开始称它们为“部署”）：部署A和部署B，它们是相同的。当在版本B上运行时，你更改了一个二进制版本，但在更改之后，你意识到出现了问题，于是回到了版本A，但问题是，你在部署B中做出的相同更改导致了系统崩溃，而这些更改也应用于部署A，因此你无法摆脱更改带来的问题。"><meta name=description content="Linux从诞生之初就简洁灵活，它严格继承了Unix的KISS（Keep It Simple, Stupid）设计哲学，但是随着新的计算场景的出现，有些问题也逐渐显现出来，比如：操作系统生命周期的管理。
实际上，围绕这个问题开发者已经做了各种尝试，包括但不只限于各种类型的包管理软件，漏洞自动修复工具等等。但是，我们有没有更好的办法呢？答案是肯定的，那就是类Git的操作系统。想象一下，管理操作系统的生命周期就像管理Git仓库一样，我们可以随时切换到任何一个版本，或者创建一个新的分支，然后合并到主分支，或者回滚到任何一个版本，这样的话，我们就可以随时随地的管理操作系统的生命周期了。
为什么要重新造轮子 我们常说“less is more”, 如果你的智能手机提供了GPS地图应用程序，你可能就不会购买物理GPS导航器。如果你的Linux系统可以提供有效且易于使用的开箱即用功能，为什么还需要配置和维护额外的工具呢？
仔细想想那些声称支持操作系统回滚、增量更新、一致性或变更历史跟踪的解决方案的复杂性（以及成本）。如果我只需使用操作系统的功能就能实现这些，那不是太好了吗？当然，前提是开箱即用的功能至少与额外工具提供的功能一样出色。我们接下来将看看这种新的操作系统生命周期管理方法是如何将这变为可能。
这个新的轮子叫做libostree，当然很多人也习惯称之为OSTree。OSTree的模型类似于Git，因为它对文件进行了校验和，并具有一个内容寻址的对象存储。但与Git不同的是，它通过硬链接来“checkout”文件，因此需要使它们不可变以防止损坏。
在开始深入研究OSTree之前，我们先来看看一些相关的基础知识。
chroot 监狱 在多年前，一些Linux的开发者觉得在开发操作系统的核心功能是如履薄冰，他们想要一种安全的方式来进行开发，以防止“破坏”环境。他们最终开发了一种可以在同一系统中快速创建操作系统的新“实例”的方式，这使得他们可以“安全地破坏”环境，因为就像拥有时光机器一样，你随时可以回退到破坏前的环境。它还有一些附加的好处，比如在多个“版本”之间共享数据、使用系统安装的应用程序、特定硬件的使用等等。
也许你会说，这种超能力完全可以使用虚拟化、容器等技术来实现，但问题是虚拟机和容器创建过程较慢，并且共享系统数据、应用程序和硬件也有些困难。此外，更重要的是，回滚能力是不可用的。因此，开发者们决定使用chroot来实现这种超能力。
“chroot”是在Unix早期引入的一项操作，它改变了系统使用的“根目录”，从而可以为运行在其中的应用程序创建一个“监狱”环境。它用于为进程创建沙盒，以防止它们恶意更改chroot目录外的数据，或者作为虚拟机的轻量级替代品。这听起来和容器技术有点相似，容器技术使用“namespace”来获取额外的隔离，但是chroot同样也可以实现类似的隔离而且更快。
回到操作系统的生命周期管理问题，核心的想法是使从不同的chroot目录引导成为可能，这样开发者可以在一个chroot监狱环境上开发新功能，能够访问一些共享数据以及其他应用程序，如果新环境出现“破坏”问题，只需返回到“原始”的chroot监狱，而不会受到“破坏”的影响。
但仅仅使用chroot是不够的，因为为了提供这些功能，你需要让它与其他不同的引导加载程序组件（如GRUB、内核初始化文件、文件系统挂载等）协同工作，不仅如此，还需要考虑如何执行诸如平台更新之类的操作，这就是 libostree 的核心功能。
类Git的可引导文件系统 先来看看libostree的官方定义：
Libostree is both a shared library and suite of command line tools that combines a “git-like” model for committing and downloading bootable filesystem trees, along with a layer for deploying them and managing the bootloader configuration.
换句话说，libostree是用于维护基于多个chroot监狱环境的完整可引导操作系统生命周期的组件，它遵循“类似于Git的模型”，这意味着libostree采用了类似Git版本控制系统的工作模式。与Git一样，libostree也使用校验和来管理文件，将操作系统的不同版本存储为一组不可变的对象，这些对象可以像源代码一样进行版本控制和回滚。这使得libostree能够轻松地管理不同版本的操作系统，并实现类似Git的分支、合并和回滚操作，从而为操作系统的生命周期管理提供了强大的工具。
但是，也许你也发现了其中的问题，我们一直在谈论使用chroot来创建可以引导的不同“版本”的根文件系统。这些版本可能会有许多相同的文件。将相同的文件复制到每个“chroot监狱”中将占用大量空间，因此必须有另一种方式，可以在不复制或共享文件的情况下将相同的文件放在不同的根文件夹中，并同时跟踪版本更改。
或许我们只知道使用Git，对其中的实现细节知之甚少，但我们多少会对象存储的概念和在扁平数据环境中如何使用哈希字符串存储的非结构化数据有一些了解，就像key-value存储一样，将哈希与文件元数据以及最终的实际数据位绑定。
Git以类似的方式工作，它是一个由哈希标识的对象组成的数据库，使用键值数据存储概念进行存储。它具有四种不同类型的对象，用于标识文件的内容（blob）、目录结构（tree）、版本信息（commit）以及标签（tag）。
尽管“blobs”和“trees”足以表示完整的文件系统，但“commits”包含对描述存储库根目录的“tree”对象的引用，从而提供了完整的版本控制系统。如果两个不同的版本之间的位没有发生更改，那么它们可以指向相同的“blob”，这样就无需在它们之间复制这些位。
libostree不仅仅是Git，它借用了Git的概念，并以非常相似的方式应用这些概念，但具体实现并不完全相同。Git被设计为源代码仓库版本控制系统，这意味着它的功能侧重于“文本文件”。相比之下，我们需要的主要是对“文本文件”和“二进制文件”的混合版本控制，因此功能必须对两者进行优化，而不仅仅是文本。
“有效地”复制文件系统 既然我们已经理解了chroot是创建“监狱式”根文件系统环境的合适技术，并且我们希望拥有类似Git的版本控制系统，那么我们需要将它们联系在一起的Linux功能，这就是文件的“硬链接”。
在Linux中有两种类型的文件链接：软链接和硬链接。软链接（符号链接）是一种指向另一个常规文件的特殊文件（该文件指向数据），而硬链接是不同的文件名直接指向相同的数据和属性（inode）。这两种不同类型的链接有一个关键区别，使得硬链接更适合我们类似Git的版本控制用例。使用硬链接，如果你删除“目标”文件，你仍然可以访问数据，而使用软链接，如果你删除目标文件，符号链接将停止工作并变得无用。我们需要在同一磁盘分区上拥有多个“文件副本”，并且这些副本必须是独立的，因此当你删除一个文件时，你不希望“自动删除”其他“副本”。
在此，我们知道libostree使用硬链接来“checkout”文件，这意味着它可以在不复制文件的情况下创建多个文件系统版本，这是非常有效的。但是，使用硬链接也带来一个额外的问题。试想一下，你的系统中有两个操作系统的“快照”（让我们从现在开始称它们为“部署”）：部署A和部署B，它们是相同的。当在版本B上运行时，你更改了一个二进制版本，但在更改之后，你意识到出现了问题，于是回到了版本A，但问题是，你在部署B中做出的相同更改导致了系统崩溃，而这些更改也应用于部署A，因此你无法摆脱更改带来的问题。"><meta property="og:locale" content="cn"><style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body blockquote{background-color:#f8f8f8;border-left:2px solid;margin:40px;padding:10px 20px}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:85%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.signatures{font-family:permanent marker,Impact,Charcoal,sans-serif;font-size:3rem;margin-top:32px}.signatures a{text-decoration:none}.header-line{width:100%;height:3px;background-color:#000;margin:18px 0}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-date,.posts-title{font-size:1.2rem}.posts-line{margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px;margin-bottom:3px}.site-footer{margin-top:50px;margin-bottom:80px;display:flex;justify-content:flex-end;flex-wrap:wrap;padding:12px 0;border-width:3px;border-color:#000}.site-footer-item{margin-right:12px}@media screen and (max-width:600px){.site-header{display:none}.post-content{padding:0 12px}.post-content p{letter-spacing:.05em}}@media screen and (max-width:48em){.posts-category{display:none}}.post-content img{max-width:100%;display:block;margin-left:auto;margin-right:auto;margin-top:12px}.post-header{margin-bottom:50px}.post-title{font-size:2.5rem;font-weight:600}.post-category{display:inline;font-weight:900;margin:0 4px;padding:2px 5px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}</style><style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style><link href=https://morven.life/index.xml rel=alternate type=application/rss+xml title="Morven's Life"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class="post 简体中文" id=article><div class=row><div class=col-xs-12><header class=post-header><h1 class=post-title>类Git的Linux操作系统</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2023-08-14 00:00:00 UTC">14 Aug 2023</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://morven.life/>@Morven's Life</a></div></div></div></header><div class="post-content markdown-body"><p>Linux从诞生之初就简洁灵活，它严格继承了Unix的<a href=https://en.wikipedia.org/wiki/KISS_principle>KISS（Keep It Simple, Stupid）</a>设计哲学，但是随着新的计算场景的出现，有些问题也逐渐显现出来，比如：操作系统生命周期的管理。</p><p>实际上，围绕这个问题开发者已经做了各种尝试，包括但不只限于各种类型的包管理软件，漏洞自动修复工具等等。但是，我们有没有更好的办法呢？答案是肯定的，那就是类Git的操作系统。想象一下，管理操作系统的生命周期就像管理Git仓库一样，我们可以随时切换到任何一个版本，或者创建一个新的分支，然后合并到主分支，或者回滚到任何一个版本，这样的话，我们就可以随时随地的管理操作系统的生命周期了。</p><h2 id=为什么要重新造轮子>为什么要重新造轮子</h2><p>我们常说“less is more”, 如果你的智能手机提供了GPS地图应用程序，你可能就不会购买物理GPS导航器。如果你的Linux系统可以提供有效且易于使用的开箱即用功能，为什么还需要配置和维护额外的工具呢？</p><p>仔细想想那些声称支持操作系统回滚、增量更新、一致性或变更历史跟踪的解决方案的复杂性（以及成本）。如果我只需使用操作系统的功能就能实现这些，那不是太好了吗？当然，前提是开箱即用的功能至少与额外工具提供的功能一样出色。我们接下来将看看这种新的操作系统生命周期管理方法是如何将这变为可能。</p><p>这个新的轮子叫做<a href=https://ostreedev.github.io/ostree/>libostree</a>，当然很多人也习惯称之为OSTree。OSTree的模型类似于Git，因为它对文件进行了校验和，并具有一个内容寻址的对象存储。但与Git不同的是，它通过硬链接来“checkout”文件，因此需要使它们不可变以防止损坏。</p><p>在开始深入研究OSTree之前，我们先来看看一些相关的基础知识。</p><h2 id=chroot-监狱>chroot 监狱</h2><p>在多年前，一些Linux的开发者觉得在开发操作系统的核心功能是如履薄冰，他们想要一种安全的方式来进行开发，以防止“破坏”环境。他们最终开发了一种可以在同一系统中快速创建操作系统的新“实例”的方式，这使得他们可以“安全地破坏”环境，因为就像拥有时光机器一样，你随时可以回退到破坏前的环境。它还有一些附加的好处，比如在多个“版本”之间共享数据、使用系统安装的应用程序、特定硬件的使用等等。</p><p>也许你会说，这种超能力完全可以使用虚拟化、容器等技术来实现，但问题是虚拟机和容器创建过程较慢，并且共享系统数据、应用程序和硬件也有些困难。此外，更重要的是，回滚能力是不可用的。因此，开发者们决定使用chroot来实现这种超能力。</p><p>“chroot”是在Unix早期引入的一项操作，它改变了系统使用的“根目录”，从而可以为运行在其中的应用程序创建一个“监狱”环境。它用于为进程创建沙盒，以防止它们恶意更改chroot目录外的数据，或者作为虚拟机的轻量级替代品。这听起来和容器技术有点相似，容器技术使用“namespace”来获取额外的隔离，但是chroot同样也可以实现类似的隔离而且更快。</p><p>回到操作系统的生命周期管理问题，核心的想法是使从不同的chroot目录引导成为可能，这样开发者可以在一个chroot监狱环境上开发新功能，能够访问一些共享数据以及其他应用程序，如果新环境出现“破坏”问题，只需返回到“原始”的chroot监狱，而不会受到“破坏”的影响。</p><p><img src=https://miro.medium.com/v2/resize:fit:4800/format:webp/1*E5x-H71-MDNgxzNDsWuZFA.png alt=rhel-for-edge-chroot-directories.png></p><p>但仅仅使用chroot是不够的，因为为了提供这些功能，你需要让它与其他不同的引导加载程序组件（如GRUB、内核初始化文件、文件系统挂载等）协同工作，不仅如此，还需要考虑如何执行诸如平台更新之类的操作，这就是 libostree 的核心功能。</p><h2 id=类git的可引导文件系统>类Git的可引导文件系统</h2><p>先来看看libostree的官方定义：</p><blockquote><p>Libostree is both a shared library and suite of command line tools that combines a “git-like” model for committing and downloading bootable filesystem trees, along with a layer for deploying them and managing the bootloader configuration.</p></blockquote><p>换句话说，libostree是用于维护基于多个chroot监狱环境的完整可引导操作系统生命周期的组件，它遵循“类似于Git的模型”，这意味着libostree采用了类似Git版本控制系统的工作模式。与Git一样，libostree也使用校验和来管理文件，将操作系统的不同版本存储为一组不可变的对象，这些对象可以像源代码一样进行版本控制和回滚。这使得libostree能够轻松地管理不同版本的操作系统，并实现类似Git的分支、合并和回滚操作，从而为操作系统的生命周期管理提供了强大的工具。</p><p>但是，也许你也发现了其中的问题，我们一直在谈论使用chroot来创建可以引导的不同“版本”的根文件系统。这些版本可能会有许多相同的文件。将相同的文件复制到每个“chroot监狱”中将占用大量空间，因此必须有另一种方式，可以在不复制或共享文件的情况下将相同的文件放在不同的根文件夹中，并同时跟踪版本更改。</p><p>或许我们只知道使用Git，对其中的实现细节知之甚少，但我们多少会对象存储的概念和在扁平数据环境中如何使用哈希字符串存储的非结构化数据有一些了解，就像key-value存储一样，将哈希与文件元数据以及最终的实际数据位绑定。</p><p>Git以类似的方式工作，它是一个由哈希标识的对象组成的数据库，使用键值数据存储概念进行存储。它具有四种不同类型的对象，用于标识文件的内容（blob）、目录结构（tree）、版本信息（commit）以及标签（tag）。</p><p>尽管“blobs”和“trees”足以表示完整的文件系统，但“commits”包含对描述存储库根目录的“tree”对象的引用，从而提供了完整的版本控制系统。如果两个不同的版本之间的位没有发生更改，那么它们可以指向相同的“blob”，这样就无需在它们之间复制这些位。</p><p>libostree不仅仅是Git，它借用了Git的概念，并以非常相似的方式应用这些概念，但具体实现并不完全相同。Git被设计为源代码仓库版本控制系统，这意味着它的功能侧重于“文本文件”。相比之下，我们需要的主要是对“文本文件”和“二进制文件”的混合版本控制，因此功能必须对两者进行优化，而不仅仅是文本。</p><h2 id=有效地复制文件系统>“有效地”复制文件系统</h2><p>既然我们已经理解了chroot是创建“监狱式”根文件系统环境的合适技术，并且我们希望拥有类似Git的版本控制系统，那么我们需要将它们联系在一起的Linux功能，这就是文件的“硬链接”。</p><p>在Linux中有两种类型的文件链接：软链接和硬链接。软链接（符号链接）是一种指向另一个常规文件的特殊文件（该文件指向数据），而硬链接是不同的文件名直接指向相同的数据和属性（inode）。这两种不同类型的链接有一个关键区别，使得硬链接更适合我们类似Git的版本控制用例。使用硬链接，如果你删除“目标”文件，你仍然可以访问数据，而使用软链接，如果你删除目标文件，符号链接将停止工作并变得无用。我们需要在同一磁盘分区上拥有多个“文件副本”，并且这些副本必须是独立的，因此当你删除一个文件时，你不希望“自动删除”其他“副本”。</p><p>在此，我们知道libostree使用硬链接来“checkout”文件，这意味着它可以在不复制文件的情况下创建多个文件系统版本，这是非常有效的。但是，使用硬链接也带来一个额外的问题。试想一下，你的系统中有两个操作系统的“快照”（让我们从现在开始称它们为“部署”）：部署A和部署B，它们是相同的。当在版本B上运行时，你更改了一个二进制版本，但在更改之后，你意识到出现了问题，于是回到了版本A，但问题是，你在部署B中做出的相同更改导致了系统崩溃，而这些更改也应用于部署A，因此你无法摆脱更改带来的问题。</p><p>这也意味着文件必须是不可变的，因为如果文件是可变的，那么在一个版本中对文件的更改将会影响到其他版本。为了防止更改，操作系统是建立在一个只读文件系统之上的，因此它就像操作系统的根文件系统的“镜像快照”，但当然，libostree还需要提供一种对这些镜像进行有效更改的方法。</p><p>当你需要执行一项（或一组）更改时，会创建一个全新的根文件系统的副本（请记住这并不意味着需要双倍的磁盘空间，并且创建该副本非常快速），并且更改将在其中进行。你没有更改的文件将保持为硬链接，而修改后的版本将成为一个新的“常规”文件，或者像下面的示例中那样被删除。</p><p><img src=https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkV4F_EiM-0FvYnAzCzjkg.png alt=rhel-for-edge-deployment-changes></p><p>但是，只读的文件系统并不代表着完全不能更新。</p><p>假设你有多个应用程序二进制文件需要更新，你需要创建一个包含新版本二进制文件的chroot文件系统的新副本，但是，如何使用这个新副本呢？当你运行在一个部署环境中（记住，部署=文件系统版本/修订版），并创建一个具有更改的新chroot目录时，你仍然在运行源版本，并没有立即切换到新的部署环境，只是创建了一堆新的硬链接。如何使这些更改在“运行的操作系统”上生效呢？</p><p>使用libostree，在系统启动时，将通过位于文件系统特定位置的符号链接之一来选择可用的操作系统根“快照/镜像/部署”，因此，如果你想使用任何替代的根文件系统镜像（例如，具有新二进制文件的镜像），我们只需要更改默认的（0号）符号链接，开始指向这个新的文件系统“版本”。</p><p>这是如何包括在启动过程中的？在initramfs文件中，有一个新的内核参数指定软链接（指向部署chroot文件系统）。</p><p><img src=https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhdPdG9jqmZMe8rlfBUfFQ.png alt=rhel-for-edge-boot-pointer></p><p>关于使用文件系统快照（部署），是在启动时做出的决定，如果你想切换到新的部署，你需要重新启动系统以使更改生效。</p><p>这与“常规”基于包的Linux发行版不同，在这些发行版中（有时）你可以更新二进制文件而无需重新启动系统，但这种在启动时进行更改也确保了所有二进制文件和正在运行的进程的一致性，这是基于镜像的系统的一个巨大优点。还要记住，多亏了这种一致性，我们可以获得libostree操作系统最酷的功能之一：系统回滚。想象一下，我们选择了一个“新的文件系统版本”在下次重新启动时引导，但你完全可以选择以前的版本，因为我们使用了一致的文件系统镜像/快照，这只是将我们的符号链接指向的位置更改即可。</p><p>所有这些意味着你可以使用与Git源代码存储库相同的方法来跟踪根文件系统的版本，进行更改而不影响先前的部署，并像更改简单符号链接一样轻松切换版本。</p><p>好处不仅于此，我们之前提到过生成操作系统的新“镜像”以进行系统更新。我们可以考虑在将要更新的同一系统上生成这些镜像，因为我们一般不只有一个需要维护的系统，可能有数十甚至数千个（例如边缘计算用例）。在这种情况下，我们可以在一个中央站点上生成更新，将它们发布到HTTP服务器上（或通过USB物理传输），然后使系统自动更新，或者只是下载新的部署（操作系统“镜像”）并等待适当的时刻上线。</p><p><img src=https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNjnfYfOw09plubDPFbelA.png alt=rhel-for-edge-image-generating></p><p>这种方法极大地简化了大规模管理，同时允许将更改跟踪放在一个中央位置（何时、什么、由谁进行的更改）。此外，另一个好处是：当你安装软件包时，你只需在中央位置计算依赖关系，执行%post脚本，执行SELinux标签化，并下载依赖关系的存储库一次，而不是每个系统一次浪费完整的网络带宽和计算资源，因为你将在中央位置创建图像，并与所有其他系统共享该图像。</p><h2 id=那我们还需要包管理系统吗>那我们还需要包管理系统吗？</h2><p>你可能会想，如果libostree负责管理系统的更新，那就不需要任何软件包管理器（如APT、DNF等）了，对吗？实际上并不是这样，libostree不是一个软件包管理器，你可能仍然需要在系统中安装一个软件包管理器。软件包管理器是一种简化软件包的管理（安装、删除、更新或配置）的工具，这些软件包是包含预编译二进制文件和配置文件的存档文件，用于构建实际的软件应用程序。这些软件包旨在消除需要从源代码编译软件以安装到系统中的需要。Libostree只管理完整的可引导文件系统树，而不是单个文件，实际上，它根本不知道单个文件（它们是如何生成的，它们的来源等等），因此它需要一个单独的机制来安装附加的打包应用程序。如果你希望保持打包软件的简单性，而不是回到自己编译源代码的时代，那么你仍然需要一个软件包管理器。</p><p>但是你不能像之前那样直接使用软件包管理器，因为传统的包管理软件不会想到你的操作系统位于只读文件系统中。因此你需要一个“混合”软件包管理器，它知道如何处理libostree。例如，在RHEL for Edge和Fedora系统中，就有一个叫<a href=https://coreos.github.io/rpm-ostree/>rpm-ostree</a>混合软件包管理器，它将libostree更新与RPM软件包结合在一起，使用相同的<code>/etc/yum.repos</code>源，但将RPM软件包包含为libostree系统的一层。</p><p>那么，libostree和rpm之间的这种“组合”是如何实现的呢？DNF将软件包安装到由libostree创建的文件系统中（从原始部署复制而来），然后从包含所需rpm软件包的原始文件系统副本创建一个新镜像，该镜像将成为实际的“libostree部署的新版本”（与libostree一开始创建的中间镜像形成对比）。总的来说，具体的步骤如下：</p><ol><li>libostree检出文件系统的一个副本</li><li>DNF将软件包安装到该新文件系统副本中</li><li>libostree将该副本检入为新对象</li><li>libostree将该副本检出，成为新的文件系统</li><li>重新启动操作系统以获取新的系统文件</li></ol><h2 id=系统配置与用户数据>系统配置与用户数据</h2><p>我们一直在谈论将根操作系统文件系统挂载为只读，以防止在libostree控制之外更改文件硬链接，但任何操作系统都需要对配置文件或用户数据进行写访问，因此不能将所有操作系统目录都设置为只读。</p><p>实际上，默认情况下，libostree仅将<code>/usr</code>设置为只读，包含不应该修改的所有目录树（例如库、二进制文件等）和其他更多内容，例如，在<code>/usr/etc中</code>，你可以找到所有已更改的<code>/etc</code>文件，从而为你提供了包括“恢复系统到出厂配置”等功能。</p><p>关于必须具有读/写权限的目录，还有其他要考虑的因素。在“可写”操作系统文件中，存在创建两个子组的差异。有些文件附加/绑定到特定的操作系统部署，而其他文件将需要“独立”。例如，假设在部署“A”中，我们有一个版本为“1”的应用程序，它需要一个需要可写的配置文件（以便可以调整配置而无需创建新的镜像）。现在，我们将应用程序更新为版本“2”，因此创建了一个新的部署“B”，但在应用程序版本过渡期间，开发人员更改了配置文件选项（可能包括或删除参数，甚至更改配置文件格式），因此配置文件必须“专用”于各自的部署，以便应用程序可以为每个发布找到预期的配置文件。</p><p>总结一下，有些情况下，在创建新的部署时，需要将可写文件与只读文件系统一起复制，而另一些情况下，这些文件只是在它们之间共享（在创建新的部署时不会“复制/复制/版本化”）。对于需要与特定部署绑定的可写文件，默认情况下，libostree使用<code>/etc</code>，而对于独立的文件，它使用<code>/var</code>。</p><p>现在我们知道<code>/etc</code>用于托管绑定到特定部署的文件，而<code>/var</code>中的文件是独立的，我们可以轻松理解libostree创建新部署时这些目录发生的情况：<code>/etc</code>位置被复制，因此当执行<code>dnf install</code>（如果使用rpm-ostree）时，这可能会更改配置文件格式，它将修改与新部署关联的新副本，并保持旧的副本不变。与此同时，<code>/var</code>只是在它们之间共享，因此可以在两个部署中访问相同的文件。</p><p>![directories-transition-between-different-deployments][https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iowVb-fK_NEpWmiJVCImoQ.png]</p><p>每个libostree操作系统都可以决定将什么放在<code>/var</code>中，但将用户的主目录（一般是是<code>/home</code>）包括在其中是一个好主意，这样用户可以保留他们自己的数据。我们可以以RHEL for Edge中的目录分发为例，并将其与非libostree（“常规”）RHEL目录树进行比较（查看“new”标签以查看更改）：</p><p><img src=https://miro.medium.com/v2/resize:fit:1300/format:webp/1*Zu78tuQFW90rPPMkxrPcSg.png alt=rhel-for-edge-directory-tree></p><p>我们可以在这里看到<code>/usr</code>被挂载为只读。为了维护常见的Linux目录结构，在新位置（在<code>/usr</code>中）创建了多个链接，如<code>/lib</code>和<code>/sbin</code>。你还可以检查<code>/etc</code>和<code>/var</code>具有写访问权限，以及<code>/home</code>或<code>/root</code>是如何重定向到<code>/var</code>以及其他包含与OS部署“独立”无关的文件的目录。</p><p>其余的目录都是Linux发行版中可以找到的“特殊”位置，但你还可以找到一个新的<code>/sysroot</code>目录以及一个新的<code>/ostree</code>链接。正如我们所看到的，我们的根目录树实际上是一个chroot监狱，这意味着你的虚拟目录树实际上是“物理”托管在其他地方的（以及来自不同部署的其他根目录）。不同的chroot目录所在的“真实”位置是<code>/sysroot</code>，实际上，正如图片上看到的那样，它们位于<code>/sysroot/ostree</code>，这也是为什么每个部署chroot目录上的<code>/sysroot</code>目录为空的原因（因为它必须在系统之外的chroot监狱中“真正存在”）。</p><h2 id=tldr>TL/DR</h2><p>既然已经阅读到这里，那就再多聊一聊。我们介绍了一种通过“fork”操作系统来创建一种新的管理操作系统生命周期的方式，这个想法不同于虚拟化以及容器技术，它诞生于Git的概念模型，以一种管理源代码的方式我们可以轻松实现操作系统的分叉、回滚、跟踪更改等等。</p><p>一旦这个想法清晰起来，只需要选择适当的Linux主要技术和功能，以实现操作系统生命周期管理的Git概念。这里用到的主要技术是：chroot和文件硬链接:</p><ul><li>使用chroot来隔离不同的操作系统根文件系统</li><li>使用文件硬链接来避免不同操作系统根文件系统之间的文件重复（通过链接到只读文件系统来限制跨更改的影响）</li></ul><p>以这些组件作为基础，创建了一种新的操作系统更新生命周期的方法，新技术被称为libostree，也被称为OSTree。</p><p>Libostree是一种用于版本控制基于Linux的操作系统更新的新系统，它带来了几个好处：</p><ul><li>可以执行事务升级（可以通过HTTP逐步执行）</li><li>可以为操作系统执行回滚（包括在更新后如果某些内容不起作用则自动回滚）</li><li>可以集中生成操作系统镜像，这样可以在多个系统之间提供操作系统一致性，并且减少了安装软件包所需的计算资源和网络带宽（使用rpm-ostree）</li><li>可以准备多个操作系统部署（并行安装），随时可以启动</li><li>可以通过受Git源代码存储库启发的版本控制系统跟踪更改</li></ul></div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=https://morven.life/categories/note/>note</a></div><div class=post-category><a href=https://morven.life/categories/tech/>tech</a></div></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=https://morven.life/about/ target=_blank>About Me</a></div></div></div></div></article><script src=https://morven.life/js/lazyload.min.js></script>
<script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script><script></script></body></html>