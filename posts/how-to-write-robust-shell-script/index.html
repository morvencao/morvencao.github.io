<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Morven's Life"><meta property="og:url" content="https://morven.life/posts/how-to-write-robust-shell-script/"><link rel=canonical href=https://morven.life/posts/how-to-write-robust-shell-script/><link rel=apple-touch-icon href=https://morven.life/favicon.ico><link rel=icon href=https://morven.life/favicon.ico><link rel=shortcut href=https://morven.life/favicon.ico><link rel=alternate type=application/atom+xml href=https://morven.life/index.xml title="Morven's Life"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/morven.life\/"},"articleSection":"posts","name":"编写健壮的 Shell 脚本","headline":"编写健壮的 Shell 脚本","description":"编写 Shell 脚本应该是程序员必须掌握的技能。因为 Shell 脚本简单易上手的特性，在日常工作中，我们经常使用它来自动化应用的测试部署、环境的搭建清理等。其实在编写运行 Shell 脚本的时候也会遇到各种坑，稍不注意就会导致 Shell 脚本因为各种原因不能正常执行。实际上，编写健壮可靠的 Shell 脚本也是有很多技巧的，今天我们就来探讨一下。\n设置 Shell 的默认执行环境参数 在执行 Shell 脚本的时候，通常都会创建一个新的 Shell ，比如，当我们执行：\nbash script.sh 我们指明使用 bash 会创建一个新的 Shell 来执行 script.sh ，同时给定了这个执行环境默认的各种参数。 set 命令可以用来修改 Shell 环境的运行参数，不带任何参数的 set 命令，会显示所有的环境变量和 Shell 函数。对于所有可以定制的运行参数，请查看官方手册，我们重点介绍其中最常用的四个。\n跟踪命令的执行 默认情况下， Shell 脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。 set -x 用来在运行结果之前，先输出执行的那一行命令，行首以 \u002b 表示是命令而非命令输出，同时，每个命令的参数也会展开，这样我们可以清晰地看到每个命令的运行实参，这对于 Shell 脚本的 debug 来说非常友好。\n#!\/bin\/bash set -x v=5 echo $v echo \u0026#34;hello\u0026#34; # output: # \u002b v=5 # \u002b echo 5 # 5 # \u002b echo hello # hello set -x 还有另一种写法： set -o xtrace 。","inLanguage":"en-US","author":"Morven\u0027s Life","creator":"Morven\u0027s Life","publisher":"Morven\u0027s Life","accountablePerson":"Morven\u0027s Life","copyrightHolder":"Morven\u0027s Life","copyrightYear":"2017","datePublished":"2017-02-06 00:00:00 \u002b0000 UTC","dateModified":"2017-02-06 00:00:00 \u002b0000 UTC","url":"https:\/\/morven.life\/posts\/how-to-write-robust-shell-script\/","keywords":[]}</script><title>编写健壮的 Shell 脚本</title><meta property="og:title" content="编写健壮的 Shell 脚本"><meta property="og:type" content="article"><meta property="og:description" content="编写 Shell 脚本应该是程序员必须掌握的技能。因为 Shell 脚本简单易上手的特性，在日常工作中，我们经常使用它来自动化应用的测试部署、环境的搭建清理等。其实在编写运行 Shell 脚本的时候也会遇到各种坑，稍不注意就会导致 Shell 脚本因为各种原因不能正常执行。实际上，编写健壮可靠的 Shell 脚本也是有很多技巧的，今天我们就来探讨一下。
设置 Shell 的默认执行环境参数 在执行 Shell 脚本的时候，通常都会创建一个新的 Shell ，比如，当我们执行：
bash script.sh 我们指明使用 bash 会创建一个新的 Shell 来执行 script.sh ，同时给定了这个执行环境默认的各种参数。 set 命令可以用来修改 Shell 环境的运行参数，不带任何参数的 set 命令，会显示所有的环境变量和 Shell 函数。对于所有可以定制的运行参数，请查看官方手册，我们重点介绍其中最常用的四个。
跟踪命令的执行 默认情况下， Shell 脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。 set -x 用来在运行结果之前，先输出执行的那一行命令，行首以 + 表示是命令而非命令输出，同时，每个命令的参数也会展开，这样我们可以清晰地看到每个命令的运行实参，这对于 Shell 脚本的 debug 来说非常友好。
#!/bin/bash set -x v=5 echo $v echo &amp;#34;hello&amp;#34; # output: # + v=5 # + echo 5 # 5 # + echo hello # hello set -x 还有另一种写法： set -o xtrace 。"><meta name=description content="编写 Shell 脚本应该是程序员必须掌握的技能。因为 Shell 脚本简单易上手的特性，在日常工作中，我们经常使用它来自动化应用的测试部署、环境的搭建清理等。其实在编写运行 Shell 脚本的时候也会遇到各种坑，稍不注意就会导致 Shell 脚本因为各种原因不能正常执行。实际上，编写健壮可靠的 Shell 脚本也是有很多技巧的，今天我们就来探讨一下。
设置 Shell 的默认执行环境参数 在执行 Shell 脚本的时候，通常都会创建一个新的 Shell ，比如，当我们执行：
bash script.sh 我们指明使用 bash 会创建一个新的 Shell 来执行 script.sh ，同时给定了这个执行环境默认的各种参数。 set 命令可以用来修改 Shell 环境的运行参数，不带任何参数的 set 命令，会显示所有的环境变量和 Shell 函数。对于所有可以定制的运行参数，请查看官方手册，我们重点介绍其中最常用的四个。
跟踪命令的执行 默认情况下， Shell 脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。 set -x 用来在运行结果之前，先输出执行的那一行命令，行首以 + 表示是命令而非命令输出，同时，每个命令的参数也会展开，这样我们可以清晰地看到每个命令的运行实参，这对于 Shell 脚本的 debug 来说非常友好。
#!/bin/bash set -x v=5 echo $v echo &amp;#34;hello&amp;#34; # output: # + v=5 # + echo 5 # 5 # + echo hello # hello set -x 还有另一种写法： set -o xtrace 。"><meta property="og:locale" content="en-us"><style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body blockquote{background-color:#f8f8f8;border-left:2px solid;margin:40px;padding:10px 20px}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:85%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.signatures{font-family:permanent marker,Impact,Charcoal,sans-serif;font-size:3rem;margin-top:32px}.signatures a{text-decoration:none}.header-line{width:100%;height:3px;background-color:#000;margin:18px 0}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-date,.posts-title{font-size:1.2rem}.posts-line{margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px;margin-bottom:3px}.site-footer{margin-top:50px;margin-bottom:80px;display:flex;justify-content:flex-end;flex-wrap:wrap;padding:12px 0;border-width:3px;border-color:#000}.site-footer-item{margin-right:12px}@media screen and (max-width:600px){.site-header{display:none}.post-content{padding:0 12px}.post-content p{letter-spacing:.05em}}@media screen and (max-width:48em){.posts-category{display:none}}.post-content img{max-width:100%;display:block;margin-left:auto;margin-right:auto;margin-top:12px}.post-header{margin-bottom:50px}.post-title{font-size:2.5rem;font-weight:600}.post-category{display:inline;font-weight:900;margin:0 4px;padding:2px 5px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}</style><style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style><link href=https://morven.life/index.xml rel=alternate type=application/rss+xml title="Morven's Life"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class="post 简体中文" id=article><div class=row><div class=col-xs-12><header class=post-header><h1 class=post-title>编写健壮的 Shell 脚本</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2017-02-06 00:00:00 UTC">06 Feb 2017</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://morven.life/>@Morven's Life</a></div></div></div></header><div class="post-content markdown-body"><p>编写 Shell 脚本应该是程序员必须掌握的技能。因为 Shell 脚本简单易上手的特性，在日常工作中，我们经常使用它来自动化应用的测试部署、环境的搭建清理等。其实在编写运行 Shell 脚本的时候也会遇到各种坑，稍不注意就会导致 Shell 脚本因为各种原因不能正常执行。实际上，编写健壮可靠的 Shell 脚本也是有很多技巧的，今天我们就来探讨一下。</p><h2 id=设置-shell-的默认执行环境参数>设置 Shell 的默认执行环境参数</h2><p>在执行 Shell 脚本的时候，通常都会创建一个新的 Shell ，比如，当我们执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>bash script.sh
</span></span></code></pre></div><p>我们指明使用 <code>bash</code> 会创建一个新的 Shell 来执行 <code>script.sh</code> ，同时给定了这个执行环境默认的各种参数。 <code>set</code> 命令可以用来修改 Shell 环境的运行参数，不带任何参数的 <code>set</code> 命令，会显示所有的环境变量和 Shell 函数。对于所有可以定制的运行参数，请查看<a href=https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html>官方手册</a>，我们重点介绍其中最常用的四个。</p><h3 id=跟踪命令的执行>跟踪命令的执行</h3><p>默认情况下， Shell 脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。 <code>set -x</code> 用来在运行结果之前，先输出执行的那一行命令，行首以 <code>+</code> 表示是命令而非命令输出，同时，每个命令的参数也会展开，这样我们可以清晰地看到每个命令的运行实参，这对于 Shell 脚本的 debug 来说非常友好。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#000>$v</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># + v=5</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># + echo 5</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 5</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># + echo hello</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># hello</span>
</span></span></code></pre></div><p><code>set -x</code> 还有另一种写法： <code>set -o xtrace</code> 。</p><h3 id=命令执行失败需报错>命令执行失败需报错</h3><p>实际上 Shell 脚本不像其他高级语言，如 Python, Ruby 等， Shell 脚本默认不提供安全机制，举个简单的例子， Ruby 脚本尝试去读取一个没有初始化的变量的内容的时候会报错，而 Shell 脚本默认不会有任何提示，只是简单地忽略。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#000>$v</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># hello</span>
</span></span></code></pre></div><p>可以看到， <code>echo $v</code> 输出了一个空行， bash 完全忽略了不存在的 <code>$v</code> 继续执行后面的命令 <code>echo "hello"</code> 。这其实并不是开发者想要的行为，对于不存在的变量，脚本应该报错且停止执行来防止错误的叠加。好在，我们可以通过 <code>set -u</code> 来改变这种默认忽略未定义变量行为，脚本在头部加上它，遇到不存在的变量就会报错并停止执行。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -u
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#000>$a</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> bar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># ./script.sh: line 4: v: unbound variable</span>
</span></span></code></pre></div><p><code>set -u</code> 的另一种写法是<code>set -o nounset</code> 。</p><h3 id=命令执行失败需停止>命令执行失败需停止</h3><p>对于默认的 Shell 脚本运行环境，有运行失败的命令（返回值非0）， bash 会继续执行后面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span>unknowncmd
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># ./script.sh: line 3: unknowncmd: command not found</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># hello</span>
</span></span></code></pre></div><p>可以看到， bash 只是显示有错误，接着继续执行 Shell 脚本，这种行为很不利于脚本安全和排错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>command</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#204a87>exit</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span></code></pre></div><p>上面的写法表示只要 <code>command</code> 有非零返回值， Shell 脚本就会停止执行。如果停止执行之前需要完成多个操作，就要采用下面三种更高级的写法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic># option 1</span>
</span></span><span style=display:flex><span><span style=color:#204a87>command</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;command failed&#34;</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87>exit</span> 1<span style=color:#000;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># option 2</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> ! command<span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>then</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;command failed&#34;</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87>exit</span> 1<span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># option 3</span>
</span></span><span style=display:flex><span><span style=color:#204a87>command</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>[</span> <span style=color:#4e9a06>&#34;</span><span style=color:#000>$?</span><span style=color:#4e9a06>&#34;</span> -ne <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#ce5c00;font-weight:700>]</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>then</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;command failed&#34;</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87>exit</span> 1<span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>fi</span>
</span></span></code></pre></div><p>此外，我们很容易就联想到另外一种很类似的用法，如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就可以采用下面的写法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>command1 <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> command2
</span></span></code></pre></div><p>但是这些技巧多少有些麻烦，容易疏忽。而 <code>set -e</code> 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>unknowncmd
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># ./script.sh: line 4: unknowncmd: command not found</span>
</span></span></code></pre></div><p>可以看到，第4行执行失败以后，脚本就终止执行了。 <code>set -e</code> 根据命令的返回值来判断命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>$(</span>ls foobar<span style=color:#204a87;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># ls: cannot access &#39;foobar&#39;: No such file or directory</span>
</span></span></code></pre></div><p>可以看到，打开 <code>set -e</code> 之后，即使 <code>ls</code> 是一个已存在的命令，但因为 <code>ls</code> 命令的运行参数 <code>foobar</code> 实际上并不存在导致命令返回非0值，这有时候并不是我们看到的。</p><p>可以暂时关闭 <code>set -e</code> ，该命令执行结束后，再重新打开 <code>set -e</code> ：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>set</span> +e
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>$(</span>ls foobar<span style=color:#204a87;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#204a87>set</span> -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># ls: cannot access &#39;foobar&#39;: No such file or directory</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># hello</span>
</span></span></code></pre></div><p>上面代码中， <code>set +e</code> 表示关闭 <code>-e</code> 选项， <code>set -e</code> 表示重新打开 <code>-e</code> 选项。</p><p>还有一种写法也能达到相似的目的</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>command</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#204a87>true</span>
</span></span></code></pre></div><p>上面的命令 <code>command</code> 即使执行失败，脚本也不会终止执行。</p><p><code>set -e</code> 还有另一种写法 <code>set -o errexit</code> 。</p><h3 id=控制管道命令的执行>控制管道命令的执行</h3><p>上一小节讲到的 <code>set -e</code> 有一个例外情况，就是不适用于管道命令。对于管道命令， bash 会把最后一个子命令的返回值作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，所以 <code>set -e</code> 就失效了。举个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo <span style=color:#000;font-weight:700>|</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;bar&#34;</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># ./script.sh: line 4: foo: command not found</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># bar</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># hello</span>
</span></span></code></pre></div><p>可以看到，即使 <code>foo</code> 是一个不存在的命令，但是 <code>foo | echo bar</code> 这个管道命令还是会执行成功，导致后面的 <code>echo hello</code> 会继续执行。</p><p><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e
</span></span><span style=display:flex><span><span style=color:#204a87>set</span> -o pipefail
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo <span style=color:#000;font-weight:700>|</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;bar&#34;</span>
</span></span><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># output:</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># ./script.sh: line 5: foo: command not found</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># bar</span>
</span></span></code></pre></div><p>可以看到，<code>foo | echo bar</code> 管道命令的失败整个 Shell 脚本的退出，后续的 <code>echo hello</code> 命令并没有执行。</p><h4 id=合并-shell-默认执行环境参数>合并 Shell 默认执行环境参数</h4><p>对于上面提到的四个 <code>set</code> 命令参数，一般都是放在一起使用：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 写法一</span>
</span></span><span style=display:flex><span><span style=color:#204a87>set</span> -euxo pipefail
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># 写法二</span>
</span></span><span style=display:flex><span><span style=color:#204a87>set</span> -eux
</span></span><span style=display:flex><span><span style=color:#204a87>set</span> -o pipefail
</span></span></code></pre></div><p>这两种写法任选其一放在所有 Shell 脚本的头部。</p><p>当然，也可以在在执行 Shell 脚本的时候，从 bash 命令行传入这些参数：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>bash -euxo pipefail script.sh
</span></span></code></pre></div><h2 id=shell-脚本防御式编程>Shell 脚本防御式编程</h2><p>编写 Shell 脚本的时候应该考虑不可预期的程序输入，如文件不存在或者目录没有创建成功等。其实 Shell 命令有很多选项可以解决这类问题，例如，使用 <code>mkdir</code> 创建目录的时候，如果父目录不存在， <code>mkdir</code> 默认返回错误，但如果加上 <code>-p</code> 选项， <code>mkdir</code> 在父目录不存在的情况下先创建父目录； <code>rm</code> 在删除一个不存在的文件会失败，但如果加上 <code>-f</code> 选项，即使文件不能存在也能执行成功。</p><p><strong>注意字符串中的空格</strong></p><p>我们必须时刻注意字符串中的空格字符，如文件名中的空格，命令参数中的空格等等，对于这些空格字符安全的最佳时实践是使用<strong>引号</strong>括住相应的字符串：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic># will fail if $filename contains spaces</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>[</span> <span style=color:#000>$filename</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;foo&#34;</span> <span style=color:#ce5c00;font-weight:700>]</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># will success even if $filename contains spaces</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>[</span> <span style=color:#4e9a06>&#34;</span><span style=color:#000>$filename</span><span style=color:#4e9a06>&#34;</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;foo&#34;</span> <span style=color:#ce5c00;font-weight:700>]</span><span style=color:#000;font-weight:700>;</span>
</span></span></code></pre></div><p>类似的情况是，我们在使用 <code>$@</code> 或者其他包含由空格分割的多个字符串也要注意使用<strong>引号</strong>括住相应的变量，实际上，使用<strong>引号</strong>括住相应的变量没有任何副作用，只会使我们的编写的 Shell 脚本更加健壮：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#8f5902;font-style:italic># will split the string paramter if parameter contains spaces</span>
</span></span><span style=display:flex><span>foo<span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>for</span> i in <span style=color:#000>$@</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>do</span> <span style=color:#204a87>printf</span> <span style=color:#4e9a06>&#34;%s\n&#34;</span> <span style=color:#4e9a06>&#34;</span><span style=color:#000>$i</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>done</span> <span style=color:#ce5c00;font-weight:700>}</span><span style=color:#000;font-weight:700>;</span> foo bar <span style=color:#4e9a06>&#34;baz quux&#34;</span>
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span>baz
</span></span><span style=display:flex><span>quux
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># will not split the string paramter if parameter contains spaces</span>
</span></span><span style=display:flex><span>foo<span style=color:#ce5c00;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>{</span> <span style=color:#204a87;font-weight:700>for</span> i in <span style=color:#4e9a06>&#34;</span><span style=color:#000>$@</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>do</span> <span style=color:#204a87>printf</span> <span style=color:#4e9a06>&#34;%s\n&#34;</span> <span style=color:#4e9a06>&#34;</span><span style=color:#000>$i</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>done</span> <span style=color:#ce5c00;font-weight:700>}</span><span style=color:#000;font-weight:700>;</span> foo bar <span style=color:#4e9a06>&#34;baz quux&#34;</span>
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span>baz quux
</span></span></code></pre></div><h2 id=多使用-trap-命令捕获信号>多使用 trap 命令捕获信号</h2><p>关于 Shell 脚本另外一个常见的情况是，脚本执行失败导致文件系统处于不一致的状态，比如文件锁、临时文件或者 Shell 脚本的错误只更新了部分文件。为了达到“事务的完整性”我们需要解决这些不一致的问题，要么删除文件锁、临时文件，要么将状态恢复到更新之前的状态。实际上， Shell 脚本确实提供了一种在捕捉到特定的 unix 信号的情况下执行一段命令或者函数的功能：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#204a87>trap</span> <span style=color:#204a87>command</span> signal <span style=color:#ce5c00;font-weight:700>[</span>signal ...<span style=color:#ce5c00;font-weight:700>]</span>
</span></span></code></pre></div><p>其实 Shell 脚本可以捕捉很多类型的信号（完整信号列表可以使用 <code>kill -l</code> 命令获取），但是我们通常只关心在问题发生之后用来恢复现场的三种信号： <code>INT</code> ， <code>TERM</code> 和 <code>EXIT</code> ：</p><table><thead><tr><th style=text-align:left>Signal</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left>INT</td><td style=text-align:left>Interrupt – this signal is sent when someone kills the script by pressing <code>ctrl-c</code></td></tr><tr><td style=text-align:left>TERM</td><td style=text-align:left>Terminate – this signal is sent when someone sends the TERM signal using the kill command</td></tr><tr><td style=text-align:left>EXIT</td><td style=text-align:left>Exit – this is a pseudo-signal and is triggered when your script exits, either through reaching the end of the script, an exit command or by a command failing when using <code>set -e</code></td></tr></tbody></table><p>一般情况下，我们在操作对应的共享区之前先创建文件锁：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>[</span> ! -e <span style=color:#000>$lockfile</span> <span style=color:#ce5c00;font-weight:700>]</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>then</span>
</span></span><span style=display:flex><span>    touch <span style=color:#000>$lockfile</span>
</span></span><span style=display:flex><span>    critical-section
</span></span><span style=display:flex><span>    rm <span style=color:#000>$lockfile</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>else</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;critical-section is already running&#34;</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>fi</span>
</span></span></code></pre></div><p>但是当 Shell 脚本操作对应的共享区的时候有人手动 Kill 掉对应的 Shell 进程，这个时候文件锁的存在会导致 Shell 脚本不能再次操作对应的共享区。使用 <code>trap</code> 命令我们可以捕捉到对应的信号并做相应的恢复操作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#ce5c00;font-weight:700>[</span> ! -e <span style=color:#000>$lockfile</span> <span style=color:#ce5c00;font-weight:700>]</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>then</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87>trap</span> <span style=color:#4e9a06>&#34;rm -f </span><span style=color:#000>$lockfile</span><span style=color:#4e9a06>; exit&#34;</span> INT TERM EXIT
</span></span><span style=display:flex><span>    touch <span style=color:#000>$lockfile</span>
</span></span><span style=display:flex><span>    <span style=color:#000>$lockfile</span>
</span></span><span style=display:flex><span>    rm <span style=color:#000>$lockfile</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87>trap</span> - INT TERM EXIT
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>else</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;critical-section is already running&#34;</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>fi</span>
</span></span></code></pre></div><p>有了上面这段 <code>trap</code> 命令，即使当 Shell 脚本操作对应的共享区的时候有人手动 Kill 掉对应的 Shell 进程，文件锁也会被清理干净。需要注意的是，我们在捕捉到信号之后删除完文件锁之后直接退出而不是继续执行。</p><h2 id=be-atomic>Be Atomic</h2><p>很多时候我们需要一次更新一批文件，但是有可能在更新了一半之后 Shell 脚本出错或者有人 kill 掉了 Shell 进程。你可能会想到，只需要在更新之前对文件做备份，并使用刚才学到的 <code>trap</code> 命令在捕捉到相应的信号之后从备份中恢复文件。这看起来没错，但是很多时候只能解决一部分的问题。例如，我们要把一个网站里面的 URL 从 <code>www.example.org</code> 全部更新为 <code>www.example.com</code> ， Shell 脚本的主要逻辑类似于下面这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87;font-weight:700>for</span> file in <span style=color:#204a87;font-weight:700>$(</span>find /var/www -type f -name <span style=color:#4e9a06>&#34;*.html&#34;</span><span style=color:#204a87;font-weight:700>)</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>do</span>
</span></span><span style=display:flex><span>    perl -pi -e <span style=color:#4e9a06>&#39;s/www.example.org/www.example.com/&#39;</span> <span style=color:#000>$file</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>done</span>
</span></span></code></pre></div><p>正确的做法是尽量使更新操作原子化，实现操作的“事务一致性”：</p><ol><li>拷贝旧目录；</li><li>在拷贝的目录中进行更新操作；</li><li>替换原目录</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>cp -a /var/www /var/www-tmp
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>for</span> file in <span style=color:#204a87;font-weight:700>$(</span>find /var/www-tmp -type f -name <span style=color:#4e9a06>&#34;*.html&#34;</span><span style=color:#204a87;font-weight:700>)</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>do</span>
</span></span><span style=display:flex><span>   perl -pi -e <span style=color:#4e9a06>&#39;s/www.example.org/www.example.com/&#39;</span> <span style=color:#000>$file</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>done</span>
</span></span><span style=display:flex><span>mv /var/www /var/www-old
</span></span><span style=display:flex><span>mv /var/www-tmp /var/www
</span></span></code></pre></div><p>在类 Unix 文件系统上进行最后的两次 <code>mv</code> 操作是非常快的（因为只需要替换两个目录的 <code>inode</code> ，而不用执行实际的拷贝操作），换句话说，容易出错的地方是批量的更新操作，而我们将更新操作全部在拷贝的目录中执行，这样，更新操作即使出错，也不会影响原目录。这里的技巧是，使用双倍的硬盘空间来进行操作，任何是需要长时间打开文件的操作都是在备份目录中进行。事实上，保持一系列操作的原子性对于某些容易出错的 Shell 脚本来说非常重要，同时操作前备份文件也是一个好的编程习惯。</p></div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=https://morven.life/categories/note/>note</a></div><div class=post-category><a href=https://morven.life/categories/tech/>tech</a></div></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=https://morven.life/about/ target=_blank>About Me</a></div></div></div></div></article><script src=https://morven.life/js/lazyload.min.js></script>
<script>var lazyImage=new LazyLoad({container:document.getElementById("article")})</script><script></script></body></html>