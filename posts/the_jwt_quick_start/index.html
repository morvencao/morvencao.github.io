<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.80.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Morven's Life"><meta property=og:url content=https://morven.life/posts/the_jwt_quick_start/><link rel=canonical href=https://morven.life/posts/the_jwt_quick_start/><link rel="shortcut icon" href=https://morven.life/favicon.ico type=image/x-png><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/morven.life\/"},"articleSection":"posts","name":"JSON Web Token","headline":"JSON Web Token","description":"近几年，前后端分离大行其道。在典型的前后端分离的应用架构中，后端主要作为Model层，为前端提供数据访问API。前后端之间的通信需要在不可信（Zero Trust）的异构网络之间进行，为了保证数据安全可靠地在客户端与服务端之间传输，实现服务端的客户端认证就显得非常重要。而HTTP协议本身是无状态的，实现服务端的客户端认证的基础是记录客户端和服务端的对话状态。\n我们最熟悉的服务端认证客户端的方式就是基于Session\/Cookie的状态记录方式，服务端在第一次请求时声生成对应的Session发送给客户端保存在Cookie中，同时Session信息还会保存在服务器端，然后客户端之后对于服务器端的每次请求都需要带上Cookie，服务器端取出相应Session并与保存的Session信息进行对比，以实现身份的认证。\n这种模式最大的问题是，没有分布式架构，无法支持横向扩展。如果使用一个服务器，该模式完全没有问题。但是，如果它是服务器群集或面向服务的跨域体系结构的话，则需要一个统一的session数据库库来保存会话数据实现共享，这样负载均衡下的每个服务器才可以正确的验证用户身份。\n举例来说，某企业同时有两个不同的网站A和网站B提供服务，如何做到用户只需要登录其中一个网站，然后它就会自动登录到另一个网站？\n一种解决方案是使用听过持久化Session的基础设施（如Redis），写入Session数据到持久层。收到新的客户端请求后，服务端从从持久层查找对应的Session信息。这种方案的优点在于架构清晰，而缺点是架构修改比较费劲，整个服务的验证逻辑层都需要重写，工作量相对较大。而且由于依赖于持久层的数据库或者问题系统，会有单点风险，如果持久层失败，整个认证体系都会挂掉。\n儿JWT另辟蹊径，基于Token（令牌）认证客户端，也就是说只需要在每次客户端的请求的HTTP头部附上 对应的Token，由服务器端去检查Token的签名来确保Token没有被篡改，这样通过客户端保存数据，而服务器根本不保存会话数据，每个请求都被发送回服务器端认证。\n什么是JWT(JSON Web Token) 根据官方的定义，JWT是一套开放的标准（RFC 7519），它定义了一套简洁（compact）且安全（URL-safe）的方案，可以在客户端和服务器之间传输JSON格式的Token信息。\nJWT工作原理 JWT服务端认证的基本原理是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。\n{ \u0026#34;username\u0026#34;: \u0026#34;morvencao\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;Admin\u0026#34;, \u0026#34;expire\u0026#34;: \u0026#34;2017-02-08 12:45:43\u0026#34; } 之后，当客户端与服务器端通信时，客户端需要在请求中发回这个JSON对象。服务器仅依赖于这个JSON对象的内容来认证客户端。为了防止中间人（man-in-middle）篡改数据，服务器将在生成JSON对象时添加签名。但服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展。\nJWT的数据结构 一个典型的JWT的数据结构看起来如下图所示：\nJWT对象为一个很长的字符串，字符之间通过\u0026quot;.\u0026ldquo;分隔符分为三个子串，各字串之间也没有换行符。每一个子串表示了一个功能块，总共有以下三个部分：\n JWT头  JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示：\n{ \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } 在上面的代码片段中，alg属性表示签名使用的算法，默认为HMAC SHA256（HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT；最后，使用Base64URL算法将上述JSON对象转换为字符串保存。\n有效载荷  有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。JWT指定七个默认字段供选择：\niss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID用于标识该JWT 除以上默认字段外，我们还可以自定义私有字段，如下例所示：\n{ \u0026#34;sub\u0026#34;: \u0026#34;xxxxxxxxx\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;morvencao\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;Admin\u0026#34;, \u0026#34;expire\u0026#34;: \u0026#34;2017-02-08 12:45:43\u0026#34; }  Note: 默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。\n JSON对象也使用Base64URL算法转换为字符串保存。\n签名哈希  签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。","inLanguage":"en-US","author":"Morven\u0027s Life","creator":"Morven\u0027s Life","publisher":"Morven\u0027s Life","accountablePerson":"Morven\u0027s Life","copyrightHolder":"Morven\u0027s Life","copyrightYear":"2016","datePublished":"2016-04-20 00:00:00 \u002b0000 UTC","dateModified":"2016-04-20 00:00:00 \u002b0000 UTC","url":"https:\/\/morven.life\/posts\/the_jwt_quick_start\/","keywords":[]}</script><title>JSON Web Token - Morven's Life</title><meta property=og:title content="JSON Web Token - Morven's Life"><meta property=og:type content=article><meta name=description content='近几年，前后端分离大行其道。在典型的前后端分离的应用架构中，后端主要作为Model层，为前端提供数据访问API。前后端之间的通信需要在不可信（Zero Trust）的异构网络之间进行，为了保证数据安全可靠地在客户端与服务端之间传输，实现服务端的客户端认证就显得非常重要。而HTTP协议本身是无状态的，实现服务端的客户端认证的基础是记录客户端和服务端的对话状态。
我们最熟悉的服务端认证客户端的方式就是基于Session/Cookie的状态记录方式，服务端在第一次请求时声生成对应的Session发送给客户端保存在Cookie中，同时Session信息还会保存在服务器端，然后客户端之后对于服务器端的每次请求都需要带上Cookie，服务器端取出相应Session并与保存的Session信息进行对比，以实现身份的认证。
这种模式最大的问题是，没有分布式架构，无法支持横向扩展。如果使用一个服务器，该模式完全没有问题。但是，如果它是服务器群集或面向服务的跨域体系结构的话，则需要一个统一的session数据库库来保存会话数据实现共享，这样负载均衡下的每个服务器才可以正确的验证用户身份。
举例来说，某企业同时有两个不同的网站A和网站B提供服务，如何做到用户只需要登录其中一个网站，然后它就会自动登录到另一个网站？
一种解决方案是使用听过持久化Session的基础设施（如Redis），写入Session数据到持久层。收到新的客户端请求后，服务端从从持久层查找对应的Session信息。这种方案的优点在于架构清晰，而缺点是架构修改比较费劲，整个服务的验证逻辑层都需要重写，工作量相对较大。而且由于依赖于持久层的数据库或者问题系统，会有单点风险，如果持久层失败，整个认证体系都会挂掉。
儿JWT另辟蹊径，基于Token（令牌）认证客户端，也就是说只需要在每次客户端的请求的HTTP头部附上 对应的Token，由服务器端去检查Token的签名来确保Token没有被篡改，这样通过客户端保存数据，而服务器根本不保存会话数据，每个请求都被发送回服务器端认证。
什么是JWT(JSON Web Token) 根据官方的定义，JWT是一套开放的标准（RFC 7519），它定义了一套简洁（compact）且安全（URL-safe）的方案，可以在客户端和服务器之间传输JSON格式的Token信息。
JWT工作原理 JWT服务端认证的基本原理是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。
{ "username": "morvencao", "role": "Admin", "expire": "2017-02-08 12:45:43" } 之后，当客户端与服务器端通信时，客户端需要在请求中发回这个JSON对象。服务器仅依赖于这个JSON对象的内容来认证客户端。为了防止中间人（man-in-middle）篡改数据，服务器将在生成JSON对象时添加签名。但服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展。
JWT的数据结构 一个典型的JWT的数据结构看起来如下图所示：
JWT对象为一个很长的字符串，字符之间通过".&ldquo;分隔符分为三个子串，各字串之间也没有换行符。每一个子串表示了一个功能块，总共有以下三个部分：
 JWT头  JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示：
{ "alg": "HS256", "typ": "JWT" } 在上面的代码片段中，alg属性表示签名使用的算法，默认为HMAC SHA256（HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT；最后，使用Base64URL算法将上述JSON对象转换为字符串保存。
有效载荷  有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。JWT指定七个默认字段供选择：
iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID用于标识该JWT 除以上默认字段外，我们还可以自定义私有字段，如下例所示：
{ "sub": "xxxxxxxxx", "username": "morvencao", "role": "Admin", "expire": "2017-02-08 12:45:43" }  Note: 默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。
 JSON对象也使用Base64URL算法转换为字符串保存。
签名哈希  签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。'><link rel=stylesheet href=https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css><link rel=stylesheet href=https://morven.life/css/index.css><link href=https://morven.life/index.xml rel=alternate type=application/rss+xml title="Morven's Life"><script>(function(undefined){}).call('object'===typeof window&&window||'object'===typeof self&&self||'object'===typeof global&&global||{});</script><article class="post 简体中文" id=article><div class=row><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href=https://morven.life/><div class=head-line></div></a><header class=post-header><h1 class=post-title>JSON Web Token</h1><div class=row><div class=col-xs-6><time class=post-date datetime="2016-04-20 00:00:00 UTC">20 Apr 2016</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://morven.life/>@Morven's Life</a></div></div></div></header><div class="post-content markdown-body"><p>近几年，前后端分离大行其道。在典型的前后端分离的应用架构中，后端主要作为Model层，为前端提供数据访问API。前后端之间的通信需要在不可信（Zero Trust）的异构网络之间进行，为了保证数据安全可靠地在客户端与服务端之间传输，实现服务端的客户端认证就显得非常重要。而HTTP协议本身是无状态的，实现服务端的客户端认证的基础是记录客户端和服务端的对话状态。<p>我们最熟悉的服务端认证客户端的方式就是基于Session/Cookie的状态记录方式，服务端在第一次请求时声生成对应的Session发送给客户端保存在Cookie中，同时Session信息还会保存在服务器端，然后客户端之后对于服务器端的每次请求都需要带上Cookie，服务器端取出相应Session并与保存的Session信息进行对比，以实现身份的认证。<p><img src=https://i.loli.net/2019/07/13/5d29cd435e80182826.jpg alt><p>这种模式最大的问题是，没有分布式架构，无法支持横向扩展。如果使用一个服务器，该模式完全没有问题。但是，如果它是服务器群集或面向服务的跨域体系结构的话，则需要一个统一的session数据库库来保存会话数据实现共享，这样负载均衡下的每个服务器才可以正确的验证用户身份。<p>举例来说，某企业同时有两个不同的网站A和网站B提供服务，如何做到用户只需要登录其中一个网站，然后它就会自动登录到另一个网站？<p>一种解决方案是使用听过持久化Session的基础设施（如Redis），写入Session数据到持久层。收到新的客户端请求后，服务端从从持久层查找对应的Session信息。这种方案的优点在于架构清晰，而缺点是架构修改比较费劲，整个服务的验证逻辑层都需要重写，工作量相对较大。而且由于依赖于持久层的数据库或者问题系统，会有单点风险，如果持久层失败，整个认证体系都会挂掉。<p><img src=https://i.loli.net/2019/07/13/5d29c64a39f9615138.jpg alt><p>儿JWT另辟蹊径，基于Token（令牌）认证客户端，也就是说只需要在每次客户端的请求的HTTP头部附上 对应的Token，由服务器端去检查Token的签名来确保Token没有被篡改，这样通过客户端保存数据，而服务器根本不保存会话数据，每个请求都被发送回服务器端认证。<h3 id=什么是jwtjson-web-token>什么是JWT(JSON Web Token)</h3><p>根据<a href=https://jwt.io/introduction/>官方</a>的定义，JWT是一套开放的标准（<a href=https://tools.ietf.org/html/rfc7519>RFC 7519</a>），它定义了一套简洁（compact）且安全（URL-safe）的方案，可以在客户端和服务器之间传输JSON格式的Token信息。<h3 id=jwt工作原理>JWT工作原理</h3><p><img src=https://i.bmp.ovh/imgs/2019/07/20f54328d6bd6e9e.jpg alt><p>JWT服务端认证的基本原理是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{
    &#34;username&#34;: &#34;morvencao&#34;,
    &#34;role&#34;: &#34;Admin&#34;,
    &#34;expire&#34;: &#34;2017-02-08 12:45:43&#34;
}
</code></pre></div><p>之后，当客户端与服务器端通信时，客户端需要在请求中发回这个JSON对象。服务器仅依赖于这个JSON对象的内容来认证客户端。为了防止中间人（man-in-middle）篡改数据，服务器将在生成JSON对象时添加签名。但服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展。<h4 id=jwt的数据结构>JWT的数据结构</h4><p>一个典型的JWT的数据结构看起来如下图所示：<p><img src=https://i.bmp.ovh/imgs/2019/07/c0f37a213a74fb98.jpg alt><p>JWT对象为一个很长的字符串，字符之间通过".&ldquo;分隔符分为三个子串，各字串之间也没有换行符。每一个子串表示了一个功能块，总共有以下三个部分：<ol><li>JWT头</ol><p>JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{
    &#34;alg&#34;: &#34;HS256&#34;,
    &#34;typ&#34;: &#34;JWT&#34;
}
</code></pre></div><p>在上面的代码片段中，<code>alg</code>属性表示签名使用的算法，默认为<code>HMAC SHA256</code>（HS256）；<code>typ</code>属性表示令牌的类型，JWT令牌统一写为<code>JWT</code>；最后，使用<code>Base64URL</code>算法将上述JSON对象转换为字符串保存。<ol start=2><li>有效载荷</ol><p>有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。JWT指定七个默认字段供选择：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>iss：发行人
exp：到期时间
sub：主题
aud：用户
nbf：在此之前不可用
iat：发布时间
jti：JWT ID用于标识该JWT
</code></pre></div><p>除以上默认字段外，我们还可以自定义私有字段，如下例所示：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{
    &#34;sub&#34;: &#34;xxxxxxxxx&#34;,
    &#34;username&#34;: &#34;morvencao&#34;,
    &#34;role&#34;: &#34;Admin&#34;,
    &#34;expire&#34;: &#34;2017-02-08 12:45:43&#34;
}
</code></pre></div><blockquote><p>Note: 默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。</blockquote><p>JSON对象也使用<code>Base64URL</code>算法转换为字符串保存。<ol start=3><li>签名哈希</ol><p>签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。<p>首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为<code>HMAC SHA256</code>）根据以下公式生成签名：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>HMACSHA256(base64UrlEncode(header) + &#34;.&#34; + base64UrlEncode(payload), secret)
</code></pre></div><p>在计算出签名哈希后，<code>JWT头</code>+<code>有效载荷</code>+<code>签名哈希</code>三个部分组合成一个字符串，每个部分用&rdquo;.&ldquo;分隔，就构成整个JWT对象。<h3 id=优点>优点</h3><ul><li>体积小：一串字符串，传输速度快<li>传输方式多样：可以通过 HTTP 头部（推荐）/URL/POST 参数等方式传输<li>严谨的结构化：它自身（在payload中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且payload支持应用定制<li>支持跨域验证：多应用于单点登录</ul><p>其实，除了以上很容易看得见的优点之外，相对于传统的服务端认证，JWT还有以下优点：<ol><li>充分依赖无状态API，契合RESTful设计原则</ol><p>JWT的设计契合无状态原则：用户登录之后，服务器会返回一串token并保存在本地，在这之后的服务器访问都要带上这串token，来获得访问相关路由、服务及资源的权限。比如单点登录就比较多地使用了JWT，因为它的体积小，并且经过简单处理（使用HTTP头带上Bearer属性 + token）就可以支持跨域操作。<ol start=2><li>易于实现 CDN，将静态资源分布式管理</ol><p>在传统的session验证中，服务端必须保存session ID，用于与用户传过来的cookie验证。而一开始session只会保存在一台服务器上，所以只能由一台server应答，就算其他服务器有空闲也无法应答，无法充分利用到分布式服务器的优点。JWT依赖的是在客户端本地保存验证信息，不需要利用服务器保存的信息来验证，所以任意一台服务器都可以应答，服务器的资源也能被较好地利用。<ol start=3><li>认证解耦，随处生成</ol><p>无需使用特定的身份验证方案，只要拥有生成token所需的认证信息，在何处都可以调用相应接口生成token，无需繁琐的耦合的认证操作，可谓是一次生成，永久使用。</div></div></div></article><script src=https://morven.life/js/highlight.pack.js></script><script src=https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js></script><script src=https://cdn.jsdelivr.net/npm/vanilla-lazyload@10.19.0/dist/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')});</script><script>hljs.initHighlightingOnLoad();var posts=document.getElementById('posts-list');posts&&quicklink({el:posts,priority:true,});</script>