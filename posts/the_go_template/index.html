<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.80.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Morven's Life"><meta property=og:url content=https://morven.life/posts/the_go_template/><link rel=canonical href=https://morven.life/posts/the_go_template/><link rel="shortcut icon" href=https://morven.life/favicon.ico type=image/x-png><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/morven.life\/"},"articleSection":"posts","name":"5分钟系列 -「Go Template」","headline":"5分钟系列 -「Go Template」","description":"随着近几年Restful架构的盛行，前后端分离大行其道，模板渲染也由后端转移到了前端，后端只需要提供资源数据即可，这样导致类似于JSP和PHP的传统服务端模板脚本语言几乎问人问津了。但是在Go语言中，模板渲染技术不只局限于服务端标记语言（如HTML页面）的渲染，事实上，GO语言经常使用模版语言来处理譬如插入特定数据的文本转化等，虽然没有正则表达式那么灵活，但是渲染效率远优于正则表达式，而且使用起来也更简单。对于某些云计算的场景十分友好。今天，我们就来详细聊一聊Go Template的技术细节。\n运行机制 模板的渲染技术本质上都是一样的，一句话来说明就是字串模板和结构化数据的结合，再详细地讲就是将定义好的模板应用于结构化的数据，使用注解语法引用数据结构中的元素（例如Struct中的特定feild，Map中的key）并显示它们的值。模板在执行过程中遍历数据结构并且设置当前光标（\u0026quot;.\u0026quot;表示当前的作用域）标识当前位置的元素。\n类似于Python的jinja，Node的jade等模版引擎，Go语言模板引擎的运行机制也是类似：\n 创建模板对象 解析模板字串 加载数据渲染模板  Go模板核心包 Go提供了两个标准库用来处理模板渲染text\/template和html\/template，它们的接口几乎一摸一样，但处理的模板数据不同。其中text\/template用来处理普通文本的模板渲染，而html\/template专门用来渲染格式化html字符串。\n下面的例子我们使用text\/template来处理普通文本模板的渲染：\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;text\/template\u0026#34; ) type Student struct { ID uint Name string } func main() { stu := Student{0, \u0026#34;jason\u0026#34;} tmpl, err := template.New(\u0026#34;test\u0026#34;).Parse(\u0026#34;The name for student {{.ID}} is {{.Name}}\u0026#34;) if err != nil { panic(err) } err = tmpl.Execute(os.Stdout, stu) if err != nil { panic(err) } } 上述代码第4行引入text\/template来处理普通文本模板渲染，第14行定义一个模板对象test来解析变量\u0026quot;The name for student {{.ID}} is {{.","inLanguage":"en-US","author":"Morven\u0027s Life","creator":"Morven\u0027s Life","publisher":"Morven\u0027s Life","accountablePerson":"Morven\u0027s Life","copyrightHolder":"Morven\u0027s Life","copyrightYear":"2018","datePublished":"2018-08-24 00:00:00 \u002b0000 UTC","dateModified":"2018-08-24 00:00:00 \u002b0000 UTC","url":"https:\/\/morven.life\/posts\/the_go_template\/","keywords":[]}</script><title>5分钟系列 -「Go Template」 - Morven's Life</title><meta property=og:title content="5分钟系列 -「Go Template」 - Morven's Life"><meta property=og:type content=article><meta name=description content='随着近几年Restful架构的盛行，前后端分离大行其道，模板渲染也由后端转移到了前端，后端只需要提供资源数据即可，这样导致类似于JSP和PHP的传统服务端模板脚本语言几乎问人问津了。但是在Go语言中，模板渲染技术不只局限于服务端标记语言（如HTML页面）的渲染，事实上，GO语言经常使用模版语言来处理譬如插入特定数据的文本转化等，虽然没有正则表达式那么灵活，但是渲染效率远优于正则表达式，而且使用起来也更简单。对于某些云计算的场景十分友好。今天，我们就来详细聊一聊Go Template的技术细节。
运行机制 模板的渲染技术本质上都是一样的，一句话来说明就是字串模板和结构化数据的结合，再详细地讲就是将定义好的模板应用于结构化的数据，使用注解语法引用数据结构中的元素（例如Struct中的特定feild，Map中的key）并显示它们的值。模板在执行过程中遍历数据结构并且设置当前光标（"."表示当前的作用域）标识当前位置的元素。
类似于Python的jinja，Node的jade等模版引擎，Go语言模板引擎的运行机制也是类似：
 创建模板对象 解析模板字串 加载数据渲染模板  Go模板核心包 Go提供了两个标准库用来处理模板渲染text/template和html/template，它们的接口几乎一摸一样，但处理的模板数据不同。其中text/template用来处理普通文本的模板渲染，而html/template专门用来渲染格式化html字符串。
下面的例子我们使用text/template来处理普通文本模板的渲染：
package main import ( "os" "text/template" ) type Student struct { ID uint Name string } func main() { stu := Student{0, "jason"} tmpl, err := template.New("test").Parse("The name for student {{.ID}} is {{.Name}}") if err != nil { panic(err) } err = tmpl.Execute(os.Stdout, stu) if err != nil { panic(err) } } 上述代码第4行引入text/template来处理普通文本模板渲染，第14行定义一个模板对象test来解析变量"The name for student {{.ID}} is {{.'><link rel=stylesheet href=https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css><link rel=stylesheet href=https://morven.life/css/index.css><link href=https://morven.life/index.xml rel=alternate type=application/rss+xml title="Morven's Life"><script>(function(undefined){}).call('object'===typeof window&&window||'object'===typeof self&&self||'object'===typeof global&&global||{});</script><article class="post 简体中文" id=article><div class=row><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href=https://morven.life/><div class=head-line></div></a><header class=post-header><h1 class=post-title>5分钟系列 -「Go Template」</h1><div class=row><div class=col-xs-6><time class=post-date datetime="2018-08-24 00:00:00 UTC">24 Aug 2018</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://morven.life/>@Morven's Life</a></div></div></div></header><div class="post-content markdown-body"><p>随着近几年Restful架构的盛行，前后端分离大行其道，模板渲染也由后端转移到了前端，后端只需要提供资源数据即可，这样导致类似于JSP和PHP的传统服务端模板脚本语言几乎问人问津了。但是在Go语言中，模板渲染技术不只局限于服务端标记语言（如HTML页面）的渲染，事实上，GO语言经常使用模版语言来处理譬如插入特定数据的文本转化等，虽然没有正则表达式那么灵活，但是渲染效率远优于正则表达式，而且使用起来也更简单。对于某些云计算的场景十分友好。今天，我们就来详细聊一聊Go Template的技术细节。<h2 id=运行机制>运行机制</h2><p>模板的渲染技术本质上都是一样的，一句话来说明就是<strong>字串模板和结构化数据</strong>的结合，再详细地讲就是将定义好的模板应用于结构化的数据，使用注解语法引用数据结构中的元素（例如Struct中的特定feild，Map中的key）并显示它们的值。模板在执行过程中遍历数据结构并且设置当前光标（<code>"."</code>表示当前的作用域）标识当前位置的元素。<p>类似于Python的<a href=http://jinja.pocoo.org/>jinja</a>，Node的<a href=http://jade-lang.com/>jade</a>等模版引擎，Go语言模板引擎的运行机制也是类似：<ol><li>创建模板对象<li>解析模板字串<li>加载数据渲染模板</ol><p><img src=https://i.loli.net/2019/03/31/5ca036206c6f3.jpg alt><h2 id=go模板核心包>Go模板核心包</h2><p>Go提供了两个标准库用来处理模板渲染<code>text/template</code>和<code>html/template</code>，它们的接口几乎一摸一样，但处理的模板数据不同。其中<code>text/template</code>用来处理普通文本的模板渲染，而<code>html/template</code>专门用来渲染格式化<code>html</code>字符串。<p>下面的例子我们使用<code>text/template</code>来处理普通文本模板的渲染：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#204a87;font-weight:700>package</span> <span style=color:#000>main</span>

<span style=color:#204a87;font-weight:700>import</span> <span style=color:#000;font-weight:700>(</span>
	<span style=color:#4e9a06>&#34;os&#34;</span>
        <span style=color:#4e9a06>&#34;text/template&#34;</span>
<span style=color:#000;font-weight:700>)</span>

<span style=color:#204a87;font-weight:700>type</span> <span style=color:#000>Student</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>ID</span>      <span style=color:#204a87;font-weight:700>uint</span>
    <span style=color:#000>Name</span>    <span style=color:#204a87;font-weight:700>string</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>stu</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#000>Student</span><span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;jason&#34;</span><span style=color:#000;font-weight:700>}</span>
    <span style=color:#000>tmpl</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>err</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#000>template</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>New</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;test&#34;</span><span style=color:#000;font-weight:700>).</span><span style=color:#000>Parse</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;The name for student {{.ID}} is {{.Name}}&#34;</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>err</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>nil</span> <span style=color:#000;font-weight:700>{</span> <span style=color:#204a87>panic</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>err</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>}</span>
    <span style=color:#000>err</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>tmpl</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Execute</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>os</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Stdout</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>stu</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>err</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>nil</span> <span style=color:#000;font-weight:700>{</span> <span style=color:#204a87>panic</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>err</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>}</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>上述代码第4行引入<code>text/template</code>来处理普通文本模板渲染，第14行定义一个模板对象<code>test</code>来解析变量<code>"The name for student {{.ID}} is {{.Name}}"</code>模板字符串，第16行使用定义好的结构化数据来渲染模版到标准输出。<blockquote><p>Note: 要引用的模板数据一定是export出来的，也就是说对应的字段必须以大写字母开头，比如例子中的<code>ID</code>, <code>Name</code>。</blockquote><p>我们再来看一个HTML字符串默板渲染的例子：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>func templateHandler(w http.ResponseWriter, r *http.Request){
    tmpl := `&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt; &lt;title&gt;Go Template Demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        {{ . }}
    &lt;/body&gt;
&lt;/html&gt;`
    
    t := template.New(&#34;hello.html&#34;)
    t, _ = t.Parse(tmpl)
    t.Execute(w, &#34;Hello, Go Template!&#34;)
}
</code></pre></div><blockquote><p>Note: 在Go语言中不倾向于使用单引号来表示字符串，请根据需要使用双引号或反引号。另外，Go语言的字符串类型在本质上就与其他语言的字符串类型不同。Java的<code>String</code>、C++的<code>std::string</code>以及python3的<code>str</code>类型都只是<strong>定宽字符序列</strong>，而Go语言的字符串是一个用<code>UTF-8</code>编码的<strong>变宽字符序列</strong>，也就是说，它的每一个字符都用一个或多个字节表示。
Go语言中的字符串字面量使用双引号或反引号("`")来创建：<ul><li>双引号用来创建可解析的字符串字面量 (支持转义，但不能用来引用多行)；<li>反引号用来创建原生(raw)字符串字面量，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。</ul></blockquote><p>本地部署执行：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>curl -i http://127.0.0.1:8080/
HTTP/1.1 200 OK
Date: Fri, 09 Dec 2016 09:04:36 GMT
Content-Length: 223
Content-Type: text/html; charset=utf-8

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt; &lt;title&gt;Go Template Demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello, Go Template!
    &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>go不仅可以直接解析模板字串，也可以使用<a href=https://golang.org/pkg/html/template/#ParseFiles>ParseFile</a>解析模板文件，还是标准的处理流程：<strong>创建-加载-渲染</strong>。<h2 id=模板命名>模板命名</h2><p>之前的例子模板对象是有名字的，可以在创建模板对象的时候显示命名，也可以让Go Template自动命名。但是如果涉及到嵌套模板的时候，该如何命名模板呢，这种情况下，模板文件有好多个！<p>Go Template提供了<a href=https://golang.org/pkg/html/template/#Template.ExecuteTemplate>ExecuteTemplate方法</a>，用于执行指定名字的Go模板。比如加载<code>hello</code>模板的时候，可以指定layout.html<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>tmplstr := `{{ define &#34;stu_info&#34; }}
The name for student {{.ID}} is {{.Name}}
{{ end }}
{{ define &#34;stu_name&#34; }}
Student name is {{.Name}}
{{ end }}
`
stu := Student{0, &#34;jason&#34;}
tmpl, err := template.New(&#34;test&#34;).Parse(tmplstr)
if err != nil { panic(err) }
err = tmpl.ExecuteTemplate(os.Stdout, &#34;stu_info&#34;, stu)
if err != nil { panic(err) }
}
</code></pre></div><p>在模板字符串中，使用了<code>define</code>这个action定义了两个命名模版<code>stu_info</code>，<code>stu_name</code>。这是虽然<code>Parse</code>方法返回的模板对象里面包含两个模板名， 但是<code>ExecuteTemplate</code>执行的模板还是<code>stu_info</code>。<p>不仅可以通过<code>define</code>定义模板，还可以通过<code>template</code>引入定义好的模板，类似jinja的<code>include</code>特性：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>tmplstr := `{{ define &#34;stu_name&#34; }}
Student name is {{.Name}}
{{ end }}
{{ define &#34;stu_info&#34; }}
{{ template &#34;stu_name&#34; . }}
{{ end }}
`
stu := Student{0, &#34;jason&#34;}
tmpl, err := template.New(&#34;test&#34;).Parse(tmplstr)
if err != nil { panic(err) }
err = tmpl.ExecuteTemplate(os.Stdout, &#34;stu_info&#34;, stu)
if err != nil { panic(err) }
}
</code></pre></div><p>上面的例子当中我们在<code>stu_info</code>模板中使用<code>template</code>引入了<code>stu_name</code>模板，同时传给<code>stu_name</code>模板当前作用域的数据(<code>.</code>)，第三个参数是可选的，如果为空，则表示传给嵌套模版的数据为<code>nil</code>。<p>总而言之，创建模板对象后和加载多个模板文件，执行模板文件的时候需要指定base模板（<code>stu_info</code>），在base模板中可以引入其他命名的模板。这里的<code>define</code>和<code>template</code>等在双花括号的关键字其实都是Go Template的<strong>action</strong>（模板标签）。<h2 id=模板action>模板Action</h2><p>通过前面的介绍，我们知道模板其实是包含了一个或多个由双花括号包含的<code>{{ }}</code>的模板字符串的文本或者文件。大部分模板字符串只是按字面值打印，但是如果模板字符串包含<code>action</code>将触发其它的行为。每个<code>action</code>都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流<code>if-else</code>语句和<code>range</code>循环语句，还有其它实例化模板等诸多特性。<p>概括起来，Go Template的action是用于动态执行一些逻辑和展示数据的形式，大致分为下面几类：<ul><li>条件语句<li>迭代<li>封装<li>引用</ul><p>我们在之前的例子中看到了<code>define</code>以及<code>template</code>的用法，下面再看看其他的action怎么使用：<h4 id=条件判断>条件判断</h4><p>条件判断的语法很简单：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{{if pipeline}} T1 {{end}}
	If the value of the pipeline is empty, no output is generated;
	otherwise, T1 is executed. The empty values are false, 0, any
	nil pointer or interface value, and any array, slice, map, or
	string of length zero.
	Dot is unaffected.

{{if pipeline}} T1 {{else}} T0 {{end}}
	If the value of the pipeline is empty, T0 is executed;
	otherwise, T1 is executed. Dot is unaffected.

{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}
	To simplify the appearance of if-else chains, the else action
	of an if may include another if directly; the effect is exactly
	the same as writing
		{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}
</code></pre></div><p>举个简单的例子：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>func test1(a int) bool {
    if a == 3 {
        return true;
    }
    return false;
}

func main() {
	t := template.New(&#34;test&#34;);
	t.Funcs(template.FuncMap{&#34;test1&#34;: test1});
	// {{if 表达式}}{{else if}}{{else}}{{end}}
	// if后面可以是一个条件表达式，可以是字符串或布尔值变量
	// 注意if后面不能直接使用==来判断
	t, _ = t.Parse(`
{{if 1}}
    it&#39;s true
{{else}}
	it&#39;s false
{{end}}
 
{{$a := 4}}
{{if $a|test1}}
	$a=3
{{else}}
	$a!=3
{{end}}
`);
	t.Execute(os.Stdout, nil);
	fmt.Println();
</code></pre></div><h4 id=迭代>迭代</h4><p>对于一些数组，Slice或者是Map，可以使用迭代的action，与Go语言本身的迭代类似，使用<code>range</code>进行处理：<p>详细规范如下：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{{range pipeline}} T1 {{end}}
	The value of the pipeline must be an array, slice, map, or channel.
	If the value of the pipeline has length zero, nothing is output;
	otherwise, dot is set to the successive elements of the array,
	slice, or map and T1 is executed. If the value is a map and the
	keys are of basic type with a defined order (&#34;comparable&#34;), the
	elements will be visited in sorted key order.

{{range pipeline}} T1 {{else}} T0 {{end}}
	The value of the pipeline must be an array, slice, map, or channel.
	If the value of the pipeline has length zero, dot is unaffected and
	T0 is executed; otherwise, dot is set to the successive elements
	of the array, slice, or map and T1 is executed.
</code></pre></div><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{{ range . }}
    &lt;li&gt;{{ . }}&lt;/li&gt;
{{ else }}
 empty
{{ end }}
</code></pre></div><p>当<code>range</code>的结构为空的时候，则会执行<code>else</code>分支的逻辑。<h4 id=with封装>with封装</h4><p><code>with</code>语言在Python中可以开启一个上下文环境。对于Go Template，<code>with</code>语句类似，其含义就是创建一个封闭的作用域，在其范围内，可以使用<code>.action</code>，而与外面的<code>.</code>无关，只与<code>with</code>的参数有关：<p>详细规范如下：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{{with pipeline}} T1 {{end}}
	If the value of the pipeline is empty, no output is generated;
	otherwise, dot is set to the value of the pipeline and T1 is
	executed.

{{with pipeline}} T1 {{else}} T0 {{end}}
	If the value of the pipeline is empty, dot is unaffected and T0
	is executed; otherwise, dot is set to the value of the pipeline
	and T1 is executed.
</code></pre></div><p>举个例子：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{{ with arg }}
    .
{{ end }}
</code></pre></div><p>在上面<code>with</code>里面的<code>.</code>代表with新开辟的作用域，而不是with外面的作用域。<code>with</code>语句的<code>.</code>与其外面的<code>.</code>是两个不相关的对象。<code>with</code>语句也可以有<code>else</code>。<code>else</code>中的<code>.</code>则和<code>with</code>外面的<code>.</code>一样，毕竟只有with语句内才有封闭的上下文：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{{ with &#34;&#34;}}
 Now the dot is set to {{ . }}
{{ else }}
 {{ . }}
{{ end }}
</code></pre></div><h4 id=嵌套模板>嵌套模板</h4><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>func test1() string {
	return &#34;test1&#34;;
}

func main() {
	t := template.New(&#34;test&#34;);
	t.Funcs(template.FuncMap{&#34;test1&#34;: test1});
	// {{ define &#34;templateName&#34; }}Template Content{{end}} --&gt; define the template
	// {{ template &#34;templateName&#34; }} --&gt; reference the template
	// {{ template &#34;templateName&#34; function }} --&gt; Pass the return value of function to {{.}}
	t, _ = t.Parse(`
{{define &#34;tp1&#34;}} template one {{end}}
{{define &#34;tp2&#34;}} template two {{.}} {{end}}
{{define &#34;tp3&#34;}} {{template &#34;tp1&#34;}} {{template &#34;tp2&#34;}} {{end}}
{{template &#34;tp1&#34;}}
{{template &#34;tp2&#34; test1}}
{{template &#34;tp3&#34; test1}}
`);
	t.Execute(os.Stdout, nil);
	fmt.Println();
}
</code></pre></div><h4 id=参数和管道>参数和管道</h4><p>前面我们提到过<code>template</code>和<code>include</code>这两个模版action可以有可选的第三个参数来传递数据给内部嵌套模版。其中，模板的参数可以是Go中的基本数据类型，如数字，布尔值，字符串，数组切片或者一个结构体。在模板中设置变量可以使用：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>$variable := value
</code></pre></div><p>Go还有一个特性就是模板的管道函数，熟悉django和jinja的开发者应该很熟悉这种手法。通过定义函数过滤器，实现模板的一些简单格式化处理。并且通过管道哲学，这样的处理方式可以连成一起。<p>例如，模板内置了一些函数，比如格式化输出：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>{{ 3.1415926 | printf &#34;%.3f&#34; }}
</code></pre></div><h4 id=函数>函数</h4><p>既然管道符可以成为模板中的过滤器，那么除了内建的函数，Go Template还支持自定义函数可以扩展模板的功能：<p>在Go Template中定义一个函数分两步：<ol><li>创建一个<code>FuncMap</code>类型的map，key是模板函数的名字，value是其函数的定义<li>将<code>FuncMap</code>注入到模板中</ol><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>func fdate(t time.Time) {
	return t.Format(time.ANSIC)
}

func main() {
	funcMap := template.FuncMap{&#34;fd&#34;: fdate}
	tmpl := template.New(&#34;test&#34;).Funcs(funcMap)
	tmpl = template.Must(t.Parse(`test data: {{ . | fd }}`))
	tmpl.ExecuteTemplate(os.Stdout, &#34;test&#34;, time.Now())
}
</code></pre></div><p>在模板中可以使用<code>{{ . | fd }}</code>，当然也可以不用管道过滤器，而是使用正常的函数调用形式<code>{{ fd . }}</code>。<h2 id=summary>Summary</h2><p>这篇笔记主要通过例子探讨了Go语言模板技术基本语法，包括模版渲染的三个步骤：创建(new)-加载(parse)-渲染(execute)；同时，我们也了解了Go Template中常见的模版标签action来实现复杂的数据展示逻辑。总结起来，Go语言模板技术是注解语法引用数据结构中的元素（例如Struct中的特定feild，Map中的key）并将之应用于定义好的模板中。Go模板技术经常用来处理譬如插入特定数据的文本转化等，虽然没有正则表达式那么灵活，但是渲染速度超过正则表达式，而且使用起来也更简单。</div></div></div></article><script src=https://morven.life/js/highlight.pack.js></script><script src=https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js></script><script src=https://cdn.jsdelivr.net/npm/vanilla-lazyload@10.19.0/dist/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')});</script><script>hljs.initHighlightingOnLoad();var posts=document.getElementById('posts-list');posts&&quicklink({el:posts,priority:true,});</script>