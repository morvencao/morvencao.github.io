<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.80.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Morven's Life"><meta property=og:url content=https://morven.life/posts/writing-robust-shell-scripts/><link rel=canonical href=https://morven.life/posts/writing-robust-shell-scripts/><link rel="shortcut icon" href=https://morven.life/favicon.ico type=image/x-png><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/morven.life\/"},"articleSection":"posts","name":"编写健壮的Shell脚本","headline":"编写健壮的Shell脚本","description":"写Shell脚本应该已经成为程序员必须掌握的技能了。因为Shell脚本简单易上手的特性，在日常工作中，我们经常使用Shell脚本来自动化应用的部署测试，环境的搭建与清理等等。殊不知，Shell脚本也会有各种坑，经常导致Shell脚本因为各种原因不能正常执行成功。实际上，编写健壮可靠的Shell脚本也是有一定的技巧的，今天我们就来一一说明。\nset -euxo pipefail 在执行Shell脚本的时候，通常都会创建一个新的Shell，比如，当我们执行：\nbash script.sh Bash会创建一个新的Shell来执行script.sh，同时也默认给定了这个执行环境的各种参数。set命令可以用来修改Shell环境的运行参数，不带任何参数的set命令，会显示所有的环境变量和Shell函数。对于所有可以定制的运行参数，请查看官方手册，我们重点介绍其中最常用的四个。\nset -x 默认情况下，Shell脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。\nset -x用来在运行结果之前，先输出执行的那一行命令，行首以\u002b表示是命令而非命令输出，同时，每个命令的参数也会展开，我们可以清晰地看到每个命令的运行实参，这对于Shell的debug来说非常友好。\n#!\/bin\/bash set -x v=5 echo $v echo \u0026#34;hello\u0026#34; # output: # \u002b v=5 # \u002b echo 5 # 5 # \u002b echo hello # hello 实际上，set -x还有另一种写法set -o xtrace。\nset -u Shell脚本不像其他高级语言，如Python, Ruby等，Shell脚本默认不提供安全机制，举个简单的例子，Ruby脚本尝试去读取一个没有初始化的变量的内容的时候会报错，而Shell脚本默认不会有任何提示，只是简单地忽略。\n#!\/bin\/bash  echo $v echo \u0026#34;hello\u0026#34; # output: # # hello 可以看到，echo $v输出了一个空行，Bash完全忽略了不存在的$v继续执行后面的命令echo \u0026quot;hello\u0026quot;。这其实并不是开发者想要的行为，对于不存在的变量，脚本应该报错且停止执行来防止错误的叠加。set -u就用来改变这种默认忽略未定义变量行为，脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。\n#!\/bin\/bash set -u echo $a echo bar # output: # .","inLanguage":"en-US","author":"Morven\u0027s Life","creator":"Morven\u0027s Life","publisher":"Morven\u0027s Life","accountablePerson":"Morven\u0027s Life","copyrightHolder":"Morven\u0027s Life","copyrightYear":"2017","datePublished":"2017-02-06 00:00:00 \u002b0000 UTC","dateModified":"2017-02-06 00:00:00 \u002b0000 UTC","url":"https:\/\/morven.life\/posts\/writing-robust-shell-scripts\/","keywords":[]}</script><title>编写健壮的Shell脚本 - Morven's Life</title><meta property=og:title content="编写健壮的Shell脚本 - Morven's Life"><meta property=og:type content=article><meta name=description content='写Shell脚本应该已经成为程序员必须掌握的技能了。因为Shell脚本简单易上手的特性，在日常工作中，我们经常使用Shell脚本来自动化应用的部署测试，环境的搭建与清理等等。殊不知，Shell脚本也会有各种坑，经常导致Shell脚本因为各种原因不能正常执行成功。实际上，编写健壮可靠的Shell脚本也是有一定的技巧的，今天我们就来一一说明。
set -euxo pipefail 在执行Shell脚本的时候，通常都会创建一个新的Shell，比如，当我们执行：
bash script.sh Bash会创建一个新的Shell来执行script.sh，同时也默认给定了这个执行环境的各种参数。set命令可以用来修改Shell环境的运行参数，不带任何参数的set命令，会显示所有的环境变量和Shell函数。对于所有可以定制的运行参数，请查看官方手册，我们重点介绍其中最常用的四个。
set -x 默认情况下，Shell脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。
set -x用来在运行结果之前，先输出执行的那一行命令，行首以+表示是命令而非命令输出，同时，每个命令的参数也会展开，我们可以清晰地看到每个命令的运行实参，这对于Shell的debug来说非常友好。
#!/bin/bash set -x v=5 echo $v echo "hello" # output: # + v=5 # + echo 5 # 5 # + echo hello # hello 实际上，set -x还有另一种写法set -o xtrace。
set -u Shell脚本不像其他高级语言，如Python, Ruby等，Shell脚本默认不提供安全机制，举个简单的例子，Ruby脚本尝试去读取一个没有初始化的变量的内容的时候会报错，而Shell脚本默认不会有任何提示，只是简单地忽略。
#!/bin/bash  echo $v echo "hello" # output: # # hello 可以看到，echo $v输出了一个空行，Bash完全忽略了不存在的$v继续执行后面的命令echo "hello"。这其实并不是开发者想要的行为，对于不存在的变量，脚本应该报错且停止执行来防止错误的叠加。set -u就用来改变这种默认忽略未定义变量行为，脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。
#!/bin/bash set -u echo $a echo bar # output: # .'><link rel=stylesheet href=https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css><link rel=stylesheet href=https://morven.life/css/index.css><link href=https://morven.life/index.xml rel=alternate type=application/rss+xml title="Morven's Life"><script>(function(undefined){}).call('object'===typeof window&&window||'object'===typeof self&&self||'object'===typeof global&&global||{});</script><article class="post 简体中文" id=article><div class=row><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href=https://morven.life/><div class=head-line></div></a><header class=post-header><h1 class=post-title>编写健壮的Shell脚本</h1><div class=row><div class=col-xs-6><time class=post-date datetime="2017-02-06 00:00:00 UTC">06 Feb 2017</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://morven.life/>@Morven's Life</a></div></div></div></header><div class="post-content markdown-body"><p>写Shell脚本应该已经成为程序员必须掌握的技能了。因为Shell脚本简单易上手的特性，在日常工作中，我们经常使用Shell脚本来自动化应用的部署测试，环境的搭建与清理等等。殊不知，Shell脚本也会有各种坑，经常导致Shell脚本因为各种原因不能正常执行成功。实际上，编写健壮可靠的Shell脚本也是有一定的技巧的，今天我们就来一一说明。<h3 id=set--euxo-pipefail><code>set -euxo pipefail</code></h3><p>在执行Shell脚本的时候，通常都会创建一个新的Shell，比如，当我们执行：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>bash script.sh
</code></pre></div><p>Bash会创建一个新的Shell来执行<code>script.sh</code>，同时也默认给定了这个执行环境的各种参数。<code>set</code>命令可以用来修改Shell环境的运行参数，不带任何参数的<code>set</code>命令，会显示所有的环境变量和Shell函数。对于所有可以定制的运行参数，请查看<a href=https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html>官方手册</a>，我们重点介绍其中最常用的四个。<h4 id=set--x><strong>set -x</strong></h4><p>默认情况下，Shell脚本执行后只显示运行结果，不会展示结果是哪一行代码的输出，如果多个命令连续执行，它们的运行结果就会连续输出，导致很难分清一串结果是什么命令产生的。<p><code>set -x</code>用来在运行结果之前，先输出执行的那一行命令，行首以<code>+</code>表示是命令而非命令输出，同时，每个命令的参数也会展开，我们可以清晰地看到每个命令的运行实参，这对于Shell的debug来说非常友好。<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -x

<span style=color:#000>v</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>5</span>
<span style=color:#204a87>echo</span> <span style=color:#000>$v</span>
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic># + v=5</span>
<span style=color:#8f5902;font-style:italic># + echo 5</span>
<span style=color:#8f5902;font-style:italic># 5</span>
<span style=color:#8f5902;font-style:italic># + echo hello</span>
<span style=color:#8f5902;font-style:italic># hello</span>
</code></pre></div><p>实际上，<code>set -x</code>还有另一种写法<code>set -o xtrace</code>。<h4 id=set--u><strong>set -u</strong></h4><p>Shell脚本不像其他高级语言，如Python, Ruby等，Shell脚本默认不提供安全机制，举个简单的例子，Ruby脚本尝试去读取一个没有初始化的变量的内容的时候会报错，而Shell脚本默认不会有任何提示，只是简单地忽略。<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#204a87>echo</span> <span style=color:#000>$v</span>
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic>#</span>
<span style=color:#8f5902;font-style:italic># hello</span>
</code></pre></div><p>可以看到，<code>echo $v</code>输出了一个空行，Bash完全忽略了不存在的<code>$v</code>继续执行后面的命令<code>echo "hello"</code>。这其实并不是开发者想要的行为，对于不存在的变量，脚本应该报错且停止执行来防止错误的叠加。<code>set -u</code>就用来改变这种默认忽略未定义变量行为，脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -u

<span style=color:#204a87>echo</span> <span style=color:#000>$a</span>
<span style=color:#204a87>echo</span> bar

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic># ./script.sh: line 4: v: unbound variable</span>
</code></pre></div><p><code>set -u</code>另一种写法是<code>set -o nounset</code><h4 id=set--e><strong>set -e</strong></h4><p>对于默认的Shell脚本运行环境，有运行失败的命令（返回值非0），Bash会继续执行后面的命令：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span>
unknowncmd
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic># ./script.sh: line 3: unknowncmd: command not found</span>
<span style=color:#8f5902;font-style:italic># hello</span>
</code></pre></div><p>可以看到，Bash只是显示有错误，接着继续执行Shell脚本，这种行为很不利于脚本安全和排错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>command || exit 1
</code></pre></div><p>上面的写法表示只要<code>command</code>有非零返回值，Shell脚本就会停止执行。如果停止执行之前需要完成多个操作，就要采用下面三种更高级的写法：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>command || { echo &#34;command failed&#34;; exit 1; }

if ! command; then echo &#34;command failed&#34;; exit 1; fi

command
if [ &#34;$?&#34; -ne 0 ]; then echo &#34;command failed&#34;; exit 1; fi
</code></pre></div><p>此外，我们就联想到另外一种很类似的用法，如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>command1 &amp;&amp; command2
</code></pre></div><p>但是这些技巧多少有些麻烦，容易疏忽。而<code>set -e</code>从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e

unknowncmd
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic># ./script.sh: line 4: unknowncmd: command not found</span>
</code></pre></div><p>可以看到，第4行执行失败以后，脚本就终止执行了。<p><code>set -e</code>根据命令的返回值来判断命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e

<span style=color:#204a87;font-weight:700>$(</span>ls foobar<span style=color:#204a87;font-weight:700>)</span>
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic># ls: cannot access &#39;foobar&#39;: No such file or directory</span>
</code></pre></div><p>可以看到，打开<code>set -e</code>之后，即使<code>ls</code>是一个已存在的命令，但因为<code>ls</code>命令的运行参数<code>foobar</code>实际上并不存在导致命令的返回非0值，这有时候并不是我们看到的。<p>可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e

<span style=color:#204a87>set</span> +e
<span style=color:#204a87;font-weight:700>$(</span>ls foobar<span style=color:#204a87;font-weight:700>)</span>
<span style=color:#204a87>set</span> -e

<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic># ls: cannot access &#39;foobar&#39;: No such file or directory</span>
<span style=color:#8f5902;font-style:italic># hello</span>
</code></pre></div><p>上面代码中，<code>set +e</code>表示关闭<code>-e</code>选项，<code>set -e</code>表示重新打开<code>-e</code>选项。<p>还有一种方法是使用<code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。<p><code>set -e</code>还有另一种写法<code>set -o errexit</code>。<h4 id=set--o-pipefail><strong>set -o pipefail</strong></h4><p><code>set -e</code>有一个例外情况，就是不适用于管道命令。对于管道命令，Bash会把最后一个子命令的返回值作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。<p>请看下面这个例子。<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e

foo <span style=color:#000;font-weight:700>|</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;bar&#34;</span>
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic># ./script.sh: line 4: foo: command not found</span>
<span style=color:#8f5902;font-style:italic># bar</span>
<span style=color:#8f5902;font-style:italic># hello</span>
</code></pre></div><p>可以看到，<code>foo</code>是一个不存在的命令，但是<code>foo | echo bar</code>这个管道命令还是会执行成功，导致后面的<code>echo hello</code>会继续执行。<p><code>set -o pipefail</code>用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=color:#8f5902;font-style:italic>#!/bin/bash
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87>set</span> -e
<span style=color:#204a87>set</span> -o pipefail

foo <span style=color:#000;font-weight:700>|</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;bar&#34;</span>
<span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;hello&#34;</span>

<span style=color:#8f5902;font-style:italic># output:</span>
<span style=color:#8f5902;font-style:italic># ./script.sh: line 5: foo: command not found</span>
<span style=color:#8f5902;font-style:italic># bar</span>
</code></pre></div><p>可以看到，<code>echo hello</code>命令并没有执行。<h4 id=合并四个参数><strong>合并四个参数</strong></h4><p>对于上面提到的四个<code>set</code>命令参数，一般都放在一起使用。<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback># 写法一
set -euxo pipefail

# 写法二
set -eux
set -o pipefail
</code></pre></div><p>这两种写法任选其一放在所有Shell脚本的头部。<p>当然，也可以在在执行Shell脚本的时候，从Bash命令行传入这些参数：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>bash -euxo pipefail script.sh
</code></pre></div><h3 id=shell脚本防御式编程>Shell脚本防御式编程</h3><p>编写Shell脚本的时候应该考虑不可预期的程序输入，如文件不存在或者目录没有创建成功&mldr;其实Shell命令有很多选项可以解决这类问题，例如，使用<code>mkdir</code>创建目录的时候，如果父目录不存在，<code>mkdir</code>默认返回错误，但如果加上<code>-p</code>选项，<code>mkdir</code>在父目录不存在的情况下先创建父目录；<code>rm</code>在删除一个不存在的文件会失败，但如果加上<code>-f</code>选项，即使文件不能存在也能执行成功。<p><strong>注意字符串中的空格</strong><p>我们必须时刻注意字符串中的空格字符，如文件名中的空格，命令参数中的空格等等，对于这些空格字符安全的最佳时实践是使用<code>"</code>括住相应的字符串：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback># will fail if $filename contains spaces
if [ $filename = &#34;foo&#34; ];


# will success even if $filename contains spaces
if [ &#34;$filename&#34; = &#34;foo&#34; ];
</code></pre></div><p>Someone will always use spaces in filenames or command line arguments and you should keep this in mind when writing shell scripts. In particular you should use quotes around variables.<p>if [ $filename = &ldquo;foo&rdquo; ];
will fail if $filename contains a space. This can be fixed by using:<p>if [ &ldquo;$filename&rdquo; = &ldquo;foo&rdquo; ];<p>类似的情况是，我们在使用<code>$@</code>或者其他包含由空格分割的多个字符串也要注意使用<code>"</code>括住相应的变量，实际上，使用<code>"</code>括住相应的变量没有任何副作用，只会是我们的Shell脚本更加健壮：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>foo() { for i in $@; do printf &#34;%s\n&#34; &#34;$i&#34;; done }; foo bar &#34;baz quux&#34;
bar
baz
quux

foo() { for i in &#34;$@&#34;; do printf &#34;%s\n&#34; &#34;$i&#34;; done }; foo bar &#34;baz quux&#34;
bar
baz quux
</code></pre></div><h3 id=使用trap命令>使用trap命令</h3><p>关于Shell脚本一个常见的情况是，脚本执行失败导致文件系统处于不一致的状态，比如文件锁、临时文件或者Shell脚本的错误只更新了部分文件。为了达到“事务的完整性”我们需要解决这些不一致的问题，要么删除文件锁、临时文件，要么将状态恢复到更新之前的状态。实际上，Shell脚本确实提供了一种在捕捉到特定的unix信号的情况下执行一段命令或者函数的功能：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>trap command signal [signal ...]
</code></pre></div><p>其实Shell脚本可以捕捉很多类型的信号（完整信号列表可以使用<code>kill -l</code>命令获取），但是我们通常只关心在问题发生之后用来恢复现场的三种信号：<code>INT</code>，<code>TERM</code>和<code>EXIT</code><table><thead><tr><th>Signal<th>Description<tbody><tr><td>INT<td>Interrupt – this signal is sent when someone kills the script by pressing <code>ctrl-c</code><tr><td>TERM<td>Terminate – this signal is sent when someone sends the TERM signal using the kill command<tr><td>EXIT<td>Exit – this is a pseudo-signal and is triggered when your script exits, either through reaching the end of the script, an exit command or by a command failing when using <code>set -e</code></table><p>一般情况下，我们在操作对应的共享区之前先创建文件锁：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>if [ ! -e $lockfile ]; then
    touch $lockfile
    critical-section
    rm $lockfile
else
    echo &#34;critical-section is already running&#34;
fi
</code></pre></div><p>但是当Shell脚本操作对应的共享区的时候有人手动Kill掉对应的Shell脚本进程，这个时候文件锁的存在会导致Shell脚本不能再次操作对应的共享区。使用trap我们可以捕捉到对应的Kill信号并做相应的恢复操作：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>if [ ! -e $lockfile ]; then
    trap &#34;rm -f $lockfile; exit&#34; INT TErm EXIT
    touch $lockfile
    $lockfile
    rm $lockfile
    trap - INT TErm EXIT
else
    echo &#34;critical-section is already running&#34;
fi
</code></pre></div><p>有了上面这段trap命令，即使当Shell脚本操作对应的共享区的时候有人手动Kill掉对应的Shell脚本进程，文件锁也会被清理干净。需要注意的是，我们在捕捉到Kill信号之后删除完文件锁之后直接退出而不是继续执行。<h3 id=be-atomic>Be Atomic</h3><p>很多时候我们需要一次更新一批文件，但是有可能在更新了一半之后Shell脚本出错或者有人kill掉了Shell脚本的进程。你可能会想到，就使用刚才学到的trap知识，同时对就文件做备份，一旦捕捉到出错的信号，就恢复备份。这看起来没错，但是很多时候只能解决一部分的问题。例如，我们要把一个网站里面的URL从<code>www.example.org</code>全部更新为<code>www.example.com</code>，Shell脚本的主要逻辑类似于这样：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>for file in $(find /var/www -type f -name &#34;*.html&#34;); do
    perl -pi -e &#39;s/www.example.org/www.example.com/&#39; $file
done
</code></pre></div><p>正确的做法是尽量使更新操作原子化，实现操作的“事务一致性”：1. 拷贝旧目录；2. 在拷贝的目录中进行更新操作；3. 替换原目录<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>cp -a /var/www /var/www-tmp
for file in $(find /var/www-tmp -type f -name &#34;*.html&#34;); do
   perl -pi -e &#39;s/www.example.org/www.example.com/&#39; $file
done
mv /var/www /var/www-old
mv /var/www-tmp /var/www
</code></pre></div><p>在类Unix文件系统上进行最后的两次<code>mv</code>操作是非常快的（因为只需要替换两个目录的<code>inode</code>，而不用执行实际的拷贝操作），换句话说，容易出错的地方是批量的更新操作，而我们将更新操作全部在拷贝的目录中执行，这样，更新操作即使出错，也不会影响原目录。这里的技巧是，使用双倍的硬盘空间来进行操作，任何是需要长时间打开文件的操作都是在备份目录中进行。事实上，保持一系列操作的原子性对于某些容易出错的Shell脚本来说非常重要，同时操作前备份文件也是一个好的编程习惯。</div></div></div></article><script src=https://morven.life/js/highlight.pack.js></script><script src=https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js></script><script src=https://cdn.jsdelivr.net/npm/vanilla-lazyload@10.19.0/dist/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')});</script><script>hljs.initHighlightingOnLoad();var posts=document.getElementById('posts-list');posts&&quicklink({el:posts,priority:true,});</script>