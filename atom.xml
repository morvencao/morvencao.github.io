<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Morven&#39;s Life</title>
    <link>https://morven.life/</link>
    <description>Recent content on Morven&#39;s Life</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Oct 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://morven.life/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>创建最小的docker镜像</title>
      <link>https://morven.life/posts/build_the_smallest_possible_docker_image/</link>
      <pubDate>Tue, 02 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/build_the_smallest_possible_docker_image/</guid>
      <description>如果你熟悉docker，你可能知道docker镜像存储使用Union FS分层存储技术。在构建一个docker镜像时，会一层一层构建，前一层是后一层的基础，每一层构建完成之后就不会再改变。正是因为这一点，我们在构建docker镜像的时候，要特别小心，每一层尽量只包含需要的东西，构建应用额外的东西尽量在构建结束的时候删除。举例来说，比如你在构建一个go写的简单web应用程序的时候，原则上只需要一个go编译出来的binary，没有必要保留构建的工具以及环境。
docker官方提供了一个特殊的空镜像scratch,使用这个镜像意味着我们不需要任何的已有镜像为基础，直接将我们自定义的指令作为镜像的第一层。
FROM scratch ...  实际上，我们可以创建自己的scratch镜像：
tar cv --files-from /dev/null | docker import - scratch  那么，问题来了，我们可以使用scratch镜像为基础制作哪些镜像呢？答案是所有不需要任何依赖库的可执行文件都可以放到以scratch为基础镜像来制作。具体来说，对于linux下静态编译的程序来说，并不需要操作系统提供的运行时支持，所有需要的一切都已经在可执行文件中包含了，比如使用go语言开发的很多应用会使用直接FROM scratch的方式制作镜像，这样最终的镜像体积非常小。
下面是一个简单的go语言开发的web程序代码：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; ) func main() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello, you&#39;ve requested: %s\n&amp;quot;, r.URL.Path) }) http.ListenAndServe(&amp;quot;:80&amp;quot;, nil) }  我们可以使用go build来编译此程序，并以scratch为基础制作docker镜像，dockerfile如下：
FROM scratch ADD helloworld / CMD [&amp;quot;/helloworld&amp;quot;]  接下来开始编译并构建docker镜像：
mc@mcmbp:~/gocode/src/hello# go build -o helloworld mc@mcmbp:~/gocode/src/hello# docker build -t helloworld .</description>
    </item>
    
    <item>
      <title>又是冬至日</title>
      <link>https://morven.life/posts/thoughts_in_winter_solstice/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/thoughts_in_winter_solstice/</guid>
      <description>冬至已到，也该向2017告别了。
最近时常酝酿着写写2017年，但到真正提笔的时候却无从下手。2017年，我一直很努力，却总是停留在原地。该离开的终究没有留下来，该坚持的还是半途而废。
2017发生了很多事，心情一直处于低谷，时常在深邃的夜晚开始怀疑自己当初的选择。理想、信念和情感&amp;hellip;所有种种陪伴了自己青春岁月的精神支撑，在这冰冷冷的，麻木的，毫无人性的现实世界里显得沧桑而无力。可能是自己过于“玻璃心”，也经常被家人评价“不成熟”的标签。
不是我无法承受现实世界的洗礼，我只是想按照自己的方式来生活。仔细想想，这些年虽然变化不少，但自己始终是个理想主义斗士。
以前的我有自己的原则，却没有太多的阅历，此外，行动力也不太够，但是仍然对这个世界充满向往。 而现在的我，却因为短期内见过太多社会的黑暗面，变得无法坚持自己的信念而变得愤世嫉俗，因为我内心的良知让我无法和这个有美好也有丑陋的世界和解。
我在无数个夜晚想象着自己回到过去，用纯粹的对世界的热情感染早已麻木的自己，提醒自己世界上还有正义，原则还有信念等一众美好的东西。
我也想拥有一台时光机器，回到过去。用自己的经历和行动力，告诫尚处于十字路口的自己坚定自己正确的选择。而不是在理想的分崩离析中不断回味那些外表逐渐模糊但内在却深入骨髓而不能磨灭的印记。
不管2017年对我来说是多么tough的一年，毫无疑问，它也将会成为我永远都铭记和感恩的一年。
希望在即将到来的2018年里，不要再掉进自己思想的漩涡里，重新拿回了生活的主导权，不忘初心，坚持梦想。
  人生几回仿往事，山形依旧枕寒流。 ——刘禹锡《西塞山怀志》   </description>
    </item>
    
    <item>
      <title>十年，火影</title>
      <link>https://morven.life/posts/ten-years-for-naruto/</link>
      <pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/ten-years-for-naruto/</guid>
      <description>去年听到火影忍者漫画完结的时候，心里是极其复杂的。急于见证万年吊车尾主人公鸣人的结局，却更多地是对于十年青春陪伴的不舍。
第一次见到火影是一个黄头发中二少年踩着树杈飞来飞去，身后跟着几个小屁孩嘴里大叫着佐助。当时觉得这种需要按着牛顿棺材板才能看的动漫实在无聊，但是正值高中紧张复习期间，偶尔用MP4从同学那里拷几集看来缓减一下压力。
第一次看到“复制忍者”旗木卡卡西VS原雾隐村“忍刀七人众”之一桃地再不斩的场景，被各种各样的结印手势以及高潮迭起的剧情吸引得神魂颠倒。旗木卡卡西，年仅12岁时就成为上忍的天才，火之国木叶隐村的精英上忍，原木叶暗部成员，四代目火影波风水门的弟子，木叶第七班队长，漩涡鸣人、宇智波佐助、春野樱的指导老师。后左眼成为宇智波带土赠予的写轮眼，因使用写轮眼复制了上千种忍术而被称为“拷贝忍者”。桃地再不斩，断刀&amp;rdquo;斩首大刀&amp;rdquo;的使用者，充满野心、铁血，但并不是无情无义的人，精通水遁忍术和暗杀术，因策划暗杀水影失败而逃离村子，成为叛忍，收留了白。两人实力相近，却有着不同的目标，经过几番焦灼战斗，最后在漫天的飞雪中，当再不斩死在白的身边时，流着泪说道：“如果可以的话，真想和你去同一个地方。”，而与此同时，一颗雪花的结晶则因为白刚刚死去时残留的体温而在白的眼角融化流下，仿佛印证了再不斩那句“白，是你在哭泣么？”，再配上背景音乐——钢琴版“Sadness and Sorrow”，​最终，这成为火影里最初也是最让人感动以及震撼的画面。
久而久之，却对剧情充满期待，开始对万年吊车尾鸣人的未来越来越感兴趣。漩涡鸣人，见证了白心甘情愿为再不斩牺牲，感同身受地与我爱罗诉说着相同的过去，将佐助视为最重要的羁绊，为了对小樱的承诺，拼尽全力追回佐助，独自练习着更强的忍术，为自己的父母深深地感到骄傲，更想用爱感化九尾，他所经历的一切，都为他贯彻自己的忍道。正是印证了鼬所说的“不是当上火影的人才能得到认可，只有得到大家的认可才能当上火影”。
其实不止主人公，火影里面每个人物都是栩栩如生。 实力又神秘，帅气又低调，漫不经心又可靠，冷酷中还有温暖的天才忍者旗木卡卡西。 高冷而睿智，隐秘而伟大，残忍却温柔，怀揣光明于黑暗中独自行走的最完美忍者宇智波鼬。 猥琐好色而真性情，荒诞不羁却坚韧刚强，洒脱随和而正气凛然，推动整个火影进程的自来也老师。 &amp;hellip;
我想火影完结对我来说不是件过于悲伤的事，尽管那天听到消息的我真的有种不可填补的缺失感，但是关于鸣人的故事暂时告一段落，但新的故事还在延续，更何况我们还有高梨康治大师级的音乐。每个人都有自己的人生，无论振作拼搏，还是颓废懈怠，时间终会带走一切，我们能留下的，只是种子，就像火影的种子早已埋在心底，何时发芽？也许明天，也许……就是现在。</description>
    </item>
    
    <item>
      <title>毕业这两年</title>
      <link>https://morven.life/posts/the-two-years/</link>
      <pubDate>Tue, 20 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/the-two-years/</guid>
      <description>步入6月，一场青春的盛宴，如期而至，这场盛宴的主题，是毕业。我虽早已是这场盛宴之外的人，但看到微博上在校同学们的种种分享，仿佛是在提醒自己：WTF, 你都毕业两年了！
是啊，我毕业都两年了！
想到这个，心中难免感慨万千，但是要谈谈这万千感慨，却又不知从何说起，真有一种情深而何以往之的感觉！
毕业这两年，让我渐渐感到陌生的，是自己。我似乎已经越来越不清楚自己是谁，越来越不知道该往何方。我时而追忆大学时代的那个自己，以寻求一点自我的慰藉。当慰藉醒来，我梦让发现，和过去的自己相比，我此时整个的生命轨迹，正在下陷。
大学时的那个我，总得而言，是一个乐于奉献、敢于担当的人。从大一入学之处欢呼雀跃，奔走于各个社团之间，到研究生逃离实验室，和几个“疯狂的哥们儿”整天呆在破烂不堪的写字楼里创业，那时候感觉自己还能“输得起”，所以做什么事情都不惧困难，在别人看来那是“不务正业”，自己却乐此不彼。
但是从毕业到现在的这两年的经历，显然让我感觉到自己正处于人生的低谷。当然，并不是我现在的处境有多么的不堪，而是精神上“斗志泯灭”。回头看看那个曾经有着纯高理想追求，并定会为之奋斗的自己，如今正处于一种“望风披靡”，追求“息事宁人”的状态。
毕业这两年，我一直就职于同一家公司，两年前的今天，我期待着可以顺风顺水地“大干一番”，毕竟公司肯定期待纯粹的技术出生，坚持技术路线的新鲜血液。的确，我投入了极大的热情，也获得了良好的发展。但是由于某种原因，公司一直处于”不稳定期“，自己也努力适应公司公司的转变策略。这样的好处是很明显的，经过几次的变化，虽然职位再三调整，但自己已经适应公司工作环境，也接触了目前各个产品线上的研发同事，合作也非常愉快，显然，公司需要这样能跟着公司战略转变的员工。然而，经过几轮的变化，自己心态早已从之前的“主动学习”，“积极探索”转变到“随波追流”，追求“完成自己分内工作就行”。我不知道这种变化是一种普遍现象，还是我自己开始濒临堕落边缘。
对工作没有了开始时的热情，问题到底处在哪里？整个而言，我现在仍然处于一个迷茫期，前路漫漫，不知所以。
虽然很多的事还没有想清楚，但并不意味着活得糊涂。我这两年虽然让自己的一些有点沉寂了，但是很多东西，我依然在坚持。坚持对善的向往，坚持对独立人格的向往，坚持读书学习思考，时刻保持着对人生观与价值观的自信。暂时得不到太多，只能好好坚持一些自认为可贵的东西，唯有坚持，才有改变的可能。</description>
    </item>
    
    <item>
      <title>后会无期，2016</title>
      <link>https://morven.life/posts/farewell-2016/</link>
      <pubDate>Sun, 18 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/farewell-2016/</guid>
      <description> 2016年，很长又很短。 大学毕业，拼命折腾。 概括起来，三言两语便是全部，往细里谈，三天三夜也不够。 但我还是要写，有些情感，只能用文字表达，有些思考，在笔尖之下才会刻骨铭心。
生活 从参加工作到现在，差不多一年多了。这期间的大部分时间我都一个人住着。每天早上睡到自然醒，洗脸刷牙，心情好楼下买个早点，然后悠哉悠哉地走到公司。下班不用急着回家，独自呆在电脑前听听歌，看看书。肚子饿的时候去公司周围吃个晚饭，然后沿着公园慢慢哟哟地走回家，天气好的话去公园旁边的球场打打球。回到家后，洗完澡看看书，刷会儿知乎，偶尔来个葛优瘫追追美剧。平时要是有人约个饭局的话就跟几个关系不错的哥们儿一起吃个饭，然后各回各家。
我这人不太合群，不喜欢热闹。除了碍于情面上的应酬，大多时候我都喜欢一个人呆着。我比较享受这种独自生活的状态。看书，听歌，看电影，玩手机，或者沏一杯茶然后发呆愣神的呆着，我都很喜欢。下半年开始，星巴克成为我出没的第三场所-公司、家之外最好的选择。经常在星巴克看到聋哑人的聚会，围成一桌用手语沟通，还看到过织毛衣的女人，都觉得蛮温暖的。我有时会点杯喝的打开笔电戴着耳机一坐一下午甚至一整天。我始终都觉得，只有当一个人的时候，才能听到自己内心的声音，才有一个好的状态去想明白一些事情。外界纷扰反而会容易让人失去判断和自我意识。
工作 一直在思考，自己到底适合做什么样的开发岗位。从大学本科阶段的被动接受计算机知识的阶段，到研究生期间主动涉猎计算机各方面知识，从最初的汇编语言与C，到面向对象语言，再到函数式编程，从小型单片机与操作系统到大型分布式系统缓存／并发的设计与实现。我一直没有停止学习，总想着扩展自己的技术栈，打造枝繁叶茂的技能树，却没有沉下心去专攻某项技能。总关注于横向领域的扩充，却忽略技能纵向深度的延伸。
从这方面来讲，2016年确实是等待以及转身的重要节点。因为经历多次工作角色的转变，终于找到最适合自己的工作方向。说实话，之前没有想过自己会从事前端开发，毕竟发展速度太快，每天都有新的轮子出现，难免不会迷失在其中。但是真正接过这个角色之后，就不要想那么多，我才27岁又不是72岁，既然入了这一行，就要有这一行的“匠人”精神。说实话，我一直也没认为IT这一行多么了不起，我们从事这一行只不过是个普通的“手艺人”，经历多年打磨自己的大脑，只有足够优秀才能制作出好的作品。但也正是因为如此，我们可以尽情发挥自己的创意。
从2016年4月开始，开始弥补自己前段领域的空白：从HTML到Jade，从CSS到Less／Sass，从Javascript到Typescript，从jQuery到Angular，从Grunt到Webpack&amp;hellip;虽然自己之前也略有涉猎前端知识，但对完整的前端技术栈知识略知皮毛。从最初的简单地写写页面到现在轻松构建整个项目框架，偶尔写个‘轮子’提供产品的个性化需求解决方案。回过头来看，这一年一路走来，发现自己的兴趣所在，沉下心去思考，研究，虽然踩了很多坑，但也收获颇丰。现在大部分人对于前段的认识还停留在‘刀耕火种’的阶段，其实这几年前端领域的快速发展导致前端工程化已经成为不可逆转的趋势。
梦想  我们走再远，终归难违初心所在。
 曾经的自己大部分时间都处于的奋斗的状态，放弃了生活的品质。如今独自生活后才发现，人一定要活在自己的气场里，才能做什么都舒心。埋头做事没什么不可，但久而久之生活里会充斥着现实的土腥味，偶尔跳出来做做自己喜欢的事，会让本就不好过的日子幸福很多。
最基本的作为自己必须培养一些爱好，必须做到一觉醒来清楚至少今天还能干什么。是去球场挥汗如雨？去找个知心老友唠嗑？还是制定一天内该吸收的知识？这些都行，自己必须做到积攒这种微小的期待和快乐，这样才不会被遥不可及的梦和无法掌控的爱给拖垮。
作为产品的创造者，总是梦想着有朝一日能有自己的优秀作品问世，自己设计，自己实现，自己运维。不期待能有成千上万的用户，不奢求能带来万贯的财富。所以，一直保持着一种虚心学习的态度，对自己、对产品。这是一个修炼的过程，若有懈怠或者失去警醒，就会距离创造伟大的产品，愈来愈远。
对2017年的展望 总的来说，2016年对我来说，还算满意。没有忘记自己的初心，也在不断获取想得到的东西，这比迷失自我的成功更难得吧。希望2017年继续保持这种状态，勿骄勿燥。
 多接触移动端开发领域，不管是iOS还是Android 系统学习UI／UX方面的知识 参加些前端以及Design方面的线下聚会 多读些历史人文方面的书籍 保持健康的生活习惯 带着相机出去走走  </description>
    </item>
    
    <item>
      <title>webpack使用小结</title>
      <link>https://morven.life/notes/webpack_summary/</link>
      <pubDate>Sun, 20 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/notes/webpack_summary/</guid>
      <description>分而治之是软件工程领域的重要思想，对于复杂度日益增加的前端也同样适用。一般前端团队选择合适的框架之后就要开始考虑开发维护的效率问题。而模块化是目前前端领域比较流行的分而治之手段。 Javascript模块化已经有很多规范和工具，例如CommonJS/AMD/requireJS/CMD/ES6 Module，在上篇文章中有详细的介绍。CSS模块化基本要依靠Less, Sass以及Stylus等于处理器的import/minxin特性实现。而HTML以及HTML模版和其他资源比如图片的模块化怎么去处理呢？ 这也正是webpack要解决的问题之一。严格来说，webpack是一个模块打包工具（module bundler），它既不像requireJS和seaJS这样的模块加载器，也不像grunt和gulp这样优化前端开发流程的构建工具，像是两类工具的集合却又远不止如此。
Webpack是一个模块打包工具，它将JS、CSS、HTML以及图片等都视为模块资源，这些模块资源必然存在某种依赖关系，webpack就是通过静态分析各种模块文件之间的依赖关系，通过不同种类的Loader将所有模块打包成起来。
webpack VS Gulp 严格来说，Gulp与webpack并没有可比性。Gulp应该和Grunt属于同一类工具，能够优化前端工作流程，比如压缩合并JS、CSS ，预编译Typescript、Sass等。也就是说，我们可以根据需要配置插件，就可以将之前需要手动完成的任务自动化。webpack作为模块打包工具，可以和browserify相提并论。两者都是预编译模块化解决方案。相比requireJS、seaJS这类‘在线’模块化方案更加智能。因为是‘预编译’，不需要在浏览器中加载解释器。另外，你可以直接在本地编写JS，不管是 AMD / CMD / ES6 风格的模块化，都编译成浏览器认识的JS。
总之，Gulp只是一个流程构建工具，而webpack、browserify等是模块化解决方案。Gulp也可以配置seaJS、requireJS甚至webpack的插件。
避免多个配置文件 刚开始接触webpack的时候，不管是去浏览GitHub上面star数较多的webpack项目，还是搜索stack overflow上面赞成数较多的回答，发现很多人提倡在一个项目中针对开发和产品发布提供不同的配置文件，比如webpack.dev.config.js和webpack.prod.config.js。看起来很清晰，也可以让新手迅速上手老项目，但仔细研究就会发现，不通环境的配置文件大部分配置项基本相同。这与工程领域一直提倡的DRY（Don&amp;rsquo;t Repeat Yourself）原则相悖，于是就产生了另外一种做法，先生成一个common的webpack.common.config.js，然后再针对不同的环境去继承（其实就是require）common的配置文件。但是不管怎样，其实都是生成多个不同的配置文件。如果换个角度想想，这些配置文件虽然不同，但都遵循着node的逻辑，所以完全可以只维护一个配置文件，然后针对不同的环境传入不同的参数。如果你使用npm，则完全可以在package.json文件中这样写：
&amp;quot;scripts&amp;quot;: { &amp;quot;devs&amp;quot;: &amp;quot;cross-env DEV=1 webpack-dev-server --hot --inline&amp;quot;, &amp;quot;build&amp;quot;: &amp;quot;cross-env PROD=1 rm -rf ./build &amp;amp;&amp;amp; webpack --p&amp;quot; }  其中cross-env是个跨平台的环境变量设置工具，可以允许Unix风格环境变量设置通用在window平台。 这样只维护一个webpack.config.js配置文件，然后在配置文件中处理自定义的参数。怎么处理自定义参数呢？这里我们使用webpack自带插件definePlugin提供魔力变量（magic globals）来处理：
plugins: [ new webpack.DefinePlugin ({ __DEV__: JSON.stringify(JSON.parse(process.env.DEV || &#39;false&#39;)), __PROD__: JSON.stringify(JSON.parse(process.env.PROD || &#39;false&#39;)) }) ]  然后在配置文件的其他地方就可以根据设定的环境变量更有针对性地配置不同插件等。甚至在业务逻辑中也可以这样针对不同环境做针对性地调试，比如在开发环境下可以AJAX可以调试本地mock数据，然后在发布的时候，可以正常访问服务端数据。
if (__DEV__) { // code for dev //.</description>
    </item>
    
    <item>
      <title>Javascript模块化开发</title>
      <link>https://morven.life/notes/developing-modular-javascript/</link>
      <pubDate>Sun, 16 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/notes/developing-modular-javascript/</guid>
      <description>随着互联网时代的到来，前端技术更新速度越来越快。起初只要在script标签中嵌入几行代码就能实现一些基本的用户交互，到现在随着Ajax，jQuery，MVC以及MVVM的发展，Javascript代码量变得日益庞大复杂。 网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等&amp;hellip;&amp;hellip;开发者不得不使用软件工程的方法，管理网页的业务逻辑。 Javascript模块化开发，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。 但是，Javascript不是一种模块化编程语言，它不支持&amp;rdquo;类&amp;rdquo;（class），更遑论&amp;rdquo;模块&amp;rdquo;（module）了。直到前不久ES6正式定稿，Javascript才开始正式支持&amp;rdquo;类&amp;rdquo;和&amp;rdquo;模块&amp;rdquo;，但还需要很长时间才能完全投入实用。
什么是模块化 模块是任何大型应用程序架构中不可缺少的一部分，一个模块就是实现特定功能的代码区块或者文件。模块可以使我们清晰地分离和组织项目中的代码单元。在项目开发中，通过移除依赖，松耦合可以使应用程序的可维护性更强。有了模块，开发者就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就会混乱不堪。
Javascript社区做了很多努力，在现有的运行环境中，实现&amp;rdquo;模块&amp;rdquo;的效果。本文总结了当前＂Javascript模块化编程＂的最佳实践，说明如何投入实用。
Javascript模块化基本写法 在第一部分，将讨论基于传统Javascript语法的模块化写法。
原始写法 模块就是实现特定功能的一组方法。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。
function func1(){ //... } function func2(){ //... }  上面的函数func1()和func2()，组成一个模块。使用的时候，直接调用就行了。 这种做法的缺点很明显：&amp;rdquo;污染&amp;rdquo;了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。
对象写法 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。
var moduleA = new Object({ _count : 0, func1 : function (){ //... }, func2 : function (){ //... } });  上面的函数func1()和func2(），都封装在moduleA对象里。使用的时候，就是调用这个对象的属性。
moduleA.func1();  但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。
moduleA._count = 3;  立即执行函数写法 使用&amp;rdquo;立即执行函数&amp;rdquo;（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。
var moduleA = (function(){ var _count = 0; var func1 = function(){ //.</description>
    </item>
    
    <item>
      <title>写在2015年年末</title>
      <link>https://morven.life/posts/post_at_the_end_of_2015/</link>
      <pubDate>Tue, 29 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/post_at_the_end_of_2015/</guid>
      <description> 2015年马上就要过去了。一年一年是如此相似，一年一年却有如此不同。每到年底总想写点什么，算是给自己的一个总结、一个回忆、一个自我述说的快乐。 2015年像很多年份一样是平常的，按部就班地数着日子过去了，虽然忙碌，但收获颇多。2015年又是不平常的，因为2015年是我正式告别学校踏入&amp;rdquo;江湖&amp;rdquo;的第一年。2015年对我来说，关键字有驾证，毕业以及入职。
驾证 之前总是一拖再拖，这次真是没法再推了。于是拉了宿舍一哥们儿入坑，组团报名。银子花出去之后便有了动力。从科目一理论到科目二场地考，再到科目三大路考，每周一到周四5点多爬起来赶班车去驾校练车。中午赶回来吃过饭休息之后再去实验室赶论文。还好，全部都一把过，算是对自己的慰藉吧。那几个月下来，认识了很多学车的同学，大多是即将毕业离开南京的学生，而且还认识了个南艺学珠宝设计的妹子（坏笑&amp;hellip;）。那段日子也确实是痛并快乐着，导致拿到驾照之后得了学车后遗症，每天早上天还没亮就睡不着了。学车本不是什么难事儿，只要安排得到，拿到驾照还是挺容易的，也不用为了考试顺利而铤而走险，贿赂教练或考官。
毕业 又毕业了，这一次是真的毕业了。研究生毕业答辩明显比本科毕业答辩阶段严格得多，所以投入了更多的时间在论文上。庆幸自己有个好导师，选题也不错，所以答辩比较顺利。毕业典礼没有本科那么正式，辅导员只是选了一些同学去参加，毕业合影部分同学的脸也是p上去的。临近毕业那段时间各种手续要办，又是档案又是户口&amp;hellip;不过总能抽出时间和室友开黑。直到离校当晚，拉着行李箱准备走出鼓楼校区，走在广州路熙熙攘攘的人群中才知道，这次不是回家，这次真要离开了，下次再来不知道是什么时候了。
入职 毕业后回家休息不到一个月正式入职。入职前一周收到HR发给我的入职材料列表，发现缺了‘无犯罪记录’证明，当时懵了，因为这材料需要回学校保卫科去办。还好，联系到了在南京的同学和辅导员，虽然麻烦，但还是搞定了。接下来就是正式入职，因为之前也有在IBM 上海Office实习的经历，对IBM的总体情况和公司文化比较了解，所以和同事融入较快。但是计划赶不上变化，我的hiring manager所在的部门研发计划有变，导致不需要太多的dev，所以就被transfer到其他的team，不过这几个team所做的产品相关性非常高，知识技术上稍有不同。IBM西安office主要做的产品是高性能计算相关，主要的核心产品要两款，其他的产品都是作为其add-on。技术的选择上java多一些，在core方面会有C&amp;amp;C++。令我不太满意的地方是，工作中对业务的熟悉程度远大于对技术的熟练上，这可能是大商业公司的通病。
对2016的期待 又到了许愿时间了。要做也要做有梦想的咸鱼～～
 希望能去自己感兴趣的team，做自己感兴趣的事儿。 希望抽出更多的时间看书，学习以及写博客。 希望能多在工作中和外籍同事交流，锻炼自己的口语。 希望坚持体育锻炼，一周跑两次步，周末打一次球。 希望感情能够稳定下来。  </description>
    </item>
    
    <item>
      <title>Dota中的Ban&amp;Pick机制与陪审团</title>
      <link>https://morven.life/posts/ban-pick_in_dota_and_jury/</link>
      <pubDate>Fri, 09 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/ban-pick_in_dota_and_jury/</guid>
      <description>Dota(Defense of the Ancients)最初只是由《魔兽争霸3：冰封王座》的一个RPG地图衍变而来，是一款支持多人即时对战的战略游戏。最早的Dota地图则在混乱之治时代就出现了，一位叫做Euls的玩家制作了第一张Dota地图-Roc Dota。随后，经过多个玩家进一步完善，以及IceFrog的多次修正和更新，游戏最终定格为两个阵营，玩家需要操作英雄，通过摧毁对方遗迹建筑来取得最终的胜利。这种多人在线的竞技模式后来被称为“Dota类游戏”，对之后产生的多个竞技类游戏产生了深远的影响。
Ban&amp;amp;Pick机制 如何在比赛中选出一套让比赛的双方都能接受的英雄阵容，同时又要体现出竞技游戏的对抗性和平衡性。一般来说，游戏的对抗性表现为游戏元素的多元化。Dota这款游戏共有102名英雄，有两个阵营各选五名英雄分辨占据近卫和天灾两方，分三路进行对抗。当然五名英雄的职责各不相同，Carry位通常在地图的优势路发育，同时要有清晰的大局观，在比赛的后期发挥主力作用。Solo位，一般在中路对抗，该位置要求选手在中前期有很强的带节奏能力。Ganker，也称为抗压位，游走于各路，配合队友完成击杀对方英雄。剩余的两个位置称为辅助位，主要配合团队控制视野，帮助队友打出优势，从而在战略上压制对方。
假定Dota的英雄完全按照其所处的位置排列，（实战中完全不这样，经常原本12号位的英雄随着版本更迭称为辅助，反之亦然）如此每个位置的英雄也就约20名，如果我们再放弃掉一些不常用的英雄的话，实际让选手能够顺畅选择的英雄其实不过尔尔。这时，如何让场上选手得以公平竞技打出激情，就必须通过一套规则，选出一套让比赛双方均能够接受的阵容，从而增加比赛的观赏性。那么，选手们应当如何选取自己心仪的英雄呢？
Dota的设计者“IceFrog”最终采用了一套&amp;rdquo;Ban&amp;amp;Pick&amp;rdquo;机制，这套机制来源于千年之前一个在法国的英国人的发明。
陪审制 1135年，英国国王亨利一世去世，根据一份协定，英国国王的继承者将由自幼生长在法国的青年亨利二世于1154年担任。亨利二世是一位非常有野心的国王，开创了一个时代，人称“金雀花王朝”。可刚上任的他作为一个“外国人”，只要想在一个地区内树立权威，那么司法权则应当是极为重要的手段之一。在当时，高贵的法国贵族又如何听得懂英格兰的那些土话呢？如果听不懂别人说什么，作为一国之君，又如何来审理民间纠纷以确立自己的声望？亨利二世又能以怎样的方式，设计出一套完美的制度呢？
最开始的时候，每当出现土地方面的诉讼时，会由法院发给争议双方一纸令状(令状或由司法大臣发布)，命令争议双方找来十二名和本案无关的人士在上帝面前发誓之后，做出对案件事实方面的裁决。而亨利二世则带人组成巡回法院，当他巡回到该地之后，对案件做出裁决。毕竟，由自己亲手提拔的大臣是懂法语的，自己审完案子下发，再由手下将其翻译成英语传达，是再好不过的事了。
但是，那十二个与本案无关的人，是怎么选出来的？
陪审员的选择一开始是随机选，而且选的比较多。然后双方会有机会了解备选的人选，并且通过辩论来决定留下谁。当然，双方都会尽量留下对自己有利的陪审员（Pick），主要是根据职业，性别，年龄来判断是否会同情被告。还有几个机会可以不必给出理由而否定某一个陪审员（Ban）。最后确定一个名单。名单上的人就得去了……因为这个是公民义务的一部分，除非有特殊原因，否则必须去，要是故意不去那就要被起诉。同时，还会有几个备用人选，也必须去，以防有人生病或者出事来不了。 还有一个是选择陪审员的时候会尽量避免选择某些职业，比如律师，法学院的学生，老师，教授等等。主要是排除类似“权威”或者习惯教育指导别人的人，以防以一人之力左右整个陪审团的意见。
对Dota来说，情况也正是如此，“IceFrog”必须采取一套制度，让选手们首选去掉那些对自己特别不利的英雄，从而不会让先选英雄的一方率先抢走版本当中最热门也是最厉害的英雄，以降低游戏的对抗程度。说白了，对Dota来说，选手们竞技环境越是公平，游戏的对抗程度越高，游戏的活力也就越持久。
不过这套制度并非一经制定就一成不变，而是会根据玩家不断的反馈与游戏平衡的调整随之改进。Dota的Ban&amp;amp;Pick规则方式的更迭几乎和Dota的游戏版本更迭频率一致。从Dota6.28X版本开始到现在的Dota6.83，每一代版本非但在游戏本身的平衡性上做出了重大调整，在Ban&amp;amp;Pick规则上，&amp;rdquo;IceFrog&amp;rdquo;也从未掉以轻心。不论是Ban&amp;amp;Pick时间还是顺序，甚至于到底Ban掉多少名英雄，也是历经多个版本才最终确立。</description>
    </item>
    
    <item>
      <title>回首2014</title>
      <link>https://morven.life/posts/a_backward_glance_of_2014/</link>
      <pubDate>Fri, 26 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/a_backward_glance_of_2014/</guid>
      <description> 一年将尽，一年伊始，兜兜转转，2014年就这样走近年末，不禁让人措手不及。似乎是一样的时光、一样的节奏、一样的人物，变换着不同的场景、不同的面孔、不同的心情，重重叠叠过去了一年。过去的一年，虽然忙碌，但也收获不少。如果一定要说一些年度关键词，那就是学分与课程、百度实习以及校园招聘。
学分与课程 从去年的9月份到今年的五月初，忙碌的两个学期，选择修完了研究生的大部分课程，这样五月份以后就可以外出实习。总的来看，研究生的课程是本科课程的扩展与深入。比如《高级数据库》这门课，本科也开，所讲内容大部分是数据库基本知识，关系型数据库设计以及SQL语句优化。研究生阶段则更深入，更倾向于数据库读写性能分析，各种关系型数据库横向对比，动手实践特殊类型的数据库设计，当然也包括对非关系型数据库的探讨。其他课程与此类似，包括高级网络，分布式设计与分析，数据挖掘与知识发现等等，基本上覆盖了计算机相关专业的主要课程。也利用研一空闲时间，复习了数据结构和算法，刷LeetCode，填本科阶段挖下的坑。到五月份主要课程都已修完，貌似还多修了两门课。研究生的成绩普遍较高，平均分达到了90分左右（现在才意识到了要好好学习，哈哈～）。研究生阶段还有一门研讨课，不过我选的研讨课自己不是特别感兴趣，所以也没有花太多的时间在上面，水水而已。
百度实习 关于今年的实习，本来想专门写一篇文章总结一下，后来由于找工作忙碌就搁置了（其实都是借口），这里就简单总结一下。今年5月份拿到百度网页搜索部的实习Offer，之前听说百度实习基本能留下正式工作，但是当时选择去百度实习的原因不是想拿百度的正式Offer，而是想去体验一下国内顶级的互联网公司，同时也增加自己的项目经验，为下半年的找工作打下基础。 先说说面试吧，百度的实习面试分为两轮技术面，HR都会跟你预约面试时间，这一点还是非常赞的。第一轮面试的大部分是基础数据结构与算法，当然也问了一些关于C++的问题，比较轻松。第二轮面试就比较开放了，当时我的面试官就是后来我实习的mentor，问题不是特别多，第一个是操作系统内存管理的，接下来，问了我对于Mysql的认识，包括mysql读写极限的多少，以及底层一些读写机制等等，最后就是一道算法题，自己回答的不是很好。不过还好，大约一周以后，就收到了Offer。 5月初正式入职，在百度网页搜索部，我所在的team在上海Office有4个DEV，主要负责抓取工作，包括百度搜索的抓取以及其他各个产品线的抓取。百度为了规范公司各个产品线的抓取，避免不必要的封禁和抓取混乱的现状，特意将抓取平台化，命名为CSPUB，公司内部各个产品线可以在CSPUB上注册，编辑抓取目标然后发起抓取。主要的开发语言是C++和PHP，自己平时也用Python写一些脚本检测线上机器的运行状况。百度确实是个年轻有活力的公司，内部员工干活都很积极，对新技术热情很高，部门内部经常会有一些技术分享，可以学到不少在学校根本不会接触到的架构知识。我的mentor是个对工作效率追求极致的人，一度使我感觉跟不上节奏，后来习惯了之后才发现自己受益颇多。到了8月份，由于开始找工作，自己也没有留上海的想法，遂辞职，返校找工作。
校园招聘 今年最重要的事情应该就是找工作了，可就是这最重要的事儿，我却刚开始就错过了一次绝佳的机会－阿里校招。不过阿里今年的校招也是让人不能理解，9月份之前就开始笔试，而且是线上笔试。我笔试当天晚上才得知消息，为时已晚。不过我对于自己在哪里工作找已有想法，因为女朋友的缘故，我会优先选择回西安工作。所以，当周围的同学都在准备BAT面试的时候，我在关注西安为数不多的IT公司校招情况。机缘巧合，之前发给IBM西安office HR的简历被筛选了，HR安排我去公司笔试和面试。接下来的一周我在西安参加了笔试一次面试三次，虽然HR说十一之后才会有消息，但当时感觉应该十拿九稳了。不出意料，回到南京之后，面试Manager通过电话给了口头offer，薪水比想象的要高，再加上之前有在IBM的实习经历，应聘职位也和自己的方向比较相关，再次考虑到在西安IT行业不景气的现状，所以也基本定下来了。当然，这时候还没到十月份，校招才刚开始，所以也准备了其他公司的笔试面试，包括百度，大众点评以及一些小公司。其中百度和大众点评都拿到Offer。在西安呆的一周内错过了腾讯，美团的校招。进入11月份基本周围同学都拿到Offer，校招也应该结束了。 总的来说，校招没必要很纠结，没必要各个公司招聘都参加，那要只会心力交瘁。想清楚自己适合什么样的公司，决定去哪个城市发展，这样自己目标就明确多了，准备起来也有条不紊，自然结果也不会很差。
新一年的愿望 希望将愿望写出来，能够更加有动力去实现。
 希望抓住最后的校园时光，感谢所有的老师，和最好的哥们儿好好告别。 希望公司入职能去好的team，找到nice的mentor，做自己想做的事情。 希望能抽出更多的时间看书，不管是技术方面的书籍还是人文历史方面的。 希望能学点设计方面的知识，尤其是UI，UX方面的。 希望在工作中锻炼自己的口语，再不要吃老本。 希望多多参与开源的项目，保持博客更新的频率。 希望能多陪陪家人出去旅游&amp;hellip;  </description>
    </item>
    
    <item>
      <title>数字签名与数字证书</title>
      <link>https://morven.life/notes/the_digital_signature_and_digital_certificate/</link>
      <pubDate>Mon, 06 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/notes/the_digital_signature_and_digital_certificate/</guid>
      <description>在之前的密码学笔记主要是介绍密码学的基础知识，包括两种加密算法的原理，引入在非对称加密算法中数字证书（Digital Certificate）的概念。这篇笔记将继续探讨什么是数字证书，不过在了解它之前，先得知道什么是数字签名（Digital Signature）。
关于数字签名和数字证书的概念，有一篇非常经典的文章，本文的大部分内容来自于那篇文章，喜欢读英文原版的请移步至：http://www.youdzone.com/signature.html
Bob生成了自己的（公钥，私钥）对：
Bob将自己的公钥分发给了他的朋友们：Pat，Susan，Daug
Susan要给Bob写一封保密的信件，写完后用Bob的公钥加密，就可以达到保密的效果。Bob收到信件之后用自己的私钥来解密，就可以看到信件的内容。这里假设Bob的私钥没有泄露（私钥是十分敏感的信息，一定要注意保管，泄露私钥那么文章里很多假设都不成立），即使信件被别人截获，信件内容也无法解密，也就是说这封信的内容不会有第三个人知道。
Bob给Susan回信，决定采用&amp;rdquo;数字签名&amp;rdquo;：他写完后先用Hash函数，生成信件的摘要（Digest），然后，在使用自己的私钥，对这个摘要进行加密，生成&amp;rdquo;数字签名&amp;rdquo;（Digital Signature）。
Bob将这个数字签名，附在信件里面，一起发给Susan。
Susan收到信件之后，对信件本身使用相同的Hash函数，得到当前信件内容的摘要，同时，取下数字签名，用Bob的公钥解密，得到原始信件的摘要，如果两者相同就说明信件的内容没有被修改过。由此证明，这封信确实是Bob发出的。
但是，更复杂的情况出现了。Daug想欺骗Susan，他伪装成Bob制作了一对（公钥，私钥）对，并将公钥分发给Susan，Susan此时实际保存的是Daug的公钥，但是还以为这是Bob的公钥。因此，Daug就可以冒充Bob，用自己的私钥做成&amp;rdquo;数字签名&amp;rdquo;写信给Susan，而Susan用假的鲍勃公钥进行解密。一切看起来完美无缺？
Susan觉得有些不对劲，因为她并不确定这个公钥是不是真正属于Bob的。于是她想到了一个办法，要求Bob去找&amp;rdquo;证书中心&amp;rdquo;（Certificate Authority，简称CA），为公钥做认证。证书中心用证书中心的私钥，对Bob的公钥和一些相关信息一起加密，生成&amp;rdquo;数字证书&amp;rdquo;（Digital Certificate）。
一旦Bob拿到数字证书以后，就可以放心写信给任何人了。只需要在信件内容的后面附上数字签名的同时，再附上数字证书就行了。
Susan收到信件之后，首先使用用CA的公钥（一般都是公开的）解开数字证书，就可以拿到Bob真实可信的公钥了，然后就能用此公钥解密数字签名进一步验证信件内容是否被篡改过。
由此可见，&amp;rdquo;数字证书&amp;rdquo;就是解决身份认证的问题，就如同现实中我们每一个人都要拥有一张证明个人身份的身份证或驾驶执照一样，以表明我们的身份或某种资格。数字证书是由权威公正的第三方机构即Certificate Authority(CA)中心签发的，确保信息的机密性和防抵赖性。对于一个大型的应用环境，认证中心往往采用一种多层次的分级结构，各级的认证中心类似于各级行政机关，上级认证中心负责签发和管理下级认证中心的证书，最下一级的认证中心直接面向最终用户。</description>
    </item>
    
    <item>
      <title>密码学基础</title>
      <link>https://morven.life/notes/the_basic_of_cryptology/</link>
      <pubDate>Tue, 16 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/notes/the_basic_of_cryptology/</guid>
      <description>密码学（Cryptography） 密码学是研究编制密码和破译密码的技术科学。研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学。 密码是通信双方按约定的法则进行信息特殊变换的一种重要保密手段。依照这些法则，变明文为密文，称为加密变换；变密文为明文，称为脱密变换。密码在早期仅对文字或数码进行加、脱密变换，随着通信技术的发展，对语音、图像、数据等都可实施加、脱密变换。
密码算法 什么是密码算法（Cryptography Algorithm），通常是指加、解密过程所使用的信息变换规则，是用于信息加密和解密的数学函数。对明文进行加密时所采用的规则称作加密算法，而对密文进行解密时所采用的规则称作解密算法。加密算法和解密算法的操作通常都是在一组密钥的控制下进行的。
什么是密钥？密钥（Secret Key）是密码算法中的一个可变参数，通常是一组满足一定条件的随机序列。用于加密算法的叫做加密密钥，用于解密算法的叫做解密密钥，加密密钥和解密密钥可能相同，也可能不相同。
加密算法根据根据密钥的不同分为两类，对称加密算法(Symmetric-key Algorithm)和非对称加密算法(Asymmetric Key Encryption Algorithm)。
对称加密 首先，让我们先从一个情景开始讲起。
比如张三学习比李四好，李四就想在考试的时候让张三“帮助”一下自己，当然，他们俩不可能像我们平常对话一样说，第一题选A，第二题选B等等，为什么？因为监考老师明白他俩在谈论什么，也就是说这种沟通交流方式属于“明文”，所以李四就想：“我需要发明一种，只有我和张三明白的交流方式”，那李四做了什么呢？恩，李四去找张三说：“当我连续咳嗽三声的时候你看我，然后如果我摸了下左耳朵，说明你可以开始给我传答案了，如果没反应，那说明我真的是在咳嗽&amp;hellip;”， 然后，怎么传答案呢？很简单，“你摸左耳朵代表A, 摸右耳朵代表B，左手放下代表C，右手放下代表D”，好了，这就是他们的“算法(规则)”，将信息的一种形式(A,B,C,D)，这里我们称为“明文”，转换成了另一种形式(摸左耳朵，摸右耳朵，放左手，放右手)，这里称为“密文”，经过这种转换，很显然监考老师不会明白这些“密文”，这样，张三和李四就通过“密文”的形式实现了信息的交换。
对称加密算法也叫单钥加密（Private Key Cryptography），加密和解密过程都用同一套密钥。历史上，人类传统的加密方法都是前一种，比如二战期间德军用的Enigma电报密码，莫尔斯电码也可以看作是一种私钥加密方法。
结合前面的例子对应一下，密钥就是“将(A,B,C,D)转换成(摸左耳朵，摸右耳朵，放左手，放右手)”这么一个规则。
 实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。
 这句话很好理解了吧，密钥是张三和李四间共同的秘密！只有他俩事先知道。 所以，为什么叫对称加密呢，你可以这么理解，一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下：
明文 &amp;lt;-&amp;gt; 密钥 &amp;lt;-&amp;gt; 密文  目前常见的对称加密算法有：
DES、3DES、AES、Blowfish、IDEA、RC5、RC6。  非对称加密 非对称加密算法也称为双钥加密（Public Key Cryptography），加密和解密过程用的是两套密钥。非对称加密是一种比对称加密更加优秀的加密算法。对称加密的密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。 在非对称加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。 对称加密的原理如下：
 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。 所有的（公钥, 私钥）对都是不同的。 用公钥可以解开私钥加密的信息，反之亦成立。 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。  在对称加密体系中，公钥用来加密信息，私钥用来数字签名。 比如，李四想给张三发送密文。于是李四开始给张三发消息：
李四： “hi哥们，我想给你发个密文，把你的公钥给我发过来。” 张三： “没问题的，这是我的公钥： d#8yHE8eU#hb*!neb，用这个公钥加密你的信息后给我发过来吧” 李四： “这是我想对你说的话： *&amp;amp;#@uehuu(**#eehu&amp;amp;$##bfeu&amp;amp;&amp;amp;”  为什么公开问公钥？非对称解密算法的强大之处就在这里！公钥可以随意分发，所以即使第三方截取了，也只是知道该公钥而已，但是要是想解密使用该公钥加密的密文！只有一个人可以办得到！就是张三！ 为什么？李四使用张三的公钥加密的信息，只有张三的公钥所对应的私钥，这里就是“张三私钥”，该私钥才可以解密！所以，没有张三私钥的第三方即时截取了这些密文，也破解不了！或者更严格的说在有限时间内比如说几千年内是暴力破解不出的！
非对称加密算法，首先要有一对key，一个被称为私钥（Private Key），一个成为公钥（Public Key），然后可以把公钥分发给想给你传密文的用户，然后用户使用该公钥加密过得密文，只有使用私钥才能解密，也就是说，只要保存好你的私钥，就能确保别人想给你发的密文不被破解。正因为，这种加密是单向的，所以被称为非对称加密算法。
这种加密算法应用非常广泛，SSH, HTTPS, TLS，电子证书，电子签名，电子身份证等等。
因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。这就是数字证书的作用了，接下来的文章将会继续探讨什么是数字签名以及数字证书。</description>
    </item>
    
    <item>
      <title>Big Endian &amp; Little Endian</title>
      <link>https://morven.life/posts/the_story_of_big_and_little_endian/</link>
      <pubDate>Wed, 26 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/the_story_of_big_and_little_endian/</guid>
      <description>字节序 谈到字节序，必然要牵扯到两大CPU派系。那就是Motorola的PowerPC系列CPU和Intel的x86系列CPU。PowerPC系列采用big endian方式存储数据，而x86系列则采用little endian方式存储数据。那么究竟什么是big endian，什么又是little endian呢？ 其实Big Endian是指低地址存放最高有效字节（MSB），而Little Endian则是低地址存放最低有效字节（LSB）。 文字说明比较抽象，下面举个例子用图像来说：
Big Endian
 低地址 高地址 -----------------------------------------&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | 12 | 34 | 56 | 78 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  Little Endian
 低地址 高地址 -----------------------------------------&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | 78 | 56 | 34 | 12 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  从上面两图可以看出，采用Big Endian方式存储数据是符合我们人类的思维习惯的，而Little Endian&amp;hellip; 为什么要注意字节序的问题呢？你可能这么问。当然，如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。但是，如果你的程序要跟别人的程序产生交互呢？在这里我想说说两种语言。C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则唯一采用big endian方式来存储数据。试想，如果你用C/C++语言在x86平台下编写的程序跟别人的JAVA程序互通时会产生什么结果？就拿上面的0x12345678来说，你的程序传递给别人的一个数据，将指向0x12345678的指针传给了JAVA程序，由于JAVA采取big endian方式存储数据，很自然的它会将你的数据翻译为0x78563412。什么？竟然变成另外一个数字了？是的，就是这种后果。因此，在你的C程序传给JAVA程序之前有必要进行字节序的转换工作。 无独有偶，所有网络协议也都是采用big endian的方式来传输数据的。所以有时我们也会把big endian方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。ANSI C中提供了下面四个转换字节序的宏。
Big Endian：最高字节在地址最低位，最低字节在地址最高位，依次排列。 Little Endian：最低字节在最低位，最高字节在最高位，反序排列。
Endian指的是当物理上的最小单元比逻辑上的最小单元小时，逻辑到物理的单元排布关系。咱们接触到的物理单元最小都是byte，在通信领域中，这里往往是bit，不过原理也是类似的。
An Example:
如果我们将0x1234abcd写入到以0x0000开始的内存中，则结果为 big-endian little-endian 0x0000 0x12 0xcd 0x0001 0x34 0xab 0x0002 0xab 0x34 0x0003 0xcd 0x12</description>
    </item>
    
    <item>
      <title>IBM实习总结</title>
      <link>https://morven.life/posts/internship-at-ibm/</link>
      <pubDate>Mon, 01 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/posts/internship-at-ibm/</guid>
      <description>今天上午和新来的实习生交接了自己的工作，中午约同事们一起吃了午饭，之后很快办完了离职手续，自己为期6个多月的IBM实习也画上了句号，不管是不是完美，对于我自己来说，大学四年的第一份实习无疑对我价值颇高。这篇文章我主要说说我在IBM实习的经历以及感受。
实习时间 我出去实习的时间比较晚，根据学院规定暑假就可以开实习，时间不能少于6个月，所以最好应该在4，5月份找实习，而我在4，5月份却忙于备考GRE和Toefl，自然也错过了找实习的黄金时间。暑假结束后，我才开始计划找实习。开始一心想着去互联网公司，也正因为一直在等待这样的机会而浪费了不少时间。直达9月份，刷小百合看到一个不错的实习机会，也就是接下来6个多月我所在的IBM JTC部门。当时心动的主要原因是这个实习职位所在的Team是做JVM的，也是自己的兴趣方向所在，所以果断投了简历。
面试 IBM的面试分为技术面和英文面，可能当时急缺实习生，所以面试安排得很紧凑。自己也比较幸运，因为Team里有已经毕业的学长Ray，多少会有加分：）。因为是JVM小组，所以技术面都是关于Java的，比如Java多线程，IO，容器类以及反射机制等，没有问算法题。现在回想起来，这些知识确实在每天的实习工作中都会有所接触。接下来是英文面，主要面试口语。因为是招聘实习生，所以也没有太高的要求，基本的听说读写熟练就没有问题。最后面试官问我有没有问题想问他的，我进一步问了关于实习职位的工作内容，当时的面试官，也就是后来我的mentor Sanhong，人非常nice，blabla&amp;hellip;讲了一大堆，虽然当时也不是很懂，但真心觉得很NB。过了一个周左右，收到面试通过的邮件，几天后搭乘了去上海的动车，开始了我的IBM实习。
工作环境 IBM的工作环境很不错，整个办公室是个很大的开放式的环境，整个部门，从部门老大，到Manager，到实习生都在这里工作。我去的时候领到了一台旧电脑，是的，实习生用的都是旧电脑，不多这也完全不影响开发，因为基本的开发测试都是在云端，通过SecureCRT SSH登录到云端Linux。也正是从这开始彻底喜欢上了Unix/Linux哲学： &amp;gt; simple and beautiful &amp;ndash;Wikipedia
对于习惯了IDE的我一开始会有些不适应，不过后来发现在Terminal下工作效率丝毫不逊于IDE。
工作内容 IBM比较注重基础性软件研发，特别在中国成立CDL(China Development Lab)，我所在的部门JTC(Java Technology Center)正式属于CDL，而我所在的小组从事的是JVM的开发。IBM的J9 JVM与Oracle 的Hotspot VM齐名，是两大主流的JVM之一，为IBM许多Java产品提供支持，比如WebSphere，以及一些开源的产品如Apache Harmony。现在我们team的工作是与加拿大以及印度的同事合作，基于J9VM开发Multitennancy JVM，通过在单一的多租户 JVM 中运行多个应用程序，云系统可以加快应用程序的启动时间，并减少其内存占用。这将作为IBM Java8的一个新特性。因为是实习生，所以我的工作大多是于解决Bug，性能调优以及测试相关。我的mentor Sanhong是个技术大牛，人也非常nice，我很庆幸能遇到这样的导师。mentor对我的帮助不仅是技术上的提高，更多的是工作方式的改进，这些东西在学校的绝对学习不到的。
IBM软件过程管理 特别要提到的是IBM的软件过程管理方式，IBM使用敏捷软件开发方式，更具体点儿是Scrum，每两周一次Sprint迭代，每天都会下午选个时间Daily Scrum Meeting，控制在15分钟左右，每个人都必须发言，也包括实习生，向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）。同时，Team会做到每天至少一个Build，即一个成功编译，可以运行的版本。虽然这些东西在学校也学过，也有实践课程可以体验，但是感觉多少还是是纸上谈兵。如今在算是真正有机会在工作机会中体会Scrum。和其他外企一样，IBM工作语言是英语，虽然平时和同事交流可以用中文，但是邮件以及Message全部都是英文，而且每周一次国际会议也是用英文交流。
总结 在IBM工作，最重要的是团队合作，虽然平时工作的压力不大，实习生见见“世面”是可以的，但如果真要在技术上有所提升，建议IBM和其他类似的外企可以不用去了，可以去百度，阿里这样的互联网公司，对于锻炼自己的技术应该帮助更大。当然，也可以选择一些创业公司，现在正值互联网蓬勃发展的时候，去小型创业公司，自己可以独当一面，项目经验提升也是必然的。当然小型公司也有自己的缺陷，缺少自己的平台，过多利用现有的技术做产品，对于想从事底层操作系统的基础架构的同学就要重新考虑了。 不过总体来说，通过这次的实习经历，我学习到了不少的东西，不只是技术上，更多是关于工作方式以及团队意识。当然，也第一次去魔都体验了码农的生活，将自己在学校学习的知识利用到了实践当中，赚了自己的第一笔钱。</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://morven.life/common/about/</link>
      <pubDate>Sat, 16 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>https://morven.life/common/about/</guid>
      <description>Hi, This is Morven, graduated from Nanjing University with Bechalor and Master degree in 2015, now working as a software engineer at IBM focusing on cloud technology. I generally use morvencao as my id on the Internet. I am a strong advocate and believer of Open Source Software and love reading, thinking, programming and everything challenging and interesting.
Reach me:
 Gmail Github Twitter Medium Instagram  </description>
    </item>
    
  </channel>
</rss>